*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_reportlistener.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _reportlistener AS reportlistener 		&& Adds error handling, session handling, and other common report run-time tasks to ReportListener base class.  Provides the ability to chain a series of reports as well as the means to delegate or share output activities to a chain of Listener-successors.
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: addreport		&& Adds to the class's collection of ReportFileNames, optionally associating REPORT FORM clauses and a listener for the specified report.
		*m: adjustreportpagesinfo		&& Hook to allow subclasses to decide how to associate the page numbers for each report in a collection with the member array representing page numbers, during the runReports method.
		*m: allowmodalmessages_assign
		*m: appname_assign
		*m: clearerrors		&& Resets the class's error status.
		*m: commandclausesfile_assign
		*m: fillruncollector		&& Abstract method to set up up runCollector object with contents at whatever point is appropriate in a given implementation.
		*m: getfrxstartupinfo		&& Provides a hook for gathering FRX information during BeforeReport method processing.
		*m: getlasterrormessage		&& Provides information about the last error that occurred.
		*m: invokeoncurrentpass		&& Provides a hook for listeners to evaluate whether they wish to generate output or perform other actions during the current report execution pass.
		*m: isfrxswapcopypresent		&& Indicates whether the original CommandClauses.File value has been swapped for a temporary copy during a report run.
		*m: issuccessor_assign
		*m: lignoreerrors_assign
		*m: listenertype_assign
		*m: outputtype_assign
		*m: pagelimitinsiderange_assign
		*m: pagelimitquietmode_assign
		*m: pagelimit_assign
		*m: pagetaillimit_assign
		*m: pagetoplimit_assign
		*m: popglobalsets		&& Provides a hook for Listeners to restore global settings not scoped to a data session after saving them with PushGlobalSets.
		*m: prepareerrormessage		&& Organizes common error information values (nError, cMethod, nLine, cName, cMessage, cCodeLine) into a coherent string for presentation to the user.
		*m: preparefrxswapcopy		&& Provides an FRX copy on disk, in the same path/location as the original FRX if possible to support relative file references, for use during a report run.  Returns fully-qualified temporary file name it generates for the copy.
		*m: pushglobalsets		&& Provides a hook for Listeners to save global settings not scoped to a data session for later restoration with PopGlobalSets.
		*m: quietmode_assign
		*m: removefrxswapcopy		&& Removes an FRX file and its matching FRT file from disk, if present.
		*m: removereports		&& Removes report filenames as well as associated clauses and listeners from this Listeners' various collections.
		*m: resetcalladjustobjectsize		&& Evaluates whether this reportlistener's activity requires calls to AdjustObjectSize method for any layout controls on this report run.
		*m: resetcallevaluatecontents		&& Evaluates whether this reportlistener's activity requires calls to EvaluateContents method for any layout controls on this report run.
		*m: resetdatasession		&& Sets the DataSessionID to the session where the Listener originated.
		*m: resetdynamicmethodcalls		&& Evaluates whether AdjustObjectSize and EvaluateContents methods should be called for a report run, for this reportlistener's activity or as requested by Successor chain.
		*m: resetruncollector		&& Abstract method to clean up runCollector object at whatever point is appropriate in a given implementation.
		*m: runreports		&& Executes a series of REPORT FORM commands according to the instructions in the ReportFileNames, ReportClauses, and Listeners collections.  Optionally clears collection after run and issues the REPORT FORM commands without OBJECTreferences.
		*m: setcurrentdatasession		&& Sets the DataSessionID to the data session holding report's data tables.
		*m: setfrxdatasession		&& Sets the DataSessionID to the data session in which the Engine has opened a readonly copy of the report file as a table for the Listener's use.
		*m: setfrxdatasessionenvironment		&& Provides a hook for classes to determine the datasession-scoped SETs they wish to add to the private FRX data session.
		*m: setfrxrunstartupconditions		&& Hook method called in BeforeReport, allowing you to set up CommandClauses properties or other attributes required by your class.
		*m: setsuccessordynamicproperties		&& Provides a hook for the Listener to share information changed by the Engine with a succession of Listeners, during the run of a report.
		*m: sharedgdiplusgraphics_assign
		*m: sharedlistenertype_assign
		*m: sharedoutputpagecount_assign		&& Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
		*m: sharedpageheight_assign
		*m: sharedpageno_assign
		*m: sharedpagetotal_assign
		*m: sharedpagewidth_assign
		*m: successor_assign
		*p: appname		&& Localizable application name string for use in user feedback.
		*p: commandclausesfile		&& Allows saving and restoring of the original CommandClauses.File value by any derived class that permits dynamic FRX-fileswapping during LoadReport.
		*p: drivingalias		&& Holds the alias of the table or cursor driving the report scope.
		*p: frxheaderrecno		&& Stores the header record number for the Windows platform in cross-platform FRXs.
		*p: haderror		&& Provides a flag indicating whether an error occurred.
		*p: isrunning		&& Provides a flag to indicate whether a report run is underway.  When IsRunning is true, the class may wish to disallow certain activities or method calls.
		*p: isrunningreports		&& Provides a flag to indicate this ReportListener is running a series of reports using its collection.
		*p: issuccessor		&& Indicates whether this Listener is chained to one or more others to provide output during a report run.  When .T., this Listener was not the object referenced in the REPORT FORM command OBJECT clauses.
		*p: lasterrormessage
		*p: lignoreerrors		&& Provides a flag to determine how this class handles activities subsequent to an error.
		*p: listenerdatasession		&& Saves the DataSessionID in which the Listener originated.
		*p: listeners		&& Collection of ReportListeners associated with each report in this Listener's ReportFileNames collection.
		*p: pagelimit		&& If > 0, represents the highest number of pages allowed in a report run (potentially across multiple reports using NOPAGEEJECT).  Especially useful for ListenerTypes 1 and 3, to avoid GDI resource issues, but can provide abbreviated results for any type
		*p: pagelimitinsiderange		&& If .T., indicates that pageTopLimit and pageTailLimit provide an inside range rather than beginning and end of report contents.  Makes pageTopLimit and pageTailLimit similar to RANGE clause, but active over multiple reports with NOPAGEEJECT.
		*p: pagelimitquietmode		&& Indicates whether the class provides user feedback when the report results are limited because the run exceeded the specified pageLimit.
		*p: pagetaillimit		&& If > 0, represents the lowest number of pages for "tail" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTopLimit or alone. No user feedback provided.
		*p: pagetoplimit		&& If > 0, represents the highest number of pages for "top" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTailLimit or alone. No user feedback provided.
		*p: reportclauses		&& Stores REPORT FORM command clauses associated with each report in the ReportFileNames collection.
		*p: reportfilenames		&& Stores the filenames of reports to be managed and executed in a series.
		*p: reportusesprivatedatasession		&& Provides a flag to indicate whether this report shares the data session from which it was executed or maintains a private data session.
		*p: runcollector		&& Placeholder available to hold extension output generated during a report run. Property may contain an alias for a cursor holding property names and values, a collection object reference, or an empty-type object reference.
		*p: sharedgdiplusgraphics		&& Provides a readwrite copy of the the Engine's GDIPlusGraphics handle which the Listener can share with a succession chain.
		*p: sharedlistenertype		&& Provides a readwrite copy of the the Engine's ListenerType property which the Listener can share with a succession chain.
		*p: sharedoutputpagecount		&& Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
		*p: sharedpageheight		&& Shares information gathered by the GetPageHeight method with other Listeners linked in a succession chain.
		*p: sharedpageno		&& Provides a readwrite copy of the the Engine's PageNo property which the Listener can share with a succession chain.
		*p: sharedpagetotal		&& Provides a readwrite copy of the the Engine's PageTotal property which the Listener can share with a succession chain.
		*p: sharedpagewidth		&& Shares information gathered by the GetPageWidth method with other Listeners linked in a succession chain.
		*p: successor		&& An object reference to the next Listener in a succession chain.
		*a: reportpages[1,0]		&& Holds accumulated page count  info when this class runs a collection of reports as a series. Can be used in report expressions or checked after a report run (if .removeReports has not been called).  Set in adjustReportPagesInfo.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED drivingalias,frxheaderrecno,haderror,isrunning,isrunningreports,lasterrormessage,listeners,reportclauses,reportfilenames,runcollector
	AllowModalMessages = (INLIST(_VFP.Startmode, 0, 4))
	appname = ("VFP Report Listener")		&& Localizable application name string for use in user feedback.
	commandclausesfile = .NULL.		&& Allows saving and restoring of the original CommandClauses.File value by any derived class that permits dynamic FRX-fileswapping during LoadReport.
	drivingalias = ("")		&& Holds the alias of the table or cursor driving the report scope.
	FRXDataSession = -1
	frxheaderrecno = 1		&& Stores the header record number for the Windows platform in cross-platform FRXs.
	Height = 23
	lasterrormessage = ("")
	listenerdatasession = 1		&& Saves the DataSessionID in which the Listener originated.
	listeners = (NULL)		&& Collection of ReportListeners associated with each report in this Listener's ReportFileNames collection.
	Name = "_reportlistener"
	pagelimit = -1		&& If > 0, represents the highest number of pages allowed in a report run (potentially across multiple reports using NOPAGEEJECT).  Especially useful for ListenerTypes 1 and 3, to avoid GDI resource issues, but can provide abbreviated results for any type
	pagelimitinsiderange = .F.		&& If .T., indicates that pageTopLimit and pageTailLimit provide an inside range rather than beginning and end of report contents.  Makes pageTopLimit and pageTailLimit similar to RANGE clause, but active over multiple reports with NOPAGEEJECT.
	pagelimitquietmode = .F.		&& Indicates whether the class provides user feedback when the report results are limited because the run exceeded the specified pageLimit.
	pagetaillimit = -1		&& If > 0, represents the lowest number of pages for "tail" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTopLimit or alone. No user feedback provided.
	pagetoplimit = -1		&& If > 0, represents the highest number of pages for "top" section of report run (potentially across multiple reports using NOPAGEEJECT).   Use with pageTailLimit or alone. No user feedback provided.
	QuietMode = (NOT INLIST(_VFP.Startmode, 0, 4))
	reportclauses = (NULL)		&& Stores REPORT FORM command clauses associated with each report in the ReportFileNames collection.
	reportfilenames = (NULL)		&& Stores the filenames of reports to be managed and executed in a series.
	runcollector = (NULL)		&& Placeholder available to hold extension output generated during a report run. Property may contain an alias for a cursor holding property names and values, a collection object reference, or an empty-type object reference.
	sharedgdiplusgraphics = 0		&& Provides a readwrite copy of the the Engine's GDIPlusGraphics handle which the Listener can share with a succession chain.
	sharedlistenertype = -1		&& Provides a readwrite copy of the the Engine's ListenerType property which the Listener can share with a succession chain.
	sharedoutputpagecount = 0		&& Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
	sharedpageheight = 0		&& Shares information gathered by the GetPageHeight method with other Listeners linked in a succession chain.
	sharedpageno = 0		&& Provides a readwrite copy of the the Engine's PageNo property which the Listener can share with a succession chain.
	sharedpagetotal = 0		&& Provides a readwrite copy of the the Engine's PageTotal property which the Listener can share with a succession chain.
	sharedpagewidth = 0		&& Shares information gathered by the GetPageWidth method with other Listeners linked in a succession chain.
	successor = (NULL)		&& An object reference to the next Listener in a succession chain.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="addreport" type="method" display="addReport" favorites="True" />
		<memberdata name="appname" type="property" display="appName" favorites="True" />
		<memberdata name="clearerrors" type="method" display="clearErrors" favorites="True" />
		<memberdata name="drivingalias" type="property" display="drivingAlias" favorites="False" />
		<memberdata name="getfrxstartupinfo" type="method" display="getFRXStartupInfo" favorites="False" />
		<memberdata name="getlasterrormessage" type="method" display="getLastErrorMessage" favorites="True" />
		<memberdata name="haderror" type="property" display="hadError" favorites="False" />
		<memberdata name="invokeoncurrentpass" type="method" display="invokeOnCurrentPass" favorites="True" />
		<memberdata name="isrunning" type="property" display="isRunning" favorites="False" />
		<memberdata name="isrunningreports" type="property" display="isRunningReports" favorites="False" />
		<memberdata name="issuccessor" type="property" display="isSuccessor" favorites="True" />
		<memberdata name="lasterrormessage" type="property" display="lastErrorMessage" favorites="False" />
		<memberdata name="lignoreerrors" type="property" display="lIgnoreErrors" favorites="False" />
		<memberdata name="listeners" type="property" display="listeners" favorites="False" />
		<memberdata name="popglobalsets" type="method" display="popGlobalSets" favorites="False" />
		<memberdata name="prepareerrormessage" type="method" display="prepareErrorMessage" favorites="True" />
		<memberdata name="pushglobalsets" type="method" display="pushGlobalSets" favorites="False" />
		<memberdata name="removereports" type="method" display="removeReports" favorites="True" />
		<memberdata name="reportclauses" type="property" display="reportClauses" favorites="False" />
		<memberdata name="reportfilenames" type="property" display="reportFilenames" favorites="False" />
		<memberdata name="reportpages" type="property" display="reportPages" favorites="False" />
		<memberdata name="reportusesprivatedatasession" type="property" display="reportUsesPrivateDataSession" favorites="True" />
		<memberdata name="resetdatasession" type="method" display="resetDataSession" favorites="False" />
		<memberdata name="runreports" type="method" display="runReports" favorites="True" />
		<memberdata name="setcurrentdatasession" type="method" display="setCurrentDataSession" favorites="False" />
		<memberdata name="setfrxdatasession" type="method" display="setFRXDataSession" favorites="False" />
		<memberdata name="setfrxdatasessionenvironment" type="method" display="setFRXDataSessionEnvironment" favorites="False" />
		<memberdata name="setsuccessordynamicproperties" type="method" display="setSuccessorDynamicProperties" favorites="True" />
		<memberdata name="sharedgdiplusgraphics" type="property" display="sharedGdiplusGraphics" favorites="True" />
		<memberdata name="sharedpagetotal" type="property" display="sharedPageTotal" favorites="True" />
		<memberdata name="sharedoutputpagecount" type="property" display="sharedOutputPageCount" favorites="True" />
		<memberdata name="sharedpageno" type="property" display="sharedPageNo" favorites="True" />
		<memberdata name="sharedpageheight" type="property" display="sharedPageHeight" favorites="True" />
		<memberdata name="sharedpagewidth" type="property" display="sharedPageWidth" favorites="True" />
		<memberdata name="listenerdatasession" type="property" display="listenerDataSession" favorites="False" />
		<memberdata name="successor" type="property" display="successor" favorites="True" />
		<memberdata name="setfrxrunstartupconditions" type="method" display="setFRXRunStartupConditions"/>
		<memberdata name="pagelimit" type="property" display="pageLimit" favorites="True" />
		<memberdata name="pagetoplimit" type="property" display="pageTopLimit" favorites="True" />
		<memberdata name="pagetaillimit" type="property" display="pageTailLimit" favorites="True" />
		<memberdata name="pagelimitquietmode" type="property" display="pageLimitQuietMode" favorites="True" />
		<memberdata name="pagelimitinsiderange" type="property" display="pageLimitInsideRange" favorites="True" />
		<memberdata name="resetdynamicmethodcalls" type="method" display="resetDynamicMethodCalls"/>
		<memberdata name="resetcallevaluatecontents" type="method" display="resetCallEvaluateContents"/>
		<memberdata name="resetcalladjustobjectsize" type="method" display="resetCallAdjustObjectSize"/>
		<memberdata name="runcollector" display="runCollector" type="property" favorites="True"/>
		<memberdata name="resetruncollector" display="resetRunCollector" type="method"/>
		<memberdata name="fillruncollector" display="fillRunCollector" type="method"/>
		<memberdata name="frxheaderrecno" display="frxHeaderRecno" type="property"/>
		<memberdata name="sharedlistenertype" display="sharedListenerType" type="property"/>
		<memberdata name="commandclausesfile" display="commandClausesFile" type="property" favorites="True"/>
		<memberdata name="preparefrxswapcopy" display="prepareFRXSwapCopy" type="method"/>
		<memberdata name="removefrxswapcopy" display="removeFRXSwapCopy" type="method"/>
		<memberdata name="isfrxswapcopypresent" display="isFRXSwapCopyPresent" type="method"/>
		<memberdata name="adjustreportpagesinfo" display="adjustReportPagesInfo" type="method"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addreport		&& Adds to the class's collection of ReportFileNames, optionally associating REPORT FORM clauses and a listener for the specified report.
		LPARAMETERS m.tcFRXName, m.tcClauses, m.toListener
		
		* can this one be done while report is running?
		* Possibly yes because we're always adding to the end.
		
		IF VARTYPE(m.tcFrxName) = "C" AND ;
		   (FILE(m.tcFRXName) OR FILE(FORCEEXT(m.tcFRXName,"FRX")) OR FILE(FORCEEXT(m.tcFRXName,"LBX")))
		
		   * If any is null, create all collections
		   * always add to all three collections
		   * to keep them in synch
		   
		   IF ISNULL(THIS.ReportFileNames) OR ;
		      ISNULL(THIS.ReportClauses) OR ;
		      ISNULL(THIS.Listeners) 
		      * start fresh
		      * this *shouldn't* be a datasession problem
		      * unless they're doing it from inside a form,
		      * but JIC:
		      LOCAL liSession
		      m.liSession = SET("DATASESSION")
		      THIS.resetDataSession()
		      THIS.ReportFileNames = CREATEOBJECT("Collection")
		      THIS.ReportClauses = CREATEOBJECT("Collection")
		      THIS.Listeners = CREATEOBJECT("Collection")
		      DIME THIS.ReportPages[1]
		      SET DATASESSION TO (m.liSession)
		   ENDIF
		   
		   THIS.ReportFileNames.Add(m.tcFRXName)
		   
		   DIME THIS.ReportPages[THIS.ReportFileNames.Count]
		   THIS.ReportPages[THIS.ReportFileNames.Count] = 0
		
		   IF VARTYPE(m.tcClauses) = "C"
		      THIS.ReportClauses.Add(m.tcClauses)
		   ELSE
		      THIS.ReportClauses.Add("")   
		   ENDIF
		
		   IF TYPE("toListener.BaseClass") = "C" AND ;
		      UPPER(toListener.BaseClass) == "REPORTLISTENER"
		      THIS.Listeners.Add(toListener)
		   ELSE
		      THIS.Listeners.Add(NULL)      
		   ENDIF
		   
		ELSE
		
		   * TBD: should we error here?   
		   
		ENDIF   
		
		
	ENDPROC

	PROTECTED PROCEDURE adjustreportpagesinfo		&& Hook to allow subclasses to decide how to associate the page numbers for each report in a collection with the member array representing page numbers, during the runReports method.
		LPARAMETERS m.tiReportIndex, m.tcClauses, m.toListener
		
		   * this is a *sketch*.  There are lots of different ways you
		   * could decide you wanted this to work.
		   * Subclasses can make this a multi-column array with 
		   * output pages (responsive to RANGE clause)
		   * represented as well, decide when to accumulate and when not, 
		   * or whether to set up a separate array col for 
		   * curr page versus total page,
		   * when to use listener ref data versus _PAGENO when a 
		   * listener ref is available,
		   * and if so how to deal with NORESET,
		   * when to use the shared/writable versions of FFC's SharedPageNo 
		   * and SharedPageTotal versus the readonly product versions, 
		   * because they are more similar to _PAGENO and _PAGETOTAL,
		   * whether page limits (top and tail) are significant, etc, etc, etc, etc.
		   
		IF m.tiReportIndex = 1 
		   * adjust the columns however you want to use them...
		   * in our version:
		   IF ALEN(THIS.reportPages,2) < 2
		      DIME THIS.reportPages(THIS.ReportFileNames.Count,2)
		   ENDIF
		   
		ENDIF   
		IF THIS.ReportFileNames.Count >= m.tiReportIndex
		   IF ISNULL(m.toListener) 
		      THIS.reportPages[m.tiReportIndex,1] = _PAGENO
		   ELSE    
		      THIS.reportPages[m.tiReportIndex,1] = m.toListener.PageNo 
		   ENDIF
		   IF m.tiReportIndex = 1
		      THIS.reportPages[m.tiReportIndex,2] = THIS.reportPages[m.tiReportIndex,1]
		   ELSE
		      THIS.reportPages[m.tiReportIndex,2] = ;
		         THIS.reportPages[m.tiReportIndex,1] + ;
		         THIS.reportPages[m.tiReportIndex-1,2]
		   ENDIF
		ENDIF
	ENDPROC

	PROCEDURE AfterBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecno
		IF NOT ISNULL(THIS.Successor)
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.AfterBand(m.nBandObjCode, m.nFRXRecNo)
		ENDIF
		
	ENDPROC

	PROCEDURE AfterReport
		IF NOT THIS.IsSuccessor
		   THIS.SharedPageWidth = THIS.GetPageWidth()
		   THIS.SharedPageHeight = THIS.GetPageHeight()
		ENDIF
		
		IF NOT ISNULL(THIS.Successor)
		   WITH THIS.Successor
		      .FRXDataSession = THIS.FRXDataSession
		      .CurrentDataSession = THIS.CurrentDataSession
		      .TwoPassProcess = THIS.TwoPassProcess
		      .CommandClauses = THIS.CommandClauses
		      .SharedPageHeight = THIS.SharedPageHeight
		      .SharedPageWidth = THIS.SharedPageWidth
		      THIS.SetSuccessorDynamicProperties()
		      .AfterReport()
		      .ResetToDefault("FRXDataSession")
		      .ResetToDefault("CurrentDataSession")
		      
		   ENDWITH
		ENDIF
		IF NOT THIS.IsSuccessor
		   NODEFAULT
		   DODEFAULT()
		ENDIF   
		
		
	ENDPROC

	PROCEDURE allowmodalmessages_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.AllowModalMessages = m.vNewVal
		ENDIF   
		
		
	ENDPROC

	PROCEDURE appname_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.appname = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE BeforeBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		
		IF NOT ISNULL(THIS.Successor)
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.BeforeBand(m.nBandObjCode, m.nFRXRecNo)
		ENDIF
		
		THIS.resetDataSession() 
		
	ENDPROC

	PROCEDURE BeforeReport
		THIS.setFRXRunStartupConditions()
		
		THIS.getFRXStartupInfo()
		
		THIS.resetDataSession()
		
		IF NOT THIS.IsSuccessor
		   THIS.sharedPageHeight = THIS.GetPageHeight()
		   THIS.sharedPageWidth = THIS.GetPageWidth()
		   THIS.sharedListenerType = THIS.ListenerType
		   THIS.ResetToDefault("sharedPageNo")
		   THIS.ResetToDefault("sharedPageTotal")
		   THIS.ResetToDefault("sharedOutputPageCount")
		   THIS.ResetToDefault("sharedGDIPlusGraphics")
		ENDIF
		
		IF NOT ISNULL(THIS.Successor)
		   WITH THIS.Successor
		      .AddProperty("sharedGDIPlusGraphics", THIS.sharedGDIPlusGraphics)      
		      .AddProperty("sharedPageHeight", THIS.sharedPageHeight)
		      .AddProperty("sharedPageWidth", THIS.sharedPageWidth)      
		      .AddProperty("sharedOutputPageCount", THIS.sharedOutputPageCount)
		      .AddProperty("sharedPageNo", THIS.sharedPageNo)      
		      .AddProperty("sharedPageTotal", THIS.sharedPageTotal) 
		      .AddProperty("sharedListenerType",THIS.ListenerType)               
		       THIS.setSuccessorDynamicProperties()        
		      .FRXDataSession = THIS.FRXDataSession
		      .CurrentDataSession = THIS.CurrentDataSession
		      .TwoPassProcess = THIS.TwoPassProcess
		      .CommandClauses = THIS.CommandClauses
		      .commandClausesFile = THIS.commandClausesFile 
		      * doing the above line here because some dynamic
		      * object may have adjusted it in the Load and we can
		      * correct original value here.
		      .BeforeReport()
		   ENDWITH
		ENDIF
		
		*&* Sedna -- we want this *after* successor has run BeforeReport code,
		*&* but some Successor.BeforeReport code might
		*&* have an affect on Dynamics
		THIS.resetDynamicMethodCalls()
		*&* .. so we'll re-set those dynamic properties again afterwards
		IF NOT ISNULL(THIS.Successor)
		   WITH THIS.successor
		       IF .CallEvaluateContents < THIS.CallEvaluateContents
		          .CallEvaluateContents = THIS.CallEvaluateContents
		       ENDIF
		       IF .CallAdjustObjectSize < THIS.CallAdjustObjectSize
		          .CallAdjustObjectSize = THIS.CallAdjustObjectSize
		       ENDIF
		   ENDWITH
		ENDIF   
	ENDPROC

	PROCEDURE CancelReport
		IF NOT THIS.IsSuccessor
		   DODEFAULT()
		   NODEFAULT
		ENDIF   
		IF NOT ISNULL(THIS.Successor)
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.CancelReport()
		ENDIF
		
	ENDPROC

	PROCEDURE clearerrors		&& Resets the class's error status.
		THIS.HadError = .F.
		THIS.LastErrorMessage = ""
	ENDPROC

	PROCEDURE ClearStatus
		DODEFAULT()
		IF NOT ISNULL(THIS.Successor)
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.ClearStatus()
		ENDIF   
	ENDPROC

	PROCEDURE commandclausesfile_assign
		LPARAMETERS m.tvNewVal
		IF VARTYPE(m.tvNewVal) = "C" AND ;
		   FILE(m.tvNewVal) && not SYS(2000), could be built into an app
		   THIS.commandClausesFile = m.tvNewVal
		ELSE
		   THIS.commandClausesFile = NULL   
		ENDIF   
		
	ENDPROC

	PROCEDURE Destroy
		STORE NULL TO ;
		  THIS.runCollector, ;
		  THIS.Successor, ;
		  THIS.Listeners, ;
		  THIS.ReportClauses, ;
		  THIS.ReportFileNames, ;
		  THIS.PreviewContainer, ;
		  THIS.CommandClauses
		
	ENDPROC

	PROCEDURE DoMessage
		LPARAMETERS m.cMessage,m.iParams,m.cTitle
		NODEFAULT
		IF THIS.QuietMode OR ;
		  (THIS.IsRunning AND THIS.CommandClauses.NoDialog)
		   * to emulate the base class behavior, do both checks,
		   * in case the call to DoMessage() occurs
		   * before the baseclass sets QuietMode .T. in response
		   * to NoDialog at the beginning of the report run,
		   * or after the baseclass re-sets Quietmode to .F.
		   * at the end of the report run.
		   RETURN 0
		ELSE
		   IF THIS.AllowModalMessages
		      IF VARTYPE(m.cTitle) = "C"
		         RETURN MESSAGEBOX(TRANS(m.cMessage),VAL(TRANS(m.iParams)),m.cTitle)
		      ELSE
		         RETURN MESSAGEBOX(TRANS(m.cMessage),VAL(TRANS(m.iParams)),THIS.AppName)
		      ENDIF
		   ELSE
		      THIS.DoStatus(m.cMessage)
		      RETURN 0
		   ENDIF
		ENDIF   
	ENDPROC

	PROCEDURE DoStatus
		LPARAMETERS m.cMessage
		NODEFAULT
		IF NOT (THIS.QuietMode OR (THIS.IsRunning AND THIS.CommandClauses.Nodialog))
		   IF THIS.TwoPassProcess AND THIS.CurrentPass = 0
		      WAIT WINDOW NOWAIT OUTPUTCLASS_PREPSTATUS_LOC 
		   ELSE
		      IF VARTYPE(m.cMessage) = "C"
		         DODEFAULT(m.cMessage)      
		      ENDIF
		   ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Error
		LPARAMETERS m.nError, m.cMethod, m.nLine
		LOCAL m.lcOnError,m.lcErrorMsg,m.lcCodeLineMsg
		THIS.HadError = .T.
		IF this.lIgnoreErrors OR _vfp.StartMode>0
			RETURN .F.
		ENDIF
		m.lcOnError=UPPER(ALLTRIM(ON("ERROR")))
		IF NOT EMPTY(m.lcOnError)
			m.lcOnError=STRTRAN(STRTRAN(STRTRAN(lcOnError,"ERROR()","nError"), ;
					"PROGRAM()","cMethod"),"LINENO()","nLine")
			&lcOnError
			RETURN
		ENDIF
		m.lcErrorMsg = THIS.PrepareErrorMessage(m.nError,m.cMethod, m.nLine)
		THIS.LastErrorMessage = m.lcErrorMsg
		
		THIS.DoMessage(m.lcErrorMsg, MB_ICONSTOP )
		
		#IF OUTPUTCLASS_DEBUGGING
		    ERROR m.nError
		#ENDIF    
	ENDPROC

	PROTECTED PROCEDURE fillruncollector		&& Abstract method to set up up runCollector object with contents at whatever point is appropriate in a given implementation.
	ENDPROC

	PROTECTED PROCEDURE getfrxstartupinfo		&& Provides a hook for gathering FRX information during BeforeReport method processing.
		THIS.SetFRXDataSession()
		IF USED("FRX")
		   SELECT FRX
		   LOCATE FOR ObjType = FRX_OBJTYP_DATAENV AND ;
		              Platform = FRX_PLATFORM_WINDOWS AND ;
		              NOT DELETED()
		   THIS.ReportUsesPrivateDataSession = Frx.Environ
		   * could also use 
		   * THIS.CommandClauses.StartDataSession # THIS.CurrentDataSession
		   LOCATE FOR ObjType = FRX_OBJTYP_REPORTHEADER AND ;
		                        Platform = FRX_PLATFORM_WINDOWS AND ;
		                        NOT DELETED()
		   THIS.frxHeaderRecno = RECNO("FRX")
		ELSE
		   THIS.ReportUsesPrivateDataSession = .F.   
		   THIS.frxHeaderRecno = -1
		ENDIF   
		THIS.SetCurrentDataSession()
		IF THIS.reportUsesPrivateDataSession
		   SET TALK OFF
		ENDIF
		THIS.DrivingAlias = UPPER(ALIAS())
	ENDPROC

	PROCEDURE getlasterrormessage		&& Provides information about the last error that occurred.
		RETURN STRTRAN(THIS.LastErrorMessage, CHR(13), " ")
	ENDPROC

	PROCEDURE IncludePageInOutput
		LPARAMETERS m.nPageNo
		LOCAL m.llInclude
		IF (NOT THIS.isSuccessor) AND ;
		   (THIS.PageLimit > 0) AND ;
		   (THIS.PageNo > THIS.PageLimit)
		   * note that nPageNo and the 
		   * current CommandClauses.RangeFrom and RangeTo values
		   * only refer to the current report, which
		   * is potentially one of a series using NOPAGEEJECT.
		   * THIS.PageNo refers to the overall number of pages that
		   * have been run, across the multiple reports.
		   IF NOT THIS.pageLimitQuietMode 
		      THIS.DoMessage(OUTPUTCLASS_PAGELIMIT_LOC , MB_ICONEXCLAMATION)
		   ENDIF      
		   THIS.LastErrorMessage = OUTPUTCLASS_PAGELIMIT_LOC
		   THIS.CancelReport()
		ELSE
		   DO CASE
		   CASE (THIS.isSuccessor) 
		      * do not try to limit run unless
		      * communicating with native engine
		      m.llInclude = .T.
		   CASE (THIS.PageTopLimit = -1) AND ;
		        (THIS.PageTailLimit = -1)
		      * no limits set        
		      m.llInclude = .T.      
		   CASE THIS.PageTopLimit = -1
		     * only bottom end requested
		      IF THIS.PageLimitInsideRange 
		         m.llInclude = (THIS.PageNo <= THIS.PageTailLimit)      
		      ELSE
		         m.llInclude = (THIS.PageNo >= THIS.PageTailLimit)
		      ENDIF         
		   CASE THIS.PageTailLimit = -1
		     * only top end requested
		      IF THIS.PageLimitInsideRange 
		         m.llInclude = (THIS.PageNo >= THIS.PageTopLimit)      
		      ELSE
		         m.llInclude = (THIS.PageNo <= THIS.PageTopLimit)
		      ENDIF         
		   OTHERWISE
		      * both top and tail requested
		      IF THIS.PageLimitInsideRange
		         m.llInclude = BETWEEN(THIS.PageNo,THIS.PageTopLimit, THIS.PageTailLimit)
		      ELSE
		         m.llInclude = ((THIS.PageNo <= THIS.PageTopLimit) OR ;
		                        (THIS.PageNo >= THIS.PageTailLimit))
		      ENDIF                        
		   ENDCASE      
		ENDIF          
		RETURN (m.llInclude AND DODEFAULT(m.nPageNo))
		
	ENDPROC

	PROCEDURE Init
		THIS.listenerDataSession = SET("DATASESSION")  
		
		IF DODEFAULT() 
		   THIS.AppName = OUTPUTCLASS_APPNAME_LOC
		ELSE
		   RETURN .F.
		ENDIF      
		
		*&* Sedna
		* this may be necessary if you
		* modify and compile these classes in a build that
		* does have the two native properties
		* and then go back to use them with a version
		* that does *not* have the native properties
		* (it's possible to lose the custom definitions)
		
		IF NOT PEMSTATUS(THIS,"CallEvaluateContents",5)
		   THIS.AddProperty("CallEvaluateContents", LISTENER_CALLDYNAMICMETHOD_CHECK_CODE)
		ENDIF   
		
		IF NOT PEMSTATUS(THIS,"CallAdjustObjectSize",5)
		   THIS.AddProperty("CallAdjustObjectSize", LISTENER_CALLDYNAMICMETHOD_CHECK_CODE)
		ENDIF   
		
		
		RETURN NOT THIS.HadError
	ENDPROC

	PROCEDURE invokeoncurrentpass		&& Provides a hook for listeners to evaluate whether they wish to generate output or perform other actions during the current report execution pass.
		RETURN .T.
	ENDPROC

	PROCEDURE isfrxswapcopypresent		&& Indicates whether the original CommandClauses.File value has been swapped for a temporary copy during a report run.
		RETURN (NOT ISNULL(THIS.commandClausesFile)) AND ;
		       (NOT EMPTY(THIS.commandClausesFile)) AND ;
		       (TYPE("THIS.commandClauses.File") = "C") AND ;
		       (NOT UPPER(THIS.commandClausesFile) == UPPER(THIS.CommandClauses.File))
		
	ENDPROC

	PROCEDURE issuccessor_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.isSuccessor = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE lignoreerrors_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.lIgnoreErrors = m.vNewVal
		ENDIf   
		
		
	ENDPROC

	PROCEDURE listenertype_assign
		LPARAMETERS m.vNewVal
		IF THIS.SupportsListenerType(m.vNewVal) AND ;
		   NOT THIS.IsRunning
		   THIS.ListenerType = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE LoadReport
		THIS.clearErrors()
		
		THIS.setFRXDataSessionEnvironment()
		
		THIS.resetDataSession()
		THIS.frxHeaderRecno = -1
		
		IF NOT ISNULL(THIS.Successor)
		   WITH THIS.Successor
		      .AddProperty("isSuccessor",.T.)
		      .AddProperty("commandClausesFile",THIS.commandClausesFile )
		      .PrintJobName = THIS.PrintJobName 
		      .CommandClauses = THIS.CommandClauses
		      .LoadReport()
		   ENDWITH
		ENDIF
		
		
		   
		
		
		   
	ENDPROC

	PROCEDURE outputtype_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
		   THIS.OutputType = INT(m.vNewVal)
		   IF THIS.SupportsListenerType(THIS.OutputType) 
		      THIS.ListenerType = THIS.OutputType
		   ENDIF    
		ENDIF
		
	ENDPROC

	PROCEDURE pagelimitinsiderange_assign
		LPARAMETERS m.tVal
		IF VARTYPE(m.tVal) = "L" 
		   THIS.PageLimitInsideRange = m.tVal
		ENDIF
		
		
	ENDPROC

	PROCEDURE pagelimitquietmode_assign
		LPARAMETERS m.tVal
		IF VARTYPE(m.tVal) = "L" 
		   THIS.PageLimitQuietMode = m.tVal
		ENDIF
		
		
	ENDPROC

	PROCEDURE pagelimit_assign
		LPARAMETERS m.tVal
		IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) > 0
		   THIS.PageLimit = CEILING(m.tVal)
		ELSE 
		   THIS.PageLimit = -1        
		ENDIF
		
		
	ENDPROC

	PROCEDURE pagetaillimit_assign
		LPARAMETERS m.tVal
		IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) > 0
		   THIS.PageTailLimit = CEILING(m.tVal)
		ELSE 
		   THIS.PageTailLimit = -1        
		ENDIF
		
		
	ENDPROC

	PROCEDURE pagetoplimit_assign
		LPARAMETERS m.tVal
		IF VARTYPE(m.tVal) = "N" AND CEILING(m.tVal) > 0
		   THIS.PageTopLimit = CEILING(m.tVal)
		ELSE 
		   THIS.PageTopLimit = -1        
		ENDIF
		
		
	ENDPROC

	PROTECTED PROCEDURE popglobalsets		&& Provides a hook for Listeners to restore global settings not scoped to a data session after saving them with PushGlobalSets.
		* abstract: restore any globals here that aren't session-bound      
		
		
	ENDPROC

	PROCEDURE prepareerrormessage		&& Organizes common error information values (nError, cMethod, nLine, cName, cMessage, cCodeLine) into a coherent string for presentation to the user.
		LPARAMETERS m.nError, m.cMethod, m.nLine, m.cName, m.cMessage, m.cCodeLine
		
		LOCAL m.lcErrorMessage, m.lcCodeLineMsg
		
		IF VARTYPE(cMessage) = "C"
		   m.lcErrorMessage = m.cMessage
		ELSE
		   m.lcErrorMessage = MESSAGE()
		ENDIF
		
		m.lcErrorMessage = m.lcErrorMessage + CHR(13) + CHR(13)
		
		IF VARTYPE(cName) = "C"
		   m.lcErrorMessage = m.lcErrorMessage + m.cName
		ELSE
		   m.lcErrorMessage = m.lcErrorMessage + this.Name
		ENDIF
		
		m.lcErrorMessage = m.lcErrorMessage + CHR(13)+ ;
		 		 OUTPUTCLASS_ERRNOLABEL_LOC +ALLTRIM(STR(m.nError))+CHR(13)+ ;
				 OUTPUTCLASS_ERRPROCLABEL_LOC +LOWER(ALLTRIM(m.cMethod))
				
		IF VARTYPE(m.cCodeLine) = "C"
		   m.lcCodeLineMsg = m.cCodeLine
		ELSE
		   m.lcCodeLineMsg = MESSAGE(1)
		ENDIF		
		
		IF BETWEEN(m.nLine,1,100000) AND NOT m.lcCodeLineMsg="..."
			m.lcErrorMessage= ;
		       m.lcErrorMessage+CHR(13)+ OUTPUTCLASS_ERRLINELABEL_LOC+ ;
			    ALLTRIM(STR(m.nLine))
			IF NOT EMPTY(m.lcCodeLineMsg)
		       m.lcErrorMessage= ;
				   m.lcErrorMessage+CHR(13)+CHR(13)+m.lcCodeLineMsg
			ENDIF
		ENDIF
		
		RETURN m.lcErrorMessage
	ENDPROC

	PROCEDURE preparefrxswapcopy		&& Provides an FRX copy on disk, in the same path/location as the original FRX if possible to support relative file references, for use during a report run.  Returns fully-qualified temporary file name it generates for the copy.
		LPARAMETERS m.tcPath, m.tlKeepCopyOpen, m.tlAdjustCommandClausesInLoadReport
		LOCAL m.lcPath, m.lcFile, m.liSession, m.lcAlias, m.liSelect, m.llSafety
		m.lcFile = ""
		m.liSession = SET("DATASESSION")
		m.liSelect = 0
		TRY
		   THIS.setFRXDataSession()
		   m.liSelect = SELECT(0)
		   DO CASE
		   CASE VARTYPE(m.tcPath) = "C" AND ;
		      (NOT EMPTY(m.tcPath)) AND DIRECTORY(ADDBS(m.tcPath))
		      m.lcPath = m.tcPath
		   CASE NOT DIRECTORY(ADDBS(JUSTPATH(THIS.CommandClauses.FILE)))
		      * report does not exist on disk
		      * and its path has not been re-created in the
		      * current environment, potentially with related
		      * image directories, etc.
		      m.lcPath = SYS(2023)
		   CASE EMPTY(SYS(2000,THIS.CommandClauses.File)) 
		      * report does not exist on disk
		      m.lcPath = SYS(2023)
		   OTHERWISE
		      * whenever possible,
		      * the best place for this copy will
		      * always be in the same location as the
		      * original FRX, for relative-pathing reasons.
		      m.lcPath = JUSTPATH(THIS.CommandClauses.File)
		   ENDCASE
		   m.lcFile = FORCEEXT(FORCEPATH("F"+SYS(2015), m.lcPath),"FRX")
		   IF USED("FRX") && this method should ordinarily
		                  && be used as part of a report swap, and that
		                  && means in LoadReport only.  FRX isn't used yet.
		                  && But we'll provide this mechanism,
		                  && in case somebody has a different reason
		                  && to use this method at another 
		                  && point in report processing -- 
		                  && XML Listener has one,
		                  && for example!
		      SELECT 0
		      CREATE CURSOR x (onefield l)
		      * we're in the frxdatasession, this is safe
		      CREATE REPORT (m.lcFile) FROM  (ALIAS()) && (DBF("x"))
		      USE IN x
		      SELECT 0
		      USE (m.lcFile) EXCLUSIVE ALIAS (JUSTSTEM(m.lcFile))
		      m.lcAlias = ALIAS()
		      m.llSafety = (SET("SAFETY") == "ON")
		      SET SAFETY OFF
		      ZAP
		      IF m.llSafety
		         SET SAFETY ON
		      ENDIF
		      SELECT FRX
		      SCAN ALL FOR NOT DELETED()
		         SCATTER MEMVAR MEMO
		         INSERT INTO (m.lcAlias) FROM MEMVAR
		      ENDSCAN
		      IF NOT m.tlKeepCopyOpen
		         USE IN (m.lcAlias)
		      ENDIF   
		   ELSE
		      * this is the normal swap mechanism
		      * SYS(2000) may be empty but FILE() should not
		      * be, even if this report was not on disk,
		      * and CommandClauses.File should be fully-qualified.
		      SELECT 0
		      USE (THIS.CommandClauses.File) ;
		        SHARED NOUPDATE ;
		        ALIAS (JUSTSTEM(THIS.CommandClauses.File))
		      m.lcAlias = ALIAS()
		      SELECT * FROM (THIS.CommandClauses.File) ;
		         WHERE NOT DELETED() ;
		         INTO TABLE (m.lcFile)
		      USE IN (m.lcAlias)
		      IF NOT m.tlKeepCopyOpen
		         m.lcAlias = JUSTSTEM(m.lcFile)
		         * this should always work because of the way
		         * we've defined the m.lcFile contents
		         IF USED(m.lcAlias)
		            USE IN (m.lcAlias)   
		         ENDIF         
		      ENDIF   
		   ENDIF
		CATCH WHEN .T.
		   m.lcFile = ""
		FINALLY
		   IF (NOT (EMPTY(m.lcFile) OR EMPTY(SYS(2000,m.lcFile)))) AND ;
		      m.tlAdjustCommandClausesInLoadReport AND ;
		      NOT m.tlKeepCopyOpen
		      THIS.CommandClauses.File = m.lcFile
		   ENDIF 
		   IF m.liSelect > 0
		      SELECT (m.liSelect)
		   ENDIF
		   SET DATASESSION TO (m.liSession)      
		ENDTRY      
		
		RETURN m.lcFile
	ENDPROC

	PROTECTED PROCEDURE pushglobalsets		&& Provides a hook for Listeners to save global settings not scoped to a data session for later restoration with PopGlobalSets.
		  * abstract: set any globals here that aren't session-bound
		
	ENDPROC

	PROCEDURE quietmode_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.quietmode = m.vNewVal
		ENDIF 
	ENDPROC

	PROCEDURE removefrxswapcopy		&& Removes an FRX file and its matching FRT file from disk, if present.
		LPARAMETERS m.tcFile,m.tlRecycle
		LOCAL m.lcRecyle, m.llResettingSharedCopy
		IF EMPTY(m.tcFile) AND THIS.isFRXSwapCopyPresent()
		   m.llResettingSharedCopy = .T.
		   m.tcFile = THIS.CommandClauses.File
		ENDIF
		IF NOT EMPTY(m.tcFile)
		   IF m.tlRecycle
		      m.lcRecycle = " RECYCLE"
		   ELSE
		      m.lcRecycle = ""
		   ENDIF      
		   IF NOT EMPTY(SYS(2000,FORCEEXT(m.tcFile,"FRX")))
		      ERASE (FORCEEXT(m.tcFile,"FRX")) &lcRecycle
		   ENDIF      
		   IF NOT EMPTY(SYS(2000,FORCEEXT(m.tcFile,"FRT")))
		      ERASE (FORCEEXT(m.tcFile,"FRT")) &lcRecycle
		   ENDIF      
		   IF m.llResettingSharedCopy
		      THIS.CommandClauses.File = THIS.commandClausesFile 
		   ENDIF
		ENDIF   
		
	ENDPROC

	PROCEDURE removereports		&& Removes report filenames as well as associated clauses and listeners from this Listeners' various collections.
		IF NOT (THIS.IsRunningReports)
		   THIS.ReportFileNames = NULL
		   THIS.ReportClauses = NULL
		   THIS.Listeners = NULL
		   DIME THIS.ReportPages[1]
		   THIS.ReportPages[1] = 0
		   
		ENDIF   
	ENDPROC

	PROCEDURE Render
		LPARAMETERS m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage
		IF NOT ISNULL(THIS.Successor)
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.Render( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		                          m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		ENDIF
		
		
	ENDPROC

	PROTECTED PROCEDURE resetcalladjustobjectsize		&& Evaluates whether this reportlistener's activity requires calls to AdjustObjectSize method for any layout controls on this report run.
		* abstract, poll members
	ENDPROC

	PROTECTED PROCEDURE resetcallevaluatecontents		&& Evaluates whether this reportlistener's activity requires calls to EvaluateContents method for any layout controls on this report run.
		* abstract, poll members
	ENDPROC

	PROTECTED PROCEDURE resetdatasession		&& Sets the DataSessionID to the session where the Listener originated.
		IF (THIS.listenerDataSession > -1) 
		   TRY
		      SET DATASESSION TO (THIS.listenerDataSession)
		   CATCH WHEN .T.
		      THIS.ResetToDefault("listenerDataSession")
		      SET DATASESSION TO (THIS.listenerDataSession)      
		   ENDTRY
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE resetdynamicmethodcalls		&& Evaluates whether AdjustObjectSize and EvaluateContents methods should be called for a report run, for this reportlistener's activity or as requested by Successor chain.
		*&* Sedna:
		
		* poll Successor, who would
		* have already run all this code on its
		* own behalf:
		
		IF INLIST(THIS.callAdjustObjectSize,;
		          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
		          LISTENER_CALLDYNAMICMETHOD_NEVER) 
		   THIS.resetCallAdjustObjectSize()
		ELSE  && already set to LISTENER_CALLDYNAMICMETHOD_ALWAYS, always call
		  * leave alone
		ENDIF   
		
		IF INLIST(THIS.callEvaluateContents,;
		          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
		          LISTENER_CALLDYNAMICMETHOD_NEVER) 
		   THIS.resetCallEvaluateContents()
		ELSE  && already set to LISTENER_CALLDYNAMICMETHOD_ALWAYS, always call
		  * leave alone
		ENDIF   
		
		IF NOT ISNULL(THIS.Successor) 
		   IF PEMSTATUS(THIS.successor,"CallAdjustObjectSize",5) AND ;
		      THIS.successor.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		      THIS.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		   ENDIF
		   IF PEMSTATUS(THIS.successor,"CallEvaluateContents",5) AND ;
		      THIS.successor.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		      THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		   ENDIF      
		ENDIF         
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE resetruncollector		&& Abstract method to clean up runCollector object at whatever point is appropriate in a given implementation.
	ENDPROC

	PROCEDURE runreports		&& Executes a series of REPORT FORM commands according to the instructions in the ReportFileNames, ReportClauses, and Listeners collections.  Optionally clears collection after run and issues the REPORT FORM commands without OBJECTreferences.
		LPARAMETERS m.tlRemoveReportsAfterRun, m.tlOmitListenerReferences
		
		IF NOT ;
		 (THIS.IsRunningReports OR ;
		  ISNULL(THIS.ReportFileNames) OR ;
		  THIS.ReportFileNames.Count = 0)
		
		  LOCAL m.oError, m.liIndex, m.lcClauses, m.loListener, m.lcParse
		  m.oError = NULL
		
		  THIS.IsRunningReports = .T. 
		  
		  TRY 
		  
		    FOR m.liIndex = 1 TO THIS.ReportFileNames.Count
		       * the clauses, filenames, and listener collections are 
		       * protected properties, we're
		       * taking care of how they match up, 
		       * that FRXs exist, etc.
		       m.lcClauses = UPPER(THIS.ReportClauses[m.liIndex])
		       m.loListener = THIS.Listeners[m.liIndex]
		       DO CASE 
		       CASE " OBJE " $ STRTRAN(" "+m.lcClauses,"CT", " ") OR ;
		            " OBJEC " $ " "+m.lcClauses OR ;
		            m.tlOmitListenerReferences
		          m.loListener = NULL  
		          REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses
		          TRY
		             m.lcParse = " " + STRTRAN(" "+m.lcClauses," OBJECT ", " OBJE ")
		             m.lcParse = STRTRAN(m.lcParse," OBJEC ", " OBJE ")
		             m.lcParse = SUBSTR(m.lcParse,AT(" OBJE ", m.lcParse)+5)        
		             DO CASE
		             CASE m.tlOmitListenerReferences
		                * we're going with old-style behavior for sure here
		             CASE " TYPE " $ " " + m.lcClauses
		                m.lcParse = ALLTRIM(STRTRAN(" " + m.lcParse," TYPE ",""))
		                IF " " $ m.lcParse
		                   m.lcParse = ALLTRIM(LEFT(m.lcParse,AT(" ",m.lcParse,1)))
		                ENDIF
		                IF VAL(m.lcParse) > 0
		                   m.loListener = EVALUATE("_oReportOutput['" + m.lcParse+"']")
		                ENDIF
		             OTHERWISE
		                m.lcParse = ALLTRIM(m.lcParse)
		                IF " " $ m.lcParse
		                   m.lcParse = ALLTRIM(LEFT(m.lcParse,AT(" ",m.lcParse,1)))
		                ENDIF
		                m.loListener = EVALUATE(m.lcParse)         
		             ENDCASE
		          CATCH
		             m.loListener = NULL
		          ENDTRY   
		       CASE ISNULL(loListener)
		          REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses  OBJECT THIS
		          m.loListener = THIS
		       OTHERWISE
		          REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses  OBJECT m.loListener
		       ENDCASE
		       
		       THIS.adjustReportPagesInfo(m.liIndex, m.lcClauses, m.loListener)
		
		*&* Sedna change: 
		*&*  see new THIS.adjustReportPagesInfo method, to which we pass report index, clauses, and 
		*&*  evaluated listener ref.  Original code here was:
		*&*          IF NOT (" NOWA " $ STRTRAN(" "+m.lcClauses,"IT"," ") OR ;
		*&*                  " NOWAI " $ " " + m.lcClauses) 
		*&*             THIS.ReportPages[m.liIndex] = THIS.SharedPageTotal
		*&*             * TBD: make this a two-column array with 
		*&*             * output pages (responsive to RANGE clause)
		*&*             * represented as well?
		*&*          ENDIF
		       
		    ENDFOR
		    
		         
		  CATCH TO m.oError
		     LOCAL lcErrMsg
		     IF (ISNULL(m.oError))
		         lcErrMsg = MESSAGE() + CHR(13) + MESSAGE(1)
		     ELSE
		         lcErrMsg = THIS.PrepareErrorMessage(;
		               m.oError.ErrorNo, ;
		               m.oError.PROCEDURE, ;
		               m.oError.LINENO, ;
		               THIS.AppName, ;
		               m.oError.MESSAGE, ;
		               m.oError.LineContents)
		     ENDIF
		     THIS.DoMessage(lcErrMsg, MB_ICONSTOP)
		     THIS.lastErrorMessage = lcErrMsg
		     #IF OUTPUTCLASS_DEBUGGING
		         SUSPEND
		     #ENDIF                   
		     EXIT  
		  FINALLY
		  
		     THIS.IsRunningReports = .F.  
		     IF m.tlRemoveReportsAfterRun
		       THIS.RemoveReports()
		     ENDIF  
		     STORE NULL TO m.loListener, m.oError
		
		  ENDTRY
		  
		  
		ENDIF   
		
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE setcurrentdatasession		&& Sets the DataSessionID to the data session holding report's data tables.
		IF (THIS.CurrentDataSession # SET("DATASESSION"))  
		   TRY
		      SET DATASESSION TO (THIS.CurrentDataSession)
		   CATCH WHEN .T.
		      THIS.ResetToDefault("CurrentDataSession")
		      THIS.resetDataSession()
		   ENDTRY
		ENDIF   
		
		
	ENDPROC

	PROTECTED PROCEDURE setfrxdatasession		&& Sets the DataSessionID to the data session in which the Engine has opened a readonly copy of the report file as a table for the Listener's use.
		IF (THIS.FRXDataSession > -1) AND (THIS.FRXDataSession # SET("DATASESSION"))
		
		   TRY
		      SET DATASESSION TO (THIS.FRXDataSession)
		   CATCH WHEN .T.
		      THIS.ResetToDefault("FRXDataSession")
		      THIS.resetDataSession()
		   ENDTRY
		   
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE setfrxdatasessionenvironment		&& Provides a hook for classes to determine the datasession-scoped SETs they wish to add to the private FRX data session.
		THIS.setFRXDataSession()
		SET TALK OFF 
		
	ENDPROC

	PROTECTED PROCEDURE setfrxrunstartupconditions		&& Hook method called in BeforeReport, allowing you to set up CommandClauses properties or other attributes required by your class.
		IF ISNULL(THIS.CommandClauses)
		   THIS.CommandClauses = CREATEOBJECT("Empty")
		ENDIF
		IF TYPE("THIS.CommandClauses.NoDialog") # "L"
		   ADDPROPERTY(THIS.CommandClauses,"NoDialog",.F.)
		ENDIF      
		
		
		* add anything critical during a run
		* that might not be available, whether
		* because this is a custom attribute
		* or because public methods of ReportListener
		* might be called outside a normal report run.
	ENDPROC

	PROCEDURE setsuccessordynamicproperties		&& Provides a hook for the Listener to share information changed by the Engine with a succession of Listeners, during the run of a report.
		IF NOT THIS.isSuccessor
		   THIS.sharedOutputPageCount = THIS.OutputPageCount
		   THIS.sharedPageTotal = THIS.PageTotal
		   THIS.sharedPageNo = THIS.PageNo
		   THIS.sharedGdiplusGraphics = THIS.GDIPlusGraphics 
		ENDIF
		WITH THIS.Successor
		   .CurrentPass = THIS.CurrentPass
		   .TwoPassProcess = THIS.TwoPassProcess   
		   .sharedOutputPageCount = THIS.sharedOutputPageCount
		   .sharedPageTotal = THIS.sharedPageTotal   
		   .sharedPageNo = THIS.sharedPageNo
		   .sharedGdiplusGraphics  = THIS.sharedGdiplusGraphics
		   .CallEvaluateContents = THIS.CallEvaluateContents
		   .CallAdjustObjectSize = THIS.CallAdjustObjectSize
		ENDWITH   
		
	ENDPROC

	PROCEDURE sharedgdiplusgraphics_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N"
		   THIS.SharedGDIplusGraphics = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE sharedlistenertype_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "N" AND ;
		   INLIST(m.vNewVal,LISTENER_TYPE_DEF,;
		                    LISTENER_TYPE_PRN,;
		                    LISTENER_TYPE_PRV,;
		                    LISTENER_TYPE_PAGED,;
		                    LISTENER_TYPE_ALLPGS)
		   THIS.sharedListenerType = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE sharedoutputpagecount_assign		&& Provides a readwrite copy of the the Engine's OutputPageCount property which the Listener can share with a succession chain.
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N"
		   THIS.sharedOutputPageCount = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE sharedpageheight_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N"
		   THIS.sharedPageHeight = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE sharedpageno_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N"
		   THIS.sharedPageNo = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE sharedpagetotal_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N"
		   THIS.sharedPageTotal = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE sharedpagewidth_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N"
		   THIS.sharedPageWidth = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE successor_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND ;
		   (ISNULL(m.vNewVal) OR ;
		   (VARTYPE(m.vNewVal) = "O" AND UPPER(m.vNewVal.BaseClass) == "REPORTLISTENER"))
		   THIS.Successor = m.vNewVal
		ENDIF   
		
		
	ENDPROC

	PROCEDURE UnloadReport
		
		IF NOT THIS.IsSuccessor
		   THIS.SharedPageWidth = THIS.GetPageWidth()
		   THIS.SharedPageHeight = THIS.GetPageHeight()
		ENDIF
		
		THIS.resetDataSession()
		
		IF NOT ISNULL(THIS.Successor)
		
		   WITH THIS.Successor
		      .FRXDataSession = THIS.FRXDataSession
		      .CurrentDataSession = THIS.CurrentDataSession
		      .TwoPassProcess = THIS.TwoPassProcess
		      .CommandClauses = THIS.CommandClauses
		      .SharedPageHeight = THIS.SharedPageHeight
		      .SharedPageWidth = THIS.SharedPageWidth
		      THIS.SetSuccessorDynamicProperties()      
		      .UnloadReport()
		      .IsSuccessor = .F.
		   ENDWITH
		  
		ENDIF
		
		   
	ENDPROC

	PROCEDURE UpdateStatus
		DODEFAULT()
		IF NOT ISNULL(THIS.Successor)
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.UpdateStatus()
		ENDIF   
	ENDPROC

ENDDEFINE

DEFINE CLASS debuglistener AS utilityreportlistener OF "_reportlistener.vcx" 		&& Provides debugging output to help developers understand what happens during an object-assisted report run.
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: dodebug		&& Provides debug information for a ReportListener event or method.
		*m: dodebugcommandclauses		&& Provides debug information for the CommandClauses object and ReportListener member properties.
		*m: verbose_assign
		*p: includeloadandunload		&& Indicates whether the debug information should include values from the LoadReport and UnloadReport events.
		*p: targetalias		&& Holds the target alias during the processing of a detail band.
		*p: verbose		&& Specifies whether the DebugListener should include extended information about parameter values of object type, as well as page, alias, and recno() information for each event or method.
	*</DefinedPropArrayMethod>

	PROTECTED targetalias
	FRXDataSession = -1
	Height = 23
	includeloadandunload = .T.		&& Indicates whether the debug information should include values from the LoadReport and UnloadReport events.
	Name = "debuglistener"
	targetalias = ("")		&& Holds the target alias during the processing of a detail band.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="verbose" type="property" display="verbose" favorites="True" />
		<memberdata name="dodebug" type="method" display="doDebug" favorites="True" />
		<memberdata name="dodebugcommandclauses" type="method" display="doDebugCommandClauses" favorites="False" />
		<memberdata name="targetalias" type="property" display="targetAlias" />
		<memberdata name="includeloadandunload" type="property" display="includeLoadAndUnload" favorites="True" />
		</VFPData>
	
	PROCEDURE AddProperty
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		             m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE AdjustObjectSize
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		DODEFAULT(m.p1, m.p2)
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE AfterBand
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		DODEFAULT(m.p1, m.p2)
	ENDPROC

	PROCEDURE AfterReport
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		
		LOCAL m.lcProgram
		m.lcProgram = PROGRAM()
		THIS.DoDebug(m.lcProgram, PCOUNT(), ;
		   m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " current CommandClauses")
		
		IF NOT (THIS.IncludeLoadAndUnload OR THIS.CommandClauses.NoPageEject)
		   THIS.CloseTargetFile()
		   IF NOT THIS.QuietMode
		      MODI COMM (THIS.TargetFileName) NOWAIT
		   ENDIF   
		ENDIF   
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE BeforeBand
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		DODEFAULT(m.p1, m.p2)
		IF THIS.Verbose
		   THIS.TargetAlias = ""
		   IF m.p1 = FRX_OBJCOD_DETAIL
		      THIS.SetFRXDataSession()
		      GO m.p2 IN FRX
		      IF NOT EMPTY(FRX.Expr)
		         THIS.TargetAlias = UPPER(EVALUATE(FRX.Expr))
		      ENDIF
		      THIS.resetDataSession()
		   ENDIF
		ENDIF   
	ENDPROC

	PROCEDURE BeforeReport
		LPARAMETERS m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		
		   LOCAL m.lcProgram
		   m.lcProgram = PROGRAM()
		   
		   DODEFAULT()
		   
		   IF THIS.Verbose
		   
		      THIS.setCurrentDataSession()
		
		   ENDIF
		   
		  
		   IF THIS.TargetHandle = -1 
		      THIS.OpenTargetFile()
		   ENDIF
		
		  THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		       m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		   
		  THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " received CommandClauses")
		
		
		   IF THIS.verbose
		      THIS.resetDataSession()
		   ENDIF      
		   
		
	ENDPROC

	PROCEDURE CancelReport
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		DODEFAULT()
		
	ENDPROC

	PROCEDURE ClearStatus
		LPARAMETERS m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		DODEFAULT()
		
	ENDPROC

	PROCEDURE dodebug		&& Provides debug information for a ReportListener event or method.
		LPARAMETERS m.p0, m.pcount, m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		
		IF THIS.TargetHandle > 0 
		
		   LOCAL m.liIndex, m.loObj, m.lvParam, m.liObjIndex, m.liMembers, laMembers[1]
		
		   FWRITE( THIS.TargetHandle, m.p0 )
		   
		   FOR m.liIndex = 1 TO m.pcount
		   
		      m.lvParam = EVAL("p"+TRANS(liIndex))
		   
		      IF THIS.Verbose AND VARTYPE(m.lvParam) = "O"
		
		         m.liMembers = AMEMBERS(laMembers, m.lvParam) && ,0,"G"
		 
		         FOR m.liIndex = 1 TO m.liMembers
		   
		            IF TYPE("lvParam."+laMembers[m.liIndex]) # "U"
		               FWRITE(THIS.TargetHandle, ;
		                  ",Obj."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("lvParam."+laMembers[m.liIndex])) )
		            ENDIF
		     
		         ENDFOR
		
		      ELSE
		  
		         FWRITE(THIS.TargetHandle, ","+TRANSF(m.lvParam))
		
		      ENDIF
		
		   ENDFOR
		
		   FPUTS(THIS.TargetHandle, "")
		
		   IF THIS.Verbose
		      THIS.setCurrentDataSession()
		   
		      FWRITE(THIS.TargetHandle, ;
		          "Listener.PageNo=" + IIF(THIS.sharedPageNo=0,;
		                                   TRANSFORM(THIS.PageNo),  ;
		                                   TRANSFORM(THIS.sharedPageNo))+ ", " + ;
		          "_PAGENO="+TRANSFORM(_PAGENO))
		
		      IF (NOT EMPTY(THIS.DrivingAlias)) AND USED(THIS.DrivingAlias)
		         FWRITE(THIS.TargetHandle, ", " + THIS.DrivingAlias + " recno=" + TRANSFORM(RECNO(THIS.Drivingalias)))   
		      ENDIF   
		      
		      IF NOT EMPTY(THIS.TargetAlias)
		      
		         FWRITE(THIS.TargetHandle, ", TargetAlias=" + THIS.TargetAlias + ", targetRecno=" + TRANSFORM(RECNO(THIS.TargetAlias)))         
		      
		      ENDIF
		   
		      FPUTS(THIS.TargetHandle, "")   
		      THIS.resetDataSession()
		   ENDIF
		   
		   FFLUSH(THIS.targetHandle)
		   
		ENDIF   
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE dodebugcommandclauses		&& Provides debug information for the CommandClauses object and ReportListener member properties.
		LPARAMETERS m.tvCommand, m.tcHeader
		
		IF VARTYPE(m.tvCommand) = "O" AND THIS.TargetHandle > 0 
		   LOCAL m.liIndex, laMembers[1], m.liMembers
		
		   FPUTS( THIS.TargetHandle, REPL("-",30) )   
		   FPUTS( THIS.TargetHandle, "MEMBERS:" )
		   m.liMembers = AMEMBERS(laMembers, THIS) && ,0,"G"
		 
		   FOR m.liIndex = 1 TO m.liMembers
		   
		      IF TYPE("THIS."+laMembers[m.liIndex]) # "U"
		  
		         FPUTS(THIS.TargetHandle, "."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("THIS."+laMembers[m.liIndex])) )
		      ENDIF
		
		   ENDFOR
		
		   FPUTS( THIS.TargetHandle, REPL("-",30) )   
		   FPUTS( THIS.TargetHandle, tcHeader )
		      
		   m.liMembers = AMEMBERS(laMembers, m.tvCommand)   
		   IF m.liMembers = 0
		      FPUTS(THIS.TargetHandle, "... NO MEMBERS")
		   ELSE
		
		      FOR m.liIndex = 1 TO m.liMembers
		  
		        FPUTS(THIS.TargetHandle, "."+laMembers[m.liIndex]+"="+TRANSFORM(EVAL("tvCommand."+laMembers[m.liIndex])) )
		
		      ENDFOR
		     
		   ENDIF   
		   FPUTS( THIS.TargetHandle, REPL("-",30) )      
		   FFLUSH(THIS.targetHandle)
		
		ENDIF
	ENDPROC

	PROCEDURE DoStatus
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		DODEFAULT(m.p1)
		
	ENDPROC

	PROCEDURE EvaluateContents
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		DODEFAULT(m.p1, m.p2)
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE IncludePageInOutput
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		RETURN DODEFAULT(m.p1)
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   THIS.AppName = OUTPUTCLASS_APPNAME_LOC
		   RETURN NOT THIS.hadError 
		ELSE
		   RETURN .F.   
		ENDIF
		
		
	ENDPROC

	PROCEDURE LoadReport
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		
		DODEFAULT()
		
		IF THIS.IncludeLoadandUnload 
		
		  IF THIS.TargetHandle = -1
		     THIS.OpenTargetFile()
		  ENDIF
		  
		  THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		      m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		  THIS.DoDebugCommandClauses(THIS.CommandClauses,PROGRAM()+ " received CommandClauses")
		  
		ENDIF  
		
	ENDPROC

	PROCEDURE OnPreviewClose
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE opentargetfile
		IF WEXIST(JUSTSTEM(THIS.targetFileName))
		   * because of the MODI FILE NOWAIT,
		   * generate a new filename:
		   THIS.targetFileName = SYS(2015)
		ENDIF
		DODEFAULT()   
	ENDPROC

	PROCEDURE OutputPage
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
		
	ENDPROC

	PROCEDURE ReadExpression
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE ReadMethod
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		IF DODEFAULT( m.p1, @m.p2, @m.p3, @m.p4, @m.p5, @m.p6, @m.p7,@m.p8) #  OUTPUTFX_BASERENDER_NORENDER
		    THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		        m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		ENDIF
		
	ENDPROC

	PROCEDURE ResetToDefault
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE SaveAsClass
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE SupportsListenerType
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		    m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE UnloadReport
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		
		IF THIS.includeLoadAndUnload 
		   LOCAL lcProgram
		   lcProgram = PROGRAM()
		   THIS.DoDebug(lcProgram, PCOUNT(),;
		        m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		   THIS.DoDebugCommandClauses(THIS.CommandClauses,m.lcProgram+ " current CommandClauses")
		ENDIF   
		
		IF THIS.TargetHandle > 0 AND (NOT THIS.CommandClauses.NoPageEject)
		   THIS.CloseTargetFile()
		   IF NOT THIS.QuietMode
		      MODI FILE (THIS.Targetfilename) NOWAIT
		   ENDIF
		ENDIF   
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE UpdateStatus
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		DODEFAULT()
		
	ENDPROC

	PROCEDURE verbose_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.Verbose = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE WriteExpression
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

	PROCEDURE WriteMethod
		LPARAMETERS  m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12
		THIS.DoDebug(PROGRAM(), PCOUNT(), ;
		     m.p1, m.p2, m.p3, m.p4, m.p5, m.p6, m.p7, m.p8, m.p9, m.p10, m.p11, m.p12)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxabstract AS custom 
	*<ClassComment>
		*Custom-derived class, supplying an abstract instance of the required interface to implement an FX or GFX object. For use with FXListener as a report decorator.
	*</ClassComment>
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: applyfx		&& Required method to implement the FX interface.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Name = "fxabstract"
	_memberdata = <VFPData>
		<memberdata name="applyfx" type="property" display="applyFX" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE applyfx		&& Required method to implement the FX interface.
		LPARAMETERS m.toListener, m.tcMethodToken,;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		            
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxlistener AS _reportlistener OF "_reportlistener.vcx" 
	*<ClassComment>
		*ReportListener supplying the means to decorate base report content during a report run, using two member collections: FXs (adjust content and format instructions) and GFXs (adjust or replace GDIPlus-graphics rendering).
	*</ClassComment>
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: addcollectionmember		&& Adds instance of specified class in specified class library  to FX or GFX collection. Params: tcClass, tcClassLib,tcModule,tlSingleton, tlInGFX, tlRequired
		*m: cancelrequested_assign
		*m: checkcollectionforspecifiedmember		&& Checks FX or GFX collection for instance of specified class by class and (if specified) by class library name. Returns logical (.F. if not found) or object reference (NULL if not found).
		*m: checkcollectionmembers		&& Eliminates members of FXs and GFXs collections in LoadReport and again in BeforeReport if they do not match required interfaces. Verifies availability of appropriate members.
		*m: classpath_assign
		*m: createhelperobjects		&& Creates FXs and GFXs collections, and additional required object members such as the FFCGraphics object.
		*m: creatememberdatacursor		&& Creates a cursor in the FRX datasession to hold extended information about FRX data rows.
		*m: ensurecollection		&& Ensures valid object collections for GFXs and FXs member references.
		*m: evaluateuserexpression		&& Attempts to evaluate a user-provided expression in various report run datasessions and return a valid result.
		*m: ffcgraphics_assign
		*m: frxcursor_access
		*m: frxcursor_assign
		*m: fxfeedbackclasslib_assign
		*m: fxfeedbackclass_assign
		*m: fxfeedbackmodule_assign
		*m: fxmemberdatascriptclasslib_assign
		*m: fxmemberdatascriptclass_assign
		*m: fxmemberdatascriptmodule_assign
		*m: getfeedbackfxobject		&& Instantiates FX object to provide user feedback.
		*m: getfrxrecno		&& Determine the current FRX cursor row number from the parameters passed to a ReportListener event.
		*m: getmemberdatascriptfxobject		&& Instantiates FX object to provide memberdata-based script handling.
		*m: getnorendergfxobject		&& Instantiates GFX object to provide memberdata-specified conditional baseclass rendering.
		*m: getobjectinstance		&& Provides a method for instancing classes as helper/member objects or FX/GFX collection members using specific path priorities.
		*m: getpathforexternals		&& Determines the location at which the current configuration table and any other required external files will be expected.
		*m: getrotategfxobject		&& Instantiates GFX object to provide memberdata-based rotation of layout controls.
		*m: gfxnorenderclasslib_assign
		*m: gfxnorenderclass_assign
		*m: gfxnorendermodule_assign
		*m: gfxrotateclasslib_assign
		*m: gfxrotateclass_assign
		*m: gfxrotatemodule_assign
		*m: loadfrxcursor_assign
		*m: memberdataalias_assign
		*m: needgfxs		&& Hook method to evaluate whether this method needs to call the GFXs collection members for rendering purposes.
		*m: removecollectionmember		&& Provides a way to remove an FX or GFX object from FXListener's collections by object instance name or class name.
		*m: reportstartrundatetime_access
		*m: reportstoprundatetime_access
		*m: runcollectorresetlevel_assign
		*m: sendfx		&& Applies FXs and GFXs collection members when an event or method is called.  Returns value to indicate how default render behavior should work when invoked during Render event.
		*m: uppermethodname		&& Passed a string such as PROGRAM(), returns an upper-case version of the method name with prefixes removed.  Utility method for use  when applying FX and GFX instructions.
		*p: cancelrequested		&& Notification flag for FX objects to request a report cancellation.
		*p: classpath		&& Provides optional location specifying path for loading objects from external libraries.
		*p: ffcgraphics		&& A reference to an FFCGraphic object created during the run and provided to members of the GFXs collection. Validated as instance of GpGraphics from the FFC _GDIPLUS.VCX or a class derived from GpGraphics.
		*p: frxcursor		&& Holds a reference to an FRXCursor helper object to aid in run-time calculations related to FRX metadata, structure, and memberdata.
		*p: fxfeedbackclass		&& Class to instantiate in FX collection for user feedback (defaults to fxTherm).
		*p: fxfeedbackclasslib		&& Class library from which to instantiate FX collection object providing user feedback.
		*p: fxfeedbackmodule		&& Application module (APP or EXE)  from which to instantiate FX collection object providing user feedback.
		*p: fxmemberdatascriptclass		&& Class to instantiate in FX collection for memberdata-based script handling (defaults to fxMemberDataScript).
		*p: fxmemberdatascriptclasslib		&& Class library from which to instantiate FX collection object providing memberdata-based script-handling.
		*p: fxmemberdatascriptmodule		&& Application module (APP or EXE)  from which to instantiate FX collection object providing memberdata-based script-handling.
		*p: fxs		&& A collection of FX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,tP1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value ignored
		*p: gfxnorenderclass		&& Class to instantiate in GFX collection for conditionally eliminating baseclass rendering of various layout controls (defaults to gfxNoRender, if empty conditional rendering is turned off).
		*p: gfxnorenderclasslib		&& Class library from which to instantiate GFX collection object providing conditional baseclass rendering.
		*p: gfxnorendermodule		&& Application module (APP or EXE) from which to instantiate GFX collection object providing conditional baseclass rendering.
		*p: gfxrotateclass		&& Class to instantiate in GFX collection for rotating layout controls (defaults to gfxRotate).
		*p: gfxrotateclasslib		&& Class library from which to instantiate GFX collection object providing rotation.
		*p: gfxrotatemodule		&& Application module (APP or EXE)  from which to instantiate GFX collection object providing rotation.
		*p: gfxs		&& A collection of GFX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,P1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value significant to Render method.
		*p: loadfrxcursor		&& Determines whether this class should dynamically load an instance of the helper class FRXCursor when attempting to access a reference to it.
		*p: memberdataalias		&& Alias of cursor holding memberdata in the FRXDataSession, read from the FRX table's Style field for easy access by other objects.
		*p: reportstartrundatetime		&& A datetime value indicating when the last report generation run began, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
		*p: reportstoprundatetime		&& A datetime value for use at the conclusion of a report run, storing when the last report generation run ended, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
		*p: runcollectorresetlevel		&& Indicates how often the runCollector member should be automatically reset by the reportListener (0=never, 1=after each report, 2=after a chained report run).
	*</DefinedPropArrayMethod>

	cancelrequested = .F.		&& Notification flag for FX objects to request a report cancellation.
	classpath = ("")		&& Provides optional location specifying path for loading objects from external libraries.
	ffcgraphics = (NULL)		&& A reference to an FFCGraphic object created during the run and provided to members of the GFXs collection. Validated as instance of GpGraphics from the FFC _GDIPLUS.VCX or a class derived from GpGraphics.
	frxcursor = (NULL)		&& Holds a reference to an FRXCursor helper object to aid in run-time calculations related to FRX metadata, structure, and memberdata.
	FRXDataSession = -1
	fxfeedbackclass = ("fxTherm")		&& Class to instantiate in FX collection for user feedback (defaults to fxTherm).
	fxfeedbackclasslib = (THIS.ClassLibrary)		&& Class library from which to instantiate FX collection object providing user feedback.
	fxfeedbackmodule = ("")		&& Application module (APP or EXE)  from which to instantiate FX collection object providing user feedback.
	fxmemberdatascriptclass = ("fxMemberDataScript")		&& Class to instantiate in FX collection for memberdata-based script handling (defaults to fxMemberDataScript).
	fxmemberdatascriptclasslib = (THIS.ClassLibrary)		&& Class library from which to instantiate FX collection object providing memberdata-based script-handling.
	fxmemberdatascriptmodule = ("")		&& Application module (APP or EXE)  from which to instantiate FX collection object providing memberdata-based script-handling.
	fxs = (NULL)		&& A collection of FX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,tP1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value ignored
	gfxnorenderclass = ("gfxNoRender")		&& Class to instantiate in GFX collection for conditionally eliminating baseclass rendering of various layout controls (defaults to gfxNoRender, if empty conditional rendering is turned off).
	gfxnorenderclasslib = (THIS.ClassLibrary)		&& Class library from which to instantiate GFX collection object providing conditional baseclass rendering.
	gfxnorendermodule = ("")		&& Application module (APP or EXE) from which to instantiate GFX collection object providing conditional baseclass rendering.
	gfxrotateclass = ("gfxRotate")		&& Class to instantiate in GFX collection for rotating layout controls (defaults to gfxRotate).
	gfxrotateclasslib = (THIS.ClassLibrary)		&& Class library from which to instantiate GFX collection object providing rotation.
	gfxrotatemodule = ("")		&& Application module (APP or EXE)  from which to instantiate GFX collection object providing rotation.
	gfxs = (NULL)		&& A collection of GFX objects, required interface: PROCEDURE ApplyFX(toListener, tcMethodToken,P1, tP2, tP3, tP4, tP5, tP6, tP7, tP8, tP9, tP10, tP11, tP12) Return value significant to Render method.
	memberdataalias = ("M"+SYS(2015))		&& Alias of cursor holding memberdata in the FRXDataSession, read from the FRX table's Style field for easy access by other objects.
	Name = "fxlistener"
	reportstartrundatetime = (DTOT({}))		&& A datetime value indicating when the last report generation run began, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
	reportstoprundatetime = (DTOT({}))		&& A datetime value for use at the conclusion of a report run, storing when the last report generation run ended, if the feedback member object has been instantiated and provides a property with a matching name. Readonly.
	runcollectorresetlevel = 0		&& Indicates how often the runCollector member should be automatically reset by the reportListener (0=never, 1=after each report, 2=after a chained report run).
	_memberdata = <VFPData>
		<memberdata name="fxs" type="property" display="FXs" favorites="True" />
		<memberdata name="gfxs" type="property" display="GFXs" favorites="True" />
		<memberdata name="ffcgraphics" type="property" display="FFCGraphics"  favorites="True"/>
		<memberdata name="createhelperobjects" type="method" display="createHelperObjects"/>
		<memberdata name="needgfxs" type="method" display="needGFXs"/>
		<memberdata name="sendfx" type="method" display="sendFX"/>
		<memberdata name="checkcollectionmembers" type="method" display="checkCollectionMembers"/>
		<memberdata name="uppermethodname" type="method" display="upperMethodName" favorites="True"/>
		<memberdata name="cancelrequested" type="property" display="cancelRequested" />
		<memberdata name="fxmemberdatascriptclass" type="property" display="fxMemberDataScriptClass" favorites="True" />
		<memberdata name="fxmemberdatascriptclasslib" type="property" display="fxMemberDataScriptClassLib" favorites="True" />
		<memberdata name="fxmemberdatascriptmodule" type="property" display="fxMemberDataScriptModule" favorites="True" />
		<memberdata name="fxfeedbackclass" type="property" display="fxFeedbackClass" favorites="True" />
		<memberdata name="fxfeedbackclasslib" type="property" display="fxFeedbackClassLib" favorites="True" />
		<memberdata name="fxfeedbackmodule" type="property" display="fxFeedbackModule" favorites="True" />
		<memberdata name="getmemberdatascriptfxobject" type="method" display="getMemberDataScriptFXObject" favorites="True"/>
		<memberdata name="getfeedbackfxobject" type="method" display="getFeedbackFXObject" favorites="True"/>
		<memberdata name="classpath" type="property" display="classPath" favorites="True"/>
		<memberdata name="getobjectinstance" type="method" display="getObjectInstance" favorites="True"/>
		<memberdata name="checkcollectionforspecifiedmember" type="method" display="checkCollectionForSpecifiedMember" favorites="True"/>
		<memberdata name="addcollectionmember" type="method" display="addCollectionMember" favorites="True"/>
		<memberdata name="getpathforexternals" type="method" display="getPathForExternals" favorites="True" />
		<memberdata name="loadfrxcursor" type="property" display="loadFrxCursor" favorites="True" />
		<memberdata name="frxcursor" type="property" display="frxCursor" favorites="True" />
		<memberdata name="memberdataalias" type="property" display="memberDataAlias" favorites = "True"/>
		<memberdata name="creatememberdatacursor" type="method" display="createMemberDataCursor"/>
		<memberdata name="runcollectorresetlevel" type="property" favorites="True" display="runCollectorResetLevel"/>
		<memberdata name="getfrxrecno" type="method" display="getFRXRecno" favorites="True"/>
		<memberdata name="getrotategfxobject" type="method" display="getRotateGFXObject" favorites="True"/>
		<memberdata name="gfxrotateclass" type="property" display="gfxRotateClass" favorites="True" />
		<memberdata name="gfxrotateclasslib" type="property" display="gfxRotateClassLib" favorites="True" />
		<memberdata name="gfxrotatemodule" type="property" display="gfxRotateModule" favorites="True" />
		<memberdata name="removecollectionmember" display="removeCollectionMember" type="method" favorites="True"/>
		<memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" />
		<memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" />
		<memberdata name="evaluateuserexpression" display="evaluateUserExpression" type="method"/>
		<memberdata name="getnorendergfxobject" type="method" display="getNoRenderGFXObject" favorites="True"/>
		<memberdata name="gfxnorenderclass" type="property" display="gfxNoRenderClass" favorites="True" />
		<memberdata name="gfxnorenderclasslib" type="property" display="gfxNoRenderClassLib" favorites="True" />
		<memberdata name="gfxnorendermodule" type="property" display="gfxNoRenderModule" favorites="True" />
		<memberdata name="ensurecollection" type="method" display="ensureCollection"/>
		</VFPData>
	
	PROCEDURE addcollectionmember		&& Adds instance of specified class in specified class library  to FX or GFX collection. Params: tcClass, tcClassLib,tcModule,tlSingleton, tlInGFX, tlRequired
		LPARAMETERS m.tcClass, m.tcClassLib,m.tcModule,m.tlSingleton, m.tlInGFX, m.tlRequired
		
		LOCAL m.loX, m.lExists, m.liReturn
		
		m.liReturn = OUTPUTFX_ADDCOLLECTION_NOACTION 
		
		IF m.tlSingleton
		  m.lExists =  THIS.checkCollectionForSpecifiedMember(m.tcClass,m.tcClassLib,m.tlInGFX)
		ELSE
		  * checkCollectionForSpecifiedMember will have done this already
		  THIS.ensureCollection(m.tlInGFX)  
		ENDIF
		
		IF NOT m.lExists               
		   m.loX = THIS.getObjectInstance(;
		          m.tcClass,;
		          m.tcClassLib,;
		          m.tcModule, ;
		         .T., IIF(tlInGFX,"GFX","FX"),tlRequired)
		   IF ISNULL(m.loX)      
		      m.liReturn = OUTPUTFX_ADDCOLLECTION_FAILURE
		   ELSE
		      IF (NOT PEMSTATUS(m.loX,"ApplyFX",5))
		         m.liReturn = OUTPUTFX_ADDCOLLECTION_UNSUITABLE
		      ELSE
		         IF tlInGFX
		            THIS.GFXs.Add(m.loX)         
		         ELSE
		            THIS.FXs.Add(m.loX)
		         ENDIF            
		         m.liReturn = OUTPUTFX_ADDCOLLECTION_SUCCESS
		      ENDIF            
		   ENDIF   
		
		ENDIF   
		
		RETURN m.liReturn
		
	ENDPROC

	PROCEDURE AdjustObjectSize
		LPARAMETERS m.nFRXRecno, m.oObjProperties
		THIS.sendFX(PROGRAM(),m.nFRXRecno, m.oObjProperties)
		NODEFAULT
		IF (NOT ISNULL(THIS.Successor))
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.AdjustObjectSize(m.nFRXRecno, m.oObjProperties)
		ENDIF
		DODEFAULT(m.nFRXRecno, m.oObjProperties)
	ENDPROC

	PROCEDURE AfterBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		THIS.sendFX(PROGRAM(),m.nBandObjCode, m.nFRXRecNo)  
		NODEFAULT
		RETURN DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
	ENDPROC

	PROCEDURE AfterReport
		THIS.sendFX(PROGRAM())  
		NODEFAULT
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE BeforeBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		IF m.nBandObjCode = FRX_OBJCOD_PAGEHEADER  ;
		   AND THIS.GFXs.Count > 0
		   THIS.FFCGraphics.SetHandle(THIS.GDIPlusGraphics)
		ENDIF
		THIS.sendFX(PROGRAM(),m.nBandObjCode, m.nFRXRecNo)  
		NODEFAULT
		RETURN DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
	ENDPROC

	PROCEDURE BeforeReport
		THIS.setFRXDataSession()
		IF (NOT THIS.IsSuccessor)
		   THIS.createMemberDataCursor()  
		   IF NOT ISNULL(THIS.successor)
		      THIS.successor.AddProperty("memberDataAlias",THIS.memberDataAlias)
		   ENDIF               
		ENDIF       
		
		* second opportunity to create FX and GFX objects,
		* in case some are needed that were not needed before:
		THIS.checkCollectionMembers(.T.)
		
		* second opportunity to create non-optional helper members,
		* in case some are needed that were not needed before,
		* Any items that would have been required for
		* FX/GFX-specific use should already have been created during
		* LoadReport, so this set of calls is "backwards" 
		* from LoadReport pairing:
		THIS.createHelperObjects(.T.)
		
		* note: at this point,
		* the FX and GFX objects have 
		* an opportunity to
		* adjust items such as CallAdjustObjectSize, CallEvaluateContents, TwoPassProcess
		THIS.sendFX(PROGRAM())  
		NODEFAULT
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE CancelReport
		IF THIS.FXs.Count > 0
		   THIS.sendFX(PROGRAM())  
		   IF THIS.cancelRequested
		      DODEFAULT()
		   ELSE
		      NODEFAULT
		   ENDIF
		ELSE
		   DODEFAULT()
		ENDIF      
		
	ENDPROC

	PROCEDURE cancelrequested_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.cancelRequested = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE checkcollectionforspecifiedmember		&& Checks FX or GFX collection for instance of specified class by class and (if specified) by class library name. Returns logical (.F. if not found) or object reference (NULL if not found).
		LPARAMETERS m.tcClass, m.tcClassLib, m.tlInGFX, m.tlReturnRef
		
		LOCAL m.liIndex, m.loXs, m.loX, m.lcForceVCX, m.lcClassLib, ;
		      m.lcClass, m.lcThisLib, m.llFound, m.loRef
		
		THIS.ensureCollection(m.tlInGFX) 
		
		IF m.tlInGFX
		  m.loXs = THIS.GFXs
		ELSE
		   m.loXs = THIS.FXs
		ENDIF   
		
		m.loRef = NULL
		
		m.lcClass = UPPER(m.tcClass)
		
		IF NOT EMPTY(m.tcClassLib)
		   m.lcClassLib = UPPER(JUSTFNAME(m.tcClassLib))
		   m.lcForceVCX = FORCEEXT(lcClassLib,"VCX")
		   m.lcForceFXP = STRTRAN(lcClassLib,".PRG",".FXP")
		ENDIF   
		
		FOR m.liIndex = 1 TO m.loXs.Count
		   m.loX = loXs.Item(liIndex)
		   m.lcThisLib = UPPER(JUSTFNAME(loX.ClassLibrary))
		   IF UPPER(loX.Class) == m.lcClass AND ;
		      (EMPTY(m.lcClassLib) OR ;
		       m.lcThisLib == m.lcClassLib OR ;
		       m.lcThisLib == m.lcForceVCX OR ;
		       m.lcThisLib == m.lcForceFXP) 
		       m.llFound = .T.
		       m.loRef = m.loX
		       EXIT
		   ENDIF         
		NEXT
		
		IF m.tlReturnRef
		   RETURN m.loRef
		ELSE
		   RETURN m.llFound
		ENDIF   
	ENDPROC

	PROTECTED PROCEDURE checkcollectionmembers		&& Eliminates members of FXs and GFXs collections in LoadReport and again in BeforeReport if they do not match required interfaces. Verifies availability of appropriate members.
		LPARAMETERS m.tlCalledFromBeforeReport
		* NB: use of this argument and 
		* no distinction made between calls from
		* BeforeReport and LoadReport at this level,
		* this distinction is made available for subclasses
		* that might not have all materials prepared for
		* creation of required collection members during Load.
		
		LOCAL m.liIndex, m.loX, m.loXs as Collection
		
		THIS.getFeedbackFXObject()
		
		THIS.getMemberDataScriptFXObject()
		
		THIS.getRotateGFXObject()
		
		THIS.getNoRenderGFXObject()
		
		m.loXs = THIS.FXs
		
		FOR m.liIndex = 1 TO THIS.FXs.Count
		   m.loX = loXs.Item(m.liIndex)
		   IF VARTYPE(m.loX) # "O" OR ;
		     (NOT PEMSTATUS(m.loX,"ApplyFX",5))
		     loXs.Remove(m.liIndex)
		   ENDIF
		NEXT
		
		m.loXs = THIS.GFXs
		
		FOR m.liIndex = 1 TO THIS.GFXs.Count
		   m.loX = loXs.Item(liIndex)
		   IF VARTYPE(m.loX) # "O" OR ;
		     (NOT PEMSTATUS(m.loX,"ApplyFX",5))
		     loXs.Remove(m.liIndex)
		   ENDIF
		NEXT
		
		STORE NULL TO m.loX, m.loXs
		
		
		
	ENDPROC

	PROCEDURE classpath_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND ;
		   DIRECTORY(m.vNewVal)
		   IF NOT EMPTY(m.vNewVal)
		      m.vNewVal = ADDBS(m.vNewVal)
		   ENDIF
		   THIS.classPath = m.vNewVal
		ELSE
		   THIS.ResetToDefault("classPath")   
		ENDIF 
		
		  
		
	ENDPROC

	PROCEDURE ClearStatus
		THIS.sendFX(PROGRAM())  
		
		
	ENDPROC

	PROTECTED PROCEDURE createhelperobjects		&& Creates FXs and GFXs collections, and additional required object members such as the FFCGraphics object.
		LPARAMETERS m.tlCalledFromBeforeReport
		* see note in CheckCollectionMembers method about parameter, which
		* is not used here but could provide significant information to
		* subclasses
		
		* NB this method creates only required helpers, not optional FX objects
		* which is handled in CheckCollectionMembers
		EXTERNAL CLASS _GDIPLUS.VCX
		LOCAL liSession
		m.liSession = SET("DATASESSION")
		THIS.resetDataSession()
		THIS.ensureCollection()
		THIS.ensureCollection(.T.)
		SET DATASESSION TO (m.liSession)
		IF VARTYPE(THIS.FFCGraphics) # "O"  AND THIS.GFXs.Count > 0
		   THIS.FFCGraphics =;
		      THIS.getObjectInstance("GpGraphics","_GDIPlus.VCX","", .T.,"GP", .T.)
		   IF NOT ISNULL(THIS.FFCGraphics)
		      THIS.FFCGraphics.QuietOnError = THIS.QuietMode
		   ENDIF      
		ENDIF   
		     
		
	ENDPROC

	PROTECTED PROCEDURE creatememberdatacursor		&& Creates a cursor in the FRX datasession to hold extended information about FRX data rows.
		
		IF USED("FRX")
		   SELECT FRX
		   LOCATE FOR Platform = FRX_PLATFORM_WINDOWS AND NOT (EMPTY(Style) OR DELETED())
		   IF  EOF() 
		      THIS.loadFrxCursor = .F.
		   ELSE
		      THIS.loadFRXCursor = .T.
		      DO CASE
		      CASE (NOT THIS.loadFRXCursor) OR ISNULL(THIS.FRXCursor)
		         * message already taken care of
		      CASE PEMSTATUS(THIS.FRXCursor,"UnpackFRXMemberdata",5)
		         THIS.FRXCursor.UnpackFRXMemberData("FRX",THIS.memberDataAlias,THIS.FRXDataSession)
		      OTHERWISE
		         THIS.DoMessage(OUTPUTFX_SCRIPTING_UNAVAILABLE_LOC ,MB_ICONEXCLAMATION)      
		      ENDCASE
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		STORE NULL TO THIS.FXs, THIS.GFXs, THIS.FFCGraphics, ;
		      THIS.FRXCursor
		DODEFAULT()
	ENDPROC

	PROCEDURE DoStatus
		LPARAMETERS m.cMessage
		THIS.sendFX(PROGRAM(),m.cMessage)  
		NODEFAULT
		
	ENDPROC

	PROTECTED PROCEDURE ensurecollection		&& Ensures valid object collections for GFXs and FXs member references.
		LPARAMETERS m.tlGFXs
		IF m.tlGFXs
		   IF VARTYPE(THIS.GFXs) # "O" OR ;
		      (NOT UPPER(THIS.GFXs.BaseClass) == "COLLECTION")
		      THIS.GFXs = CREATEOBJECT("Collection")
		   ENDIF
		ELSE
		   IF VARTYPE(THIS.FXs) # "O" OR ;
		      (NOT UPPER(THIS.FXs.BaseClass) == "COLLECTION")
		      THIS.FXs = CREATEOBJECT("Collection")    
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE EvaluateContents
		LPARAMETERS m.nFRXRecno, m.oObjProperties
		THIS.sendFX(PROGRAM(),m.nFRXRecno, m.oObjProperties)
		NODEFAULT
		IF (NOT ISNULL(THIS.Successor))
		   THIS.SetSuccessorDynamicProperties()
		   THIS.Successor.EvaluateContents(m.nFRXRecno, m.oObjProperties)
		ENDIF
		DODEFAULT(m.nFRXRecno, m.oObjProperties)
	ENDPROC

	PROTECTED PROCEDURE evaluateuserexpression		&& Attempts to evaluate a user-provided expression in various report run datasessions and return a valid result.
		LPARAMETERS m.tvValueExpr
		LOCAL m.liSession, m.lvValue
		m.lvValue = ""
		m.liSession = SET("DATASESSION")
		THIS.setCurrentDataSession()
		IF TYPE(m.tvValueExpr) # "U"
		   m.lvValue = EVALUATE(m.tvValueExpr)
		ELSE
		   THIS.setFRXDataSession()
		   IF TYPE(m.tvValueExpr) # "U"
		      m.lvValue = EVALUATE(m.tvValueExpr)
		   ELSE
		      THIS.resetDataSession()
		      IF TYPE(m.tvValueExpr) # "U"
		         m.lvValue = EVALUATE(m.tvValueExpr)
		      ELSE
		         IF TYPE ("THIS.CommandClauses.StartDatasession") = "N" AND ;
		            THIS.CommandClauses.StartDatasession > 0 AND ;
		            (THIS.CommandClauses.StartDatasession # THIS.ListenerDataSession)
		            SET DATASESSION TO (THIS.CommandClauses.StartDataSession)
		            IF TYPE(m.tvValueExpr) # "U"
		               m.lvValue = EVALUATE(m.tvValueExpr)
		            ENDIF
		         ENDIF   
		      ENDIF
		   ENDIF
		ENDIF
		SET DATASESSION TO (m.liSession)
		RETURN m.lvValue 
	ENDPROC

	PROCEDURE ffcgraphics_assign
		LPARAMETERS m.tvNewVal
		DO CASE
		CASE ISNULL(m.tvNewVal) AND (NOT THIS.isRunning)
		   THIS.FFCGraphics = m.tvNewVal
		CASE VARTYPE(m.tvNewVal) = "O"
		   LOCAL laDummy[1]
		   IF ACLASS(laDummy,m.tvNewVal) > 0 AND ;
		      ASCAN(laDummy,"GpGraphics",1,ALEN(laDummy),1, 7) > 0 && case insensitive, exact on
		      THIS.FFCGraphics = m.tvNewVal
		   ENDIF      
		OTHERWISE
		   * don't   
		ENDCASE
		
	ENDPROC

	PROCEDURE frxcursor_access
		IF (NOT THIS.IsRunning) AND ;
		   ISNULL(THIS.frxCursor) AND THIS.loadFRXCursor
		   THIS.frxCursor = ;
		      THIS.getObjectInstance("FRXCursor","_FRXCURSOR.VCX","", .T.,"frx", .T.)
		   IF ISNULL(THIS.frxCursor)
		      THIS.loadFRXCursor = .F.
		   ELSE
		      THIS.frxCursor.QuietMode = THIS.QuietMode      
		   ENDIF
		ENDIF      
		RETURN THIS.frxCursor
		
	ENDPROC

	PROCEDURE frxcursor_assign
		LPARAMETERS m.vNewVal
		IF ISNULL(m.vNewVal) OR (NOT THIS.IsRunning)
		   THIS.frxcursor = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE fxfeedbackclasslib_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.fxFeedbackClassLib = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE fxfeedbackclass_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.fxFeedbackClass = m.vNewVal
		ENDIF
	ENDPROC

	PROCEDURE fxfeedbackmodule_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "C" 
		   THIS.fxFeedbackModule = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE fxmemberdatascriptclasslib_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.fxMemberDataScriptClassLib = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE fxmemberdatascriptclass_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.fxMemberDataScriptClass = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE fxmemberdatascriptmodule_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "C" 
		   THIS.fxMemberDataScriptModule = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE getfeedbackfxobject		&& Instantiates FX object to provide user feedback.
		LPARAMETERS m.tlQuiet
		
		
		IF (NOT THIS.QuietMode) AND ;
		   (NOT THIS.isSuccessor) AND ;
		   (TYPE("THIS.CommandClauses.NoDialog") # "L" OR ;
		    (NOT THIS.CommandClauses.NoDialog))
		
		   THIS.addCollectionMember(;
		         THIS.fxFeedbackClass,;
		         THIS.fxFeedbackClassLib,;
		         THIS.fxFeedbackModule, .T.)
		      
		   IF NOT THIS.checkCollectionForSpecifiedMember(;
		          THIS.fxFeedbackClass,;
		          THIS.fxFeedbackClassLib)
		       IF NOT m.tlQuiet
		          THIS.DoMessage(OUTPUTFX_USERFEEDBACK_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
		       ENDIF       
		       THIS.QuietMode = .T.
		   ENDIF    
		
		ENDIF   
		
		
	ENDPROC

	PROCEDURE getfrxrecno		&& Determine the current FRX cursor row number from the parameters passed to a ReportListener event.
		LPARAMETERS m.tcMethodToken,m.tP1, m.tP2
		
		LOCAL m.liFRXRecno, m.liSession
		
		m.liFRXRecno = 0
		
		DO CASE
		CASE INLIST(m.tcMethodToken,"BEFOREREPORT","AFTERREPORT","LOADREPORT","UNLOADREPORT")
		   IF THIS.frxHeaderRecno = -1
		      * this is an early call. find the value early if possible
		      m.liSession = SET("DATASESSION")
		      THIS.setFRXDataSession()
		      IF USED("FRX")
		         SELECT FRX
		         LOCATE FOR ObjType = FRX_OBJTYP_REPORTHEADER AND ;
		                    Platform = FRX_PLATFORM_WINDOWS AND ;
		                    NOT DELETED()
		         THIS.frxHeaderRecno = RECNO()
		      ELSE
		         THIS.frxHeaderRecno = 1
		      ENDIF
		      SET DATASESSION TO (m.liSession)
		   ENDIF   
		   m.liFRXRecNo = THIS.frxHeaderRecno 
		CASE INLIST(m.tcMethodToken,"BEFOREBAND","AFTERBAND") AND ;
		     VARTYPE(m.tP2) = "N" && Band events
		   m.liFRXRecNo = m.tP2          
		CASE VARTYPE(m.tP1) = "N"  && Render, other events   
		   m.liFRXRecNo = m.tP1
		OTHERWISE
		   * called inappropriately
		ENDCASE
		
		RETURN  m.liFRXRecno
	ENDPROC

	PROTECTED PROCEDURE getmemberdatascriptfxobject		&& Instantiates FX object to provide memberdata-based script handling.
		
		THIS.setFRXDataSession()
		IF USED(THIS.memberDataAlias) AND ;
		   RECCOUNT(THIS.memberDataAlias) > 0
		   SELECT (THIS.memberDataAlias)
		   LOCATE FOR (NOT EMPTY(Execute))
		   IF NOT EOF()
		      THIS.addCollectionMember(;
		           THIS.fxMemberDataScriptClass,;
		           THIS.fxMemberDataScriptClassLib,;
		           THIS.fxMemberDataScriptModule, .T.)
		      IF NOT THIS.checkCollectionForSpecifiedMember(;
		           THIS.fxMemberDataScriptClass,;
		           THIS.fxMemberDataScriptClassLib)
		           THIS.DoMessage(OUTPUTFX_SCRIPTING_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
		      ENDIF
		   ENDIF      
		   IF USED("FRX")
		      SELECT FRX
		   ENDIF
		ENDIF
		
		
		
	ENDPROC

	PROTECTED PROCEDURE getnorendergfxobject		&& Instantiates GFX object to provide memberdata-specified conditional baseclass rendering.
		IF NOT EMPTY(THIS.gfxNoRenderClass)
		   LOCAL m.llNeedThisGFX, m.llOpenedMemberData
		   THIS.setFRXDataSession()
		   IF (NOT USED(THIS.memberDataAlias)) AND ;
		      (NOT THIS.CommandClauses.IsDesignerLoaded) AND ;
		      (NOT THIS.checkCollectionForSpecifiedMember(;
		              THIS.gfxNoRenderClass,;
		              THIS.gfxNoRenderClassLib, .T.))
		      IF NOT USED("FRX") && during LoadReport
		         IF FILE(THIS.CommandClauses.File)
		            USE (THIS.CommandClauses.File) AGAIN SHARED NOUPDATE ALIAS FRX
		            * this is a special situation, in that
		            * this gfx needs to be available to do a swap
		            * *before* memberdata is commonly available.
		            * At this point, depending on what else has happened,
		            * Memberdata may or may not be here. If it is not,
		            * we could build the memberdata cursor here temporarily --
		            * the gfx itself will do that, in fact -- but in this
		            * method we're just ascertaining the requirement for
		            * the gfx to *exist*.  This doesn't merit the extra time
		            * to do an exact comparison of the appropriate memberdata
		            * element.  If we might need it, the class should be 
		            * instantiated.  Let it do the special build of memberdata
		            * later and do its evaluations at that time.
		            LOCATE FOR  FRX_BLDR_ADVPROP_PREPROCESS_NORENDER $ Style ;
		                        AND NOT DELETED()
		            m.llNeedThisGFX = (NOT EOF())
		            USE IN FRX
		         ELSE
		            * built-into another app, just load without the check
		            m.llNeedThisGFX = .T.
		         ENDIF
		         IF m.llNeedThisGFX
		            THIS.loadFrxCursor = .T.
		         ENDIF    
		      ENDIF              
		   ENDIF      
		   IF (NOT m.llNeedThisGFX) AND ;
		      USED(THIS.memberDataAlias) AND ;
		      RECCOUNT(THIS.memberDataAlias) > 0
		      * now we'll check in the normal way later in the report for
		      * any required instance suppression, which occurs
		      * later in the report cycle and can use the normal build
		      * of memberdata
		      SELECT (THIS.memberDataAlias)
		      LOCATE FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
		                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                 (ExecWhen == FRX_BLDR_ADVPROP_INSTANCE_NORENDER AND ;
		                 NOT EMPTY(Execute))  OR ;
		                 (ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER)
		      IF NOT EOF()
		         m.llNeedThisGFX = .T.
		      ENDIF
		   ENDIF
		   IF m.llNeedThisGFX
		      THIS.addCollectionMember(;
		           THIS.gfxNoRenderClass,;
		           THIS.gfxNoRenderClassLib,;
		           THIS.gfxNoRenderModule, .T., .T.)
		      IF NOT THIS.checkCollectionForSpecifiedMember(;
		           THIS.gfxNoRenderClass,;
		           THIS.gfxNoRenderClassLib, .T.)
		           THIS.DoMessage(OUTPUTFX_CONDITIONALRENDERING_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
		      ENDIF
		   ENDIF         
		   IF USED("FRX")
		      SELECT FRX
		   ENDIF
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE getobjectinstance		&& Provides a method for instancing classes as helper/member objects or FX/GFX collection members using specific path priorities.
		LPARAMETERS m.tcClass, m.tcClassLib, m.tcModule, ;
		            m.tlAssignUniqueNameToObject, ;
		            m.tcNamePrefix, m.tlMandatoryObject
		
		IF VARTYPE(m.tcClass) # "C" OR EMPTY(m.tcClass)
		   IF m.tlMandatoryObject
		      THIS.DoMessage(OUTPUTFX_REQUIREDOBJECTDEF_MISSING_LOC,MB_ICONEXCLAMATION)
		   ENDIF
		   RETURN NULL
		ENDIF
		
		LOCAL m.loX,m.lcForceVCX, m.lcForceFXP, m.lcUseThisLib, m.lcExternalsPath, m.liSession
		
		liSession = SET("DATASESSION")
		THIS.ResetDataSession()
		m.lcForceVCX = FORCEEXT(m.tcClassLib,"VCX")
		m.lcForceFXP = STRTRAN(m.tcClassLib,".PRG",".FXP")
		m.lcExternalsPath = THIS.getPathForExternals()
		
		m.loX = NULL
		
		TRY 
		   DO CASE
		   CASE FILE(m.tcClassLib) OR ;
		        FILE(m.lcForceVCX) OR ;
		        ATC(FULLPATH(m.lcForceVCX) + " ALIAS ",SET("CLASSLIB")) > 0 OR ;
		        ATC("\" + JUSTFNAME(m.lcForceVCX) + " ALIAS ",SET("CLASSLIB")) > 0 OR ;
		        ATC(m.tcClassLib,SET("PROCEDURE")) > 0 OR ;
		        ATC(m.lcForceFXP,SET("PROCEDURE")) > 0
		        m.lcUseThisLib = m.tcClassLib
		   CASE FILE(FORCEPATH(m.tcClassLib,m.lcExternalsPath)) OR ;
		        FILE(FORCEPATH(m.lcForceVCX,m.lcExternalsPath)) OR ;
		        FILE(FORCEPATH(m.lcForceFXP,m.lcExternalsPath)) 
		        m.lcUseThisLib = FORCEPATH(m.tcClassLib,m.lcExternalsPath)
		   CASE FILE(FORCEPATH(m.tcClassLib,HOME(0)+"FFC\")) OR ;
		        FILE(FORCEPATH(m.lcForceVCX,HOME(0)+"FFC\")) 
		        FILE(FORCEPATH(m.lcForceFXP,HOME(0)+"FFC\"))         
		        m.lcUseThisLib = FORCEPATH(m.tcClassLib,HOME(0) + "FFC\") 
		   CASE FILE(FORCEPATH(m.tcClassLib,HOME(0)+"FFC\" + THIS.classPath)) OR ;
		        FILE(FORCEPATH(m.lcForceVCX,HOME(0)+"FFC\" + THIS.classPath)) 
		        FILE(FORCEPATH(m.lcForceFXP,HOME(0)+"FFC\" + THIS.classPath))         
		        m.lcUseThisLib = FORCEPATH(m.tcClassLib,HOME(0) + "FFC\" + THIS.classPath) 
		   OTHERWISE
		        m.lcUseThisLib = m.tcClassLib
		        * may error, but if it's a required object,
		        * it *should* error.
		   ENDCASE 
		             
		   m.loX =  NEWOBJECT(m.tcClass, m.lcUseThisLib, ;
		            IIF(VARTYPE(m.tcModule)="C",m.tcModule,""))          
		   
		   IF (NOT ISNULL(m.loX)) AND m.tlAssignUniqueNameToObject
		      m.tcNamePrefix = IIF(VARTYPE(m.tcNamePrefix) = "C", ;
		                            m.tcNamePrefix, "FXH")
		      m.loX.Name = m.tcNamePrefix + SYS(2015)                         
		   ENDIF   
		
		CATCH TO err
		   m.loX = NULL
		   #IF OUTPUTCLASS_DEBUGGING 
		       SUSPEND
		   #ENDIF
		ENDTRY
		
		IF m.tlMandatoryObject AND ISNULL(m.loX)
		   THIS.DoMessage(OUTPUTFX_REQUIREDOBJECT_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
		ENDIF
		SET DATASESSION TO (m.liSession)
		RETURN m.loX
	ENDPROC

	PROCEDURE getpathforexternals		&& Determines the location at which the current configuration table and any other required external files will be expected.
		* this is  mostly for standalone use
		* first figure out where to put it
		* with the idea of not littering
		* the disk too much based on CURDIR().
		   
		* For app pieces, look for a container module
		* and put it there.
		* if there isn't one,
		* put it with the VCX
		      
		LOCAL m.liLevel, m.lcSys16, m.lcPath
		
		IF ":" $ THIS.classPath
		   * explicit path
		   m.lcPath = THIS.classPath
		ELSE
		   FOR m.liLevel = PROGRAM(-1) TO 1 STEP -1
		       m.lcSys16 = UPPER(SYS(16,m.liLevel))
		      IF INLIST(RIGHT(m.lcSys16,3),"APP","EXE","DLL")
		         m.lcPath = JUSTPATH(m.lcSys16)
		         EXIT
		      ENDIF
		   ENDFOR
		   IF (NOT EMPTY(lcPath)) AND ;
		      (NOT EMPTY(THIS.classPath)) AND ;
		       DIRECTORY(FULLPATH(THIS.classPath,ADDBS(lcPath)))
		       m.lcPath = FULLPATH(THIS.classPath,ADDBS(lcPath))
		   ENDIF
		ENDIF   
		      
		IF EMPTY(m.lcPath)
		   m.lcPath = JUSTPATH(THIS.ClassLibrary)
		   IF (NOT EMPTY(lcPath)) AND ;
		      (NOT EMPTY(THIS.classPath)) AND ;
		       DIRECTORY(FULLPATH(THIS.classPath,ADDBS(lcPath)))
		       m.lcPath = FULLPATH(THIS.classPath,ADDBS(lcPath))
		   ENDIF
		ENDIF
		
		IF NOT DIRECTORY(m.lcPath)
		   m.lcPath = ""
		ELSE 
		   m.lcPath = ADDBS(m.lcPath)   
		ENDIF
		
		RETURN m.lcPath
	ENDPROC

	PROTECTED PROCEDURE getrotategfxobject		&& Instantiates GFX object to provide memberdata-based rotation of layout controls.
		THIS.setFRXDataSession()
		IF USED(THIS.memberDataAlias) AND RECCOUNT(THIS.memberDataAlias) > 0
		   SELECT (THIS.memberDataAlias)
		   LOCATE FOR  Type = FRX_BLDR_MEMBERDATATYPE AND ;
		               Name == FRX_BLDR_NAMESPACE_ROTATE AND ;
		               NOT EMPTY(Execute)                    
		   IF NOT EOF()
		      THIS.addCollectionMember(;
		           THIS.gfxRotateClass,;
		           THIS.gfxRotateClassLib,;
		           THIS.gfxRotateModule, .T., .T.)
		      IF NOT THIS.checkCollectionForSpecifiedMember(;
		           THIS.gfxRotateClass,;
		           THIS.gfxRotateClassLib, .T.)
		           THIS.DoMessage(OUTPUTFX_ROTATION_UNAVAILABLE_LOC,MB_ICONEXCLAMATION)
		      ENDIF
		
		   ENDIF      
		   IF USED("FRX")
		      SELECT FRX
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE gfxnorenderclasslib_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" 
		   THIS.gfxNoRenderClassLib = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE gfxnorenderclass_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" 
		   THIS.gfxNoRenderClass = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE gfxnorendermodule_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" 
		   THIS.gfxNoRenderModule = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE gfxrotateclasslib_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.gfxRotateClassLib = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE gfxrotateclass_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.gfxRotateClass = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE gfxrotatemodule_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" 
		   THIS.gfxRotateModule = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   THIS.AppName = OUTPUTFX_APPNAME_LOC
		   THIS.Name = "FX" + SYS(2015)
		   THIS.createHelperObjects()
		   *&* THIS.getFeedbackFXObject(.T.)
		ELSE
		   RETURN .F.   
		ENDIF
		
		RETURN NOT THIS.hadError 
	ENDPROC

	PROCEDURE loadfrxcursor_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
		   THIS.loadfrxcursor = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE LoadReport
		* always start with full reset for this run:
		THIS.CallAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_NEVER
		THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_NEVER
		THIS.commandClausesFile = THIS.CommandClauses.File
		
		* see notes in BeforeReport
		*** DH 03/09/2012: moved this line from below to here as per http://cathypountney.blogspot.de/2009/04/set-talk-appears-to-be-on-when-running.html
		THIS.setFRXDataSessionEnvironment() 
		THIS.createHelperObjects()
		THIS.checkCollectionMembers()
		*** DH 03/09/2012: commented out this line (moved above)
		*THIS.setFRXDataSessionEnvironment() 
		THIS.sendFX(PROGRAM())  
		
		NODEFAULT
		RETURN DODEFAULT() && these changes can be passed on to successors
		
	ENDPROC

	PROCEDURE memberdataalias_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT EMPTY(m.vNewVal)
		   THIS.memberDataAlias = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE needgfxs		&& Hook method to evaluate whether this method needs to call the GFXs collection members for rendering purposes.
		LPARAMETERS m.tcProgram,;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP8, m.tP10, m.tP11, m.tP12
		* hook
		* a subclass could evaluate conditions,
		* such as whether any objects have custom properties
		* requiring GFX activity.
		
		RETURN .T.            
	ENDPROC

	PROCEDURE quietmode_assign
		LPARAMETERS m.vNewVal
		DODEFAULT(m.vNewVal)
		IF THIS.loadFRXCursor AND (NOT ISNULL(THIS.FRXCursor))
		   THIS.FRXCursor.QuietMode = THIS.QuietMode
		ENDIF   
		IF NOT ISNULL(THIS.FFCGraphics)
		   THIS.FFCGraphics.QuietOnError = THIS.QuietMode
		ENDIF      
		
		   
	ENDPROC

	PROCEDURE removecollectionmember		&& Provides a way to remove an FX or GFX object from FXListener's collections by object instance name or class name.
		LPARAMETERS m.tcName, m.tlInGFX, m.tlNameIsClass
		
		LOCAL m.liIndex, m.loXs, m.loX, m.llFound, m.lcName
		
		IF EMPTY(m.tcName) OR VARTYPE(m.tcName) # "C"
		   RETURN .F.
		ENDIF   
		
		IF m.tlInGFX
		  m.loXs = THIS.GFXs
		ELSE
		   m.loXs = THIS.FXs
		ENDIF   
		
		m.lcName = ALLTRIM(UPPER(m.tcName))
		
		FOR m.liIndex = 1 TO m.loXs.Count
		   m.loX = loXs.Item(liIndex)
		   IF (UPPER(loX.Name) == m.lcName) OR ;
		      (m.tlNameIsClass AND UPPER(loX.Class) == m.lcName)
		       m.loXs.Remove(m.liIndex)
		       m.llFound = .T.
		       EXIT
		   ENDIF         
		NEXT
		
		RETURN m.llFound
	ENDPROC

	PROCEDURE Render
		LPARAMETERS m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage
		
		LOCAL m.liDefaultBehavior,m.llNeedGFXs, m.lnState
		       
		m.llNeedGFXs = (NOT THIS.IsSuccessor) AND THIS.GFXs.Count > 0 AND ;
		               THIS.NeedGFXs(PROGRAM(),m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		               m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		
		IF m.llNeedGFXs
		   THIS.FFCGraphics.SetHandle(THIS.GDIPlusGraphics)
		   * done in BeforeBand for the page header
		   * for GFX objects, in case they (for any reason) choose to
		   * manipulate the page in other methods than Render.
		   * but we'll do it again here.
		   THIS.FFCGraphics.Save(@m.lnState)
		ENDIF
		          
		m.liDefaultBehavior = ;
		    THIS.sendFX(PROGRAM(),m.nFRXRecNo,;
		                @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight,;
		                @m.nObjectContinuationType, ;
		                @m.cContentsToBeRendered, @m.GDIPlusImage)
		NODEFAULT
		
		* note that FX objects get the args passed by reference, 
		* however the GFX objects
		* should not be seeking to change these args and 
		* receive the args passed by value. Their
		* job is to draw, not to change what is drawn by others or the base.
		                   
		DO CASE
		       
		CASE m.llNeedGFXs AND ;
		     m.liDefaultBehavior = OUTPUTFX_BASERENDER_RENDER_BEFORE_RESTORE
		     
		     DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		     THIS.FFCGraphics.Restore(m.lnState)
		
		CASE m.llNeedGFXs AND ;
		     m.liDefaultBehavior >= OUTPUTFX_BASERENDER_NORENDER
		     THIS.FFCGraphics.Restore(m.lnState)                        
		     IF (NOT ISNULL(THIS.Successor))
		        THIS.SetSuccessorDynamicProperties()
		        THIS.Successor.Render(m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		             m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		     ENDIF
		               
		CASE m.llNeedGFXs && OUTPUTFX_BASERENDER_AFTERRESTORE, ;
		                  && OUTPUTFX_DEFAULT_RENDER_BEHAVIOR
		
		     THIS.FFCGraphics.Restore(m.lnState)
		     DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		                m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		
		OTHERWISE  && no GFX behavior at all, just base behavior
		
		     DODEFAULT( m.nFRXRecno, m.nLeft, m.nTop, m.nWidth, m.nHeight, ;
		                m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage)
		
		ENDCASE
		
		RETURN m.liDefaultBehavior
	ENDPROC

	PROCEDURE reportstartrundatetime_access
		LOCAL m.lox, m.ldt
		m.lox = THIS.checkCollectionForSpecifiedMember(;
		      THIS.fxFeedbackClass, THIS.fxFeedbackClassLib,.f., .t.) 
		IF (NOT ISNULL(m.lox)) AND PEMSTATUS(m.lox,"reportStartRunDatetime",5)
		   m.ldt = m.lox.reportStartRunDateTime
		ELSE
		   m.ldt = THIS.reportStartRunDateTime   
		ENDIF   
		m.lox = NULL
		RETURN m.ldt
		   
		
	ENDPROC

	PROCEDURE reportstoprundatetime_access
		LOCAL m.lox, m.ldt
		m.lox = THIS.checkCollectionForSpecifiedMember(;
		      THIS.fxFeedbackClass, THIS.fxFeedbackClassLib,.F., .T.) 
		IF (NOT ISNULL(m.lox)) AND PEMSTATUS(m.lox,"reportStopRunDatetime",5)
		   m.ldt = lox.reportStopRunDateTime
		ELSE
		   m.ldt = THIS.reportStopRunDateTime 
		ENDIF   
		m.lox = NULL
		RETURN m.ldt
		   
		
	ENDPROC

	PROCEDURE resetcalladjustobjectsize
		* abstract, note that fx and gfx objects already
		* have an opportunity via sendFX call.
	ENDPROC

	PROCEDURE resetcallevaluatecontents
		* abstract, note that fx and gfx objects already
		* have an opportunity via sendFX call.
		
	ENDPROC

	PROCEDURE runcollectorresetlevel_assign
		LPARAMETERS tvNewVal
		IF VARTYPE(m.tvNewVal) = "N" AND ;
		   INLIST(m.tvNewVal,OUTPUTFX_RUNCOLLECTOR_RESET_NEVER , ;
		                     OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT,;
		                     OUTPUTFX_RUNCOLLECTOR_RESET_ONCHAIN)
		   THIS.runCollectorResetLevel = m.tvNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE sendfx		&& Applies FXs and GFXs collection members when an event or method is called.  Returns value to indicate how default render behavior should work when invoked during Render event.
		LPARAMETERS m.tcProgram, ;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, ;
		            m.tP6, m.tP7, m.tP8, m.tP9, m.tP10, ;
		            m.tP11, m.tP12)
		  LOCAL m.loFX, m.liRenderBehavior, m.liTemp, m.lcMethodToken
		  m.liRenderBehavior = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR   
		  IF THIS.IsSuccessor
		     * Only the lead does this work.     
		     RETURN m.liRenderBehavior
		  ENDIF
		  m.lcMethodToken = THIS.upperMethodName(m.tcProgram)  
		  IF VARTYPE(THIS.FXs) = "O" AND THIS.FXs.Count > 0
		     * The order of the 
		     * invocation of this method,
		     * which precedes the DODEFAULT()
		     * in each event, 
		     * makes the results available 
		     * for all Successors.
		     FOR EACH m.loFX IN THIS.FXs FOXOBJECT
		         IF VARTYPE(m.loFX) = "O" && contract API is checked in LoadReport and BeforeReport
		                                && but the object could release itself midway through a run
		            THIS.setCurrentDataSession()                                
		            m.loFX.ApplyFX(THIS,m.lcMethodToken, ;
		                       @tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
		                       @tP7, @tP8, @tP9, @tP10, @tP11, @tP12)
		         ENDIF              
		      NEXT
		  ENDIF
		  IF VARTYPE(THIS.GFXs) = "O" AND THIS.GFXs.Count > 0 AND ;
		     THIS.NeedGFXs(m.lcMethodToken,;
		                   m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, ;
		                   m.tP6, m.tP7, m.tP8, m.tP9, m.tP10, ;
		                   m.tP11, m.tP12)
		      FOR EACH m.loFX IN THIS.GFXs FOXOBJECT
		          IF VARTYPE(m.loFX) = "O" && contract API is checked in LoadReport and BeforeReport
		                                   && but the object could release itself midway through a run          
		             THIS.setCurrentDataSession()                                                                   
		             m.liTemp = INT(VAL(TRANSFORM(m.loFX.ApplyFX(THIS, m.lcMethodToken, ;
		                        @tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
		                        @tP7, @tP8, @tP9, @tP10, @tP11, @tP12))))
		             IF m.liTemp > m.liRenderBehavior  && behavior is cumulative
		                m.liRenderBehavior = INT(m.liTemp)
		             ENDIF      
		          ENDIF
		      NEXT
		  ENDIF
		 RETURN m.liRenderBehavior  && this value only affects calls during Render method 
		
		
	ENDPROC

	PROCEDURE UnloadReport
		THIS.sendFX(PROGRAM())  
		THIS.CommandClauses.File = THIS.commandClausesFile 
		THIS.commandClausesFile = NULL
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE UpdateStatus
		THIS.sendFX(PROGRAM())  
		NODEFAULT
		
	ENDPROC

	PROTECTED PROCEDURE uppermethodname		&& Passed a string such as PROGRAM(), returns an upper-case version of the method name with prefixes removed.  Utility method for use  when applying FX and GFX instructions.
		LPARAMETERS m.tcProgram
		LOCAL m.lcProgram
		m.lcProgram = UPPER(TRANSFORM(m.tcProgram))
		RETURN SUBSTR(m.lcProgram,RAT(".",m.lcProgram) + 1)      
	ENDPROC

ENDDEFINE

DEFINE CLASS fxmemberdatascript AS fxabstract OF "_reportlistener.vcx" 		&& Executes script stored in FRX Memberdata, reading it from a cursor in the FRX datasession.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: adjustdynamiccalls		&& Ensures that dynamic method calls are made if there is relevant MemberData script attached to them.
		*m: findparametersstatement		&& Checks FX scripts for a parameter statement as required for ApplyFX() method.
		*m: gatherscripts		&& Sets up script elements at the beginning of a report run.
		*m: processdynamicmethodscript		&& Processes specialized MemberData rows for the current layout control for dynamic methods EvaluateContents and AdjustObjectSize.
		*m: processmemberdatascript		&& Executes MemberData script from the main MemberData row for the current FRX layout element.
		*m: removescriptonfailure_assign
		*m: usememberdata		&& Evaluates whether the current event and the current FRX layout element have MemberData that this class can process and positions the MemberData and Scripting cursors appropriately.
		*p: removescriptonfailure		&& Indicates whether any script failure should remove the  failed script for the balance of the report run. If .F., this script continues to be executed for additional report events and errors are handled silently. Defaults to .T..
		*p: scriptalias		&& The alias of a cursor holding script information during the report run.
	*</DefinedPropArrayMethod>

	PROTECTED scriptalias
	Name = "fxmemberdatascript"
	removescriptonfailure = .T.		&& Indicates whether any script failure should remove the  failed script for the balance of the report run. If .F., this script continues to be executed for additional report events and errors are handled silently. Defaults to .T..
	scriptalias = ("S"+SYS(2015))		&& The alias of a cursor holding script information during the report run.
	_memberdata = <VFPData>
		<memberdata name="applyfx" type="property" display="applyFX" favorites="True"/>
		<memberdata name="gatherscripts" type="method" display="gatherScripts"/>
		<memberdata name="processmemberdatascript" type="method" display="processMemberDataScript"/>
		<memberdata name="processdynamicmethodscript" type="method" display="processDynamicMethodScript"/>
		<memberdata name="usememberdata" type="method" display="useMemberData"/>
		<memberdata name="scriptalias" display="scriptAlias" type="property"/>
		<memberdata name="adjustdynamiccalls" type="method" display="adjustDynamicCalls"/>
		<memberdata name="removescriptonfailure" display="removeScriptOnFailure" type="property" favorites="True"/>
		<memberdata name="findparametersstatement" type="method" display="findParametersStatement"/>
		</VFPData>
	
	PROTECTED PROCEDURE adjustdynamiccalls		&& Ensures that dynamic method calls are made if there is relevant MemberData script attached to them.
		LPARAMETERS m.toListener
		
		* change m.toListener.CallEvaluateContents and 
		* m.toListener.CallAdjustObjectSize if necessary
		
		SET DATASESSION TO (m.toListener.FRXDataSession)
		
		IF INLIST(m.toListener.callEvaluateContents,;
		          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
		          LISTENER_CALLDYNAMICMETHOD_NEVER) 
		
		   SELECT FRX    
		   GO TOP
		   SCAN FOR ObjType = FRX_OBJTYP_FIELD AND Platform = FRX_PLATFORM_WINDOWS
		      IF THIS.useMemberData(RECNO())
		         SELECT (THIS.scriptAlias)
		         IF ATC("EvaluateContents",ExecWhen) > 0 OR ;
		            ATC("EvaluateContents",Execute) > 0 OR ;
		            (NOT EMPTY(UserScript))
		            * UserScript for a Field-type item
		            * has to be EvaluateContents
		            m.toListener.callEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		            EXIT
		         ENDIF
		      ENDIF    
		      SELECT FRX
		   ENDSCAN
		
		ENDIF          
		   
		IF INLIST(m.toListener.callAdjustObjectSize,;
		          LISTENER_CALLDYNAMICMETHOD_CHECK_CODE,;
		          LISTENER_CALLDYNAMICMETHOD_NEVER) 
		
		   SELECT FRX    
		   GO TOP
		   SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND INLIST(ObjType,FRX_OBJTYP_LINE,FRX_OBJTYP_RECTANGLE,FRX_OBJTYP_PICTURE)          
		      IF THIS.useMemberData(RECNO())
		         SELECT (THIS.scriptAlias)
		         IF ATC("AdjustObjectSize",ExecWhen) > 0 OR ;
		            ATC("AdjustObjectSize",Execute) > 0 OR ;
		            (NOT EMPTY(UserScript))
		            * UserScript for a Shape-Picture-type item
		            * has to be AdjustObjectSize
		            m.toListener.callAdjustObjectSize = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		            EXIT
		         ENDIF
		      ENDIF    
		      SELECT FRX
		   ENDSCAN
		
		ENDIF          
		
	ENDPROC

	PROCEDURE applyfx
		LPARAMETERS m.toListener, m.tcMethodToken,;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		TRY
		   IF m.toListener.FRXDataSession > 0
		      SET DATASESSION TO (m.toListener.FRXDataSession)
		   ENDIF      
		
		   LOCAL m.liFRXRecno
		
		   IF m.tcMethodToken == "BEFOREREPORT"
		      THIS.gatherScripts(m.toListener)
		      THIS.adjustDynamicCalls(m.toListener)
		   ENDIF
		   
		   IF m.toListener.FRXDataSession > 0
		      SET DATASESSION TO (m.toListener.FRXDataSession)
		   ENDIF
		
		   m.liFRXRecno = m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
		
		   IF USED("FRX") AND m.liFRXRecno > 0
		      GO (m.liFRXRecno) IN FRX
		   ENDIF
		            
		   IF THIS.useMemberData(m.liFRXRecno)
		      THIS.processMemberDataScript(m.toListener, m.tcMethodToken,;
		               @m.tP1, @m.tP2, @m.tP3, @m.tP4, @m.tP5, @m.tP6, ;
		               @m.tP7, @m.tP8, @m.tP9, @m.tP10, @m.tP11, @m.tP12)
		      IF INLIST(m.tcMethodToken,"EVALUATECONTENTS","ADJUSTOBJECTSIZE")
		         THIS.processDynamicMethodScript(m.toListener,m.tP1, m.tP2)
		      ENDIF  
		   ENDIF    
		   
		   IF m.toListener.FRXDataSession > 0
		      SET DATASESSION TO (m.toListener.FRXDataSession)
		   ENDIF
		   IF USED("FRX")
		      SELECT FRX        
		   ENDIF      
		   SET DATASESSION TO (m.toListener.ListenerDataSession)
		
		CATCH TO err
		
		   #IF OUTPUTCLASS_DEBUGGING 
		       SUSPEND
		   #ENDIF
		   
		ENDTRY            
		
	ENDPROC

	PROTECTED PROCEDURE findparametersstatement		&& Checks FX scripts for a parameter statement as required for ApplyFX() method.
		LPARAMETERS m.tcScript
		LOCAL laLines[1], liLine, lcLine, llFound
		IF VARTYPE(m.tcScript) = "C" AND NOT EMPTY(m.tcScript) 
		   FOR m.liLine = 1 TO ALINES(laLines,CHRTRAN(m.tcScript,CHR(10),CHR(13)),1+4,CHR(13))
		      m.lcLine = ALLTRIM(UPPER(m.laLines[liLine]))
		      DO CASE
		      CASE LEFT(m.lcLine,1) == "*" OR LEFT(m.lcLine,2) == REPLICATE(CHR(38),2)
		         * skip leading comments
		      CASE BETWEEN(ATC("PARAM",m.lcLine),1,2)
		         m.llFound = .T.
		         EXIT
		      OTHERWISE
		         EXIT
		      ENDCASE
		   ENDFOR
		ENDIF   
		
		RETURN m.llFound 
	ENDPROC

	PROTECTED PROCEDURE gatherscripts		&& Sets up script elements at the beginning of a report run.
		LPARAMETERS m.toListener
		LOCAL lcTemp1, lcTemp2, lcTemp3, liSelect
		SET DATASESSION TO (m.toListener.FRXDataSession)
		m.liSelect = SELECT(0)
		SELECT 0
		CREATE CURSOR (THIS.scriptAlias) ;
		   (FRXRecno i, ExecWhen M, Execute M, UserScript M)
		IF USED(m.toListener.MemberDataAlias) AND ;
		   RECCOUNT(m.toListener.MemberDataAlias) > 0
		   SELECT FRX   
		   GO TOP
		   SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND NOT EMPTY(Style)
		      SELECT (m.toListener.MemberDataAlias)
		      LOCATE FOR FRXRecno = RECNO("FRX") AND ;
		         EMPTY(Name) AND Type = FRX_BLDR_MEMBERDATATYPE   
		      m.lcTemp1 = ExecWhen         
		      m.lcTemp2 = Execute         
		      m.lcTemp3 = ""
		      IF NOT EMPTY(m.lcTemp2)
		         IF NOT THIS.findParametersStatement(m.lcTemp2)
		            * add a parameters statement
		            m.lcTemp2 =  "LPARAMETERS toFX, toListener, tcMethodToken,;"+ CHR(13) + CHR(10) + ;
		                         "tP1, tP2, tP3, tP4, tP5, tP6,"+;
		                         "tP7, tP8, tP9, tP10, tP11, tP12" + CHR(13) + CHR(10) + ;
		                         m.lcTemp2  
		         ENDIF            
		      ENDIF        
		      DO CASE
		      CASE INLIST(FRX.ObjType,FRX_OBJTYP_LINE,FRX_OBJTYP_RECTANGLE,FRX_OBJTYP_PICTURE)
		          LOCATE FOR FRXRecno = RECNO("FRX") AND ;
		                     Type = FRX_BLDR_MEMBERDATATYPE   AND ;
		                     Name == FRX_BLDR_NAMESPACE_ADJUSTOBJECTSIZE 
		          IF NOT EOF()           
		             m.lcTemp3 = ;
		               m.toListener.FRXCursor.GenerateAdjustObjectSizeScript("frx",m.toListener.MemberDataAlias,m.toListener.FRXDataSession)
		          ENDIF               
		      CASE FRX.ObjType = FRX_OBJTYP_FIELD 
		          LOCATE FOR FRXRecno = RECNO("FRX") AND ;
		                     Type = FRX_BLDR_MEMBERDATATYPE   AND ;
		                     Name == FRX_BLDR_NAMESPACE_EVALUATECONTENTS
		          IF NOT EOF()           
		             m.lcTemp3 = ;          
		               m.toListener.FRXCursor.GenerateEvaluateContentsScript("frx",m.toListener.MemberDataAlias,m.toListener.FRXDataSession)         
		          ENDIF               
		      OTHERWISE
		          m.lcTemp3 = ""
		      ENDCASE            
		      SET DATASESSION TO (m.toListener.FRXDataSession)      
		      IF NOT EMPTY(m.lcTemp1 + m.lcTemp2 + m.lcTemp3)
		         INSERT INTO (THIS.scriptAlias) ;
		            VALUES (RECNO("FRX"),m.lcTemp1, m.lcTemp2, m.lcTemp3)
		      ENDIF                   
		      SELECT FRX      
		   ENDSCAN
		  
		ENDIF
		
		SELECT (THIS.scriptAlias)
		INDEX ON FrxRecno TAG FrxRecno
		   
		SELECT (m.liSelect)
		
	ENDPROC

	PROTECTED PROCEDURE processdynamicmethodscript		&& Processes specialized MemberData rows for the current layout control for dynamic methods EvaluateContents and AdjustObjectSize.
		LPARAMETERS m.toListener,  m.tnFRXRecno, m.toProps 
		* we are already positioned on the correct MemberData record
		* in the script alias and in the FRXDataSession
		* by the calling method.
		IF (NOT EOF(THIS.scriptAlias))
		   LOCAL lcScript
		   m.lcScript = EVALUATE(THIS.scriptAlias + ".UserScript" ) 
		   IF NOT EMPTY(m.lcScript)
		      TRY
		         EXECSCRIPT(m.lcScript,m.toListener, m.tnFRXRecno, m.toProps )
		      CATCH TO err
		         IF THIS.removeScriptOnFailure AND ;
		            (m.toListener.FRXDataSession > 0)
		             SET DATASESSION TO (m.toListener.FRXDataSession)
		             REPLACE UserScript WITH "" IN (THIS.scriptAlias)
		         ENDIF
		         #IF OUTPUTCLASS_DEBUGGING 
		             SUSPEND
		         #ENDIF
		      FINALLY
		         IF m.toListener.FRXDataSession > 0
		            SET DATASESSION TO (m.toListener.FRXDataSession)
		         ENDIF
		      ENDTRY
		   ENDIF
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE processmemberdatascript		&& Executes MemberData script from the main MemberData row for the current FRX layout element.
		LPARAMETERS m.toListener, m.tcMethodToken,;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		            
		* we are already positioned on the correct MemberData record
		* in the FRXDataSession in the script alias
		* by the calling method.
		IF (NOT EOF(THIS.scriptAlias))
		   LOCAL llExecute, lcExecute, lcExecWhen
		   m.lcExecute = EVALUATE(THIS.scriptAlias + ".Execute")
		   m.lcExecWhen = EVALUATE(THIS.scriptAlias + ".ExecWhen")
		   SET DATASESSION TO (m.toListener.CurrentDataSession)
		   DO CASE
		   CASE EMPTY(m.lcExecute)
		       * nothing to execute
		   CASE EMPTY(m.lcExecWhen)
		       * always execute
		       m.llExecute = .T.
		   CASE UPPER(m.lcExecWhen)== m.tcMethodToken
		        * simple event evaluation
		        * ExecWhen contains an event name
		        * Note that each event, via script,
		        * could potentially change the contents of
		        * ExecWhen to hold another value (the next
		        * event during which this script should be evaluated)
		        m.llExecute = .T.
		   CASE (TYPE(m.lcExecWhen) = "L") AND ;
		        EVALUATE(m.lcExecWhen)
		        * ExecWhen contains a logical expression to be evaluated
		        m.llExecute = .T.
		   CASE ATC("|"+m.tcMethodToken+"|","|" + m.lcExecWhen + "|") > 0
		        * ExecWhen contains a delimited string of events
		        m.llExecute = .T.
		   ENDCASE
		
		   IF m.llExecute 
		      TRY
		         ExecScript(m.lcExecute,;
		                    THIS, m.toListener, m.tcMethodToken,;
		                    @tP1, @tP2, @tP3, @tP4, @tP5, @tP6, ;
		                    @tP7, @tP8, @tP9, @tP10, @tP11, @tP12)
		      CATCH TO err
		         IF THIS.removeScriptOnFailure AND ;
		            (m.toListener.FRXDataSession > 0)
		             SET DATASESSION TO (m.toListener.FRXDataSession)
		             REPLACE Execute WITH "" IN (THIS.scriptAlias)
		         ENDIF      
		         #IF OUTPUTCLASS_DEBUGGING 
		             SUSPEND
		         #ENDIF
		      ENDTRY                    
		   ENDIF
		   IF m.toListener.FRXDataSession > 0
		      SET DATASESSION TO (m.toListener.FRXDataSession)
		   ENDIF      
		ENDIF   
		
		
		
	ENDPROC

	PROCEDURE removescriptonfailure_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.removeScriptOnFailure = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE usememberdata		&& Evaluates whether the current event and the current FRX layout element have MemberData that this class can process and positions the MemberData and Scripting cursors appropriately.
		LPARAMETERS m.tiFRXRecno
		
		LOCAL m.llUseMemberData, m.liSelect
		
		IF (m.tiFRXRecno > 0) 
		   IF USED(THIS.scriptAlias) 
		      m.liSelect = SELECT(0)
		      SELECT (THIS.scriptAlias)
		      m.llUseMemberData = ;
		         SEEK(m.tiFRXRecno,THIS.scriptAlias,"FRXRecno") 
		      SELECT (m.liSelect)    
		   ENDIF
		ENDIF
		
		RETURN m.llUseMemberData
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxresetpagetotal AS fxabstract OF "_reportlistener.vcx" 		&& Provides page count & total in any report. Runs if _ResetPageTotal var exists, also fills vars _ReportPageNo & _ReportPageTotal if available. Results are similar to system variables _PAGENO & _PAGETOTAL, but accurate in reports that reset _PAGENO on band.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: dobeforeband		&& Accumulates page counts into the ResetAlias cursor as the report run progresses.
		*m: dobeforereport		&& Initializes page count activity at the start of a report run.
		*p: dothisrun		&& Holds assessment of whether this object must perform its function during the current report run.
		*p: oldpass		&& Internal processing variable.
		*p: resetalias		&& Alias of cursor used to accumulate page counts for groups.
		*p: resetcount		&& Internal processing variable.
	*</DefinedPropArrayMethod>

	PROTECTED dothisrun,oldpass,resetalias,resetcount
	dothisrun = .F.		&& Holds assessment of whether this object must perform its function during the current report run.
	Name = "fxresetpagetotal"
	oldpass = 0		&& Internal processing variable.
	resetalias = ("GR"+SYS(2015))		&& Alias of cursor used to accumulate page counts for groups.
	resetcount = 0		&& Internal processing variable.
	_memberdata = <VFPData>
		<memberdata name="applyfx" type="property" display="applyFX" favorites="True"/>
		<memberdata name="dothisrun" type="property" display="doThisRun" favorites="True"/>
		<memberdata name="oldpass" type="property" display="oldPass"/>
		<memberdata name="resetcount" type="property" display="resetCount"/>
		<memberdata name="resetalias" type="property" display="resetAlias"/>
		<memberdata name="dobeforeband" type="method" display="doBeforeBand"/>
		<memberdata name="dobeforereport" type="method" display="doBeforeReport"/>
		</VFPData>
	
	PROCEDURE applyfx
		LPARAMETERS m.toListener, m.tcMethodToken, ;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6,   ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		            
		DO CASE
		   CASE m.tcMethodToken == "BEFOREREPORT" AND ;
		        TYPE("_ResetPageTotal") # "U"
		       * we can turn on behavior explicitly
		        toListener.TwoPassProcess = .T.
		        THIS.doThisRun = .T.
		        THIS.doBeforeReport(toListener)
		   CASE m.tcMethodToken == "BEFOREREPORT" AND ;
		       (TYPE("_ResetPageTotal") = "U")
		        THIS.doThisRun = .F.
		   CASE NOT THIS.DoThisRun          
		        * do nothing
		   CASE m.tcMethodToken == "BEFOREBAND"
		        THIS.doBeforeBand(toListener,tP1)          
		   OTHERWISE
		        * do nothing
		ENDCASE
		   
		                        
		
	ENDPROC

	PROTECTED PROCEDURE dobeforeband		&& Accumulates page counts into the ResetAlias cursor as the report run progresses.
		LPARAMETERS m.toListener,m.tnBandCode
		
		LOCAL m.liSession, m.liSelect
		IF m.tnBandCode = 1 && pageheader
		   m.liSession = SET("DATASESSION")
		   SET DATASESSION TO (m.toListener.FRXDataSession )
		   liSelect = SELECT(0)      
		   SELECT (THIS.resetAlias)
		   IF _PAGENO = 1 && user reset occurred
		      IF THIS.oldPass = 0 AND toListener.CurrentPass = 1
		         * we're entering the rendering pass
		         THIS.resetCount = 1
		         THIS.oldPass = 1
		         IF TYPE("_ReportPageTotal") = "N"
		            CALCULATE SUM(ResetPageTotal) TO _ReportPageTotal
		         ENDIF
		      ELSE
		         THIS.resetCount = THIS.resetCount + 1       
		      ENDIF
		      IF m.toListener.CurrentPass = 0 
		         INSERT INTO (THIS.resetAlias) VALUES (THIS.ResetCount, 1)
		      ENDIF          
		   ELSE
		      * we're not starting a set of page numbers,
		      * so we need to keep track of the pages in 
		      * this particular group.
		      IF m.toListener.CurrentPass = 0
		         SEEK THIS.ResetCount 
		         REPLACE ResetPageTotal WITH ResetPageTotal + 1 
		      ENDIF              
		   ENDIF
		   IF m.toListener.CurrentPass = 1
		      * make the current group's page total available
		      * for display/output
		      SEEK THIS.ResetCount 
		      _ResetPageTotal = ResetPageTotal
		      _ReportPageNo = m.toListener.PageNo && don't even worry about whether the var has been declared
		   ENDIF
		   SELECT (m.liSelect)
		   SET DATASESSION TO (m.toListener.CurrentDataSession)
		ENDIF     
		
	ENDPROC

	PROTECTED PROCEDURE dobeforereport		&& Initializes page count activity at the start of a report run.
		LPARAMETERS m.toListener
		LOCAL liSession, liSelect
		liSession = SET("DATASESSION")
		SET DATASESSION TO (m.toListener.FRXDataSession )
		liSelect = SELECT(0)      
		SELECT 0
		CREATE CURSOR (THIS.resetAlias) (ResetsNo i, ResetPageTotal i)
		INDEX ON ResetsNo TAG Resets
		THIS.resetCount = 0
		THIS.oldPass = 0
		_ResetPageTotal = 0
		SELECT (liSelect)
		SET DATASESSION TO (m.toListener.CurrentDataSession)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxtherm AS form 		&& FX interface-conformant object derived from form class, providing user feedback during a report run.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="THERMBACK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="THERMLABEL" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="THERMSHAPE" UniqueID="" Timestamp="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: applyfx		&& Implements required API for an object included in the FXListener FXs collection.
		*m: clearstatus		&& Delegate for ReportListener ClearStatus method.
		*m: dostatus		&& Delegate for ReportListener DoStatus method.
		*m: getparentwindowref		&& Provides a window reference for the top form in which the user feedback window should appear.
		*m: getreportscopedriver		&& Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
		*m: includeseconds_assign
		*m: initstatustext_assign
		*m: persistbetweenruns_assign
		*m: popuserfeedbackglobalsets		&& Handles non-session-specific user feedback SETtings and behavior.
		*m: prepassstatustext_assign
		*m: pushuserfeedbackglobalsets		&& Handles non-session-specific user feedback SETtings and behavior.
		*m: resetuserfeedback		&& Sets user feedback to an initialized state.
		*m: runstatustext_assign
		*m: secondstext_assign
		*m: setthermformcaption		&& Sets the user feedback window title using the ThermFormCaption property.
		*m: setupreport		&& Handles ReportListener's BeforeReport status preparation chores.
		*m: synchstatus		&& Compares driving recno with currrently-saved information to evaluate need to update user feedback.
		*m: synchuserinterface		&& Set up therm form to match latest user specifications.
		*m: thermcaption_assign
		*m: thermformcaption_assign
		*m: thermformheight_assign
		*m: thermformwidth_assign
		*m: thermmargin_assign
		*m: thermprecision_assign
		*m: updatestatus		&& Delegate for ReportListener UpdateStatus method.
		*p: currentrecord		&& Holds the current record relative to the recordtotal in scope for the current report run.
		*p: designateddriver		&& Original selected alias for the report.
		*p: drivingalias		&& Stores the effective driving alias for a report from the point of view of the therm update.
		*p: drivingaliascurrentrecno		&& Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
		*p: escapereference		&& Holds the name of a public variable used to facilitate interrupting a report run.
		*p: frxbandrecno		&& Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
		*p: includeseconds		&& Indicates whether the default user feedback message should include timing data.
		*p: initstatustext		&& Provides the user message shown when user feedback first appears.
		*p: isrunning		&& Indicates whether a report run is in progress.
		*p: onescapecommand		&& Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
		*p: percentdone		&& Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
		*p: persistbetweenruns		&& Allows the therm window to continue to exist (maintaining its end-of-run contents) after the run of the report.  It may potentially show up on the automatic _MWINDOW list if this is turned on.
		*p: prepassstatustext		&& User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
		*p: reportstartrundatetime		&& A datetime value indicating when the last report generation run began.
		*p: reportstoprundatetime		&& A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
		*p: runstatustext		&& Provides a user message shown during the course of a report run.
		*p: secondstext		&& Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
		*p: setescape		&& Saves the state of SET ESCAPE previous to the report run, for later restoration.
		*p: setnotifycursor		&& Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
		*p: successorsys2024		&& Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
		*p: thermcaption		&& Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
		*p: thermformcaption		&& Holds the value used to set the title of the user feedback form.
		*p: thermformheight		&& Holds the height of the user feedback form, in pixels.
		*p: thermformwidth		&& Holds the width of the user feedback form, in pixels.
		*p: thermmargin		&& Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
		*p: thermprecision		&& The number of places (precision) to use for evaluating and (by default) showing the percentage done.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED currentrecord,designateddriver,drivingalias,drivingaliascurrentrecno,escapereference,frxbandrecno,isrunning,onescapecommand,percentdone,setescape,setnotifycursor,successorsys2024
	AllowOutput = .F.
	AlwaysOnTop = .T.
	AutoCenter = .T.
	BorderStyle = 2
	Caption = "ThermForm"
	ControlBox = .F.
	currentrecord = (0)		&& Holds the current record relative to the recordtotal in scope for the current report run.
	designateddriver = ("")		&& Original selected alias for the report.
	DoCreate = .T.
	drivingalias = ("")		&& Stores the effective driving alias for a report from the point of view of the therm update.
	drivingaliascurrentrecno = (0)		&& Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
	escapereference = ("")		&& Holds the name of a public variable used to facilitate interrupting a report run.
	frxbandrecno = (0)		&& Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
	HalfHeightCaption = .T.
	Height = 40
	includeseconds = .T.		&& Indicates whether the default user feedback message should include timing data.
	initstatustext = ("")		&& Provides the user message shown when user feedback first appears.
	isrunning = .F.		&& Indicates whether a report run is in progress.
	MaxButton = .F.
	MinButton = .F.
	Name = "fxtherm"
	onescapecommand = ("")		&& Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
	percentdone = (0)		&& Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
	persistbetweenruns = .F.		&& Allows the therm window to continue to exist (maintaining its end-of-run contents) after the run of the report.  It may potentially show up on the automatic _MWINDOW list if this is turned on.
	prepassstatustext = ("")		&& User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
	reportstartrundatetime = (DTOT({}))		&& A datetime value indicating when the last report generation run began.
	reportstoprundatetime = (DTOT({}))		&& A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
	runstatustext = ("secs")		&& Provides a user message shown during the course of a report run.
	secondstext = ("")		&& Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
	setescape = .F.		&& Saves the state of SET ESCAPE previous to the report run, for later restoration.
	setnotifycursor = .F.		&& Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
	successorsys2024 = ("N")		&& Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
	thermcaption = <fb2p_value>[m.cMessage+ " "+ TRANSFORM(THIS.PercentDone,"999"+IIF(THIS.ThermPrecision=0,"","."+REPL("9",THIS.ThermPrecision))) + "%" + IIF(NOT THIS.IncludeSeconds, "" , " "+TRANSFORM(IIF(THIS.IsRunning,DATETIME(), THIS.ReportStopRunDateTime)-THIS.ReportStartRunDateTime)+" " + THIS.SecondsText)]</fb2p_value>		&& Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
	thermformcaption = ("")		&& Holds the value used to set the title of the user feedback form.
	thermformheight = (40)		&& Holds the height of the user feedback form, in pixels.
	thermformwidth = (356)		&& Holds the width of the user feedback form, in pixels.
	thermmargin = (5)		&& Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
	thermprecision = (2)		&& The number of places (precision) to use for evaluating and (by default) showing the percentage done.
	Width = 356
	_memberdata = <VFPData>
		<memberdata name="applyfx" display="applyFX" type="method"/>
		<memberdata name="percentdone" type="property" display="percentDone" favorites="False" />
		<memberdata name="currentrecord" type="property" display="currentRecord" favorites="False" />
		<memberdata name="designateddriver" type="property" display="designatedDriver" favorites="False" />
		<memberdata name="drivingaliascurrentrecno" type="property" display="drivingAliasCurrentRecno" favorites="False" />
		<memberdata name="escapereference" type="property" display="escapeReference" favorites="False" />
		<memberdata name="frxbandrecno" type="property" display="frxBandRecno" favorites="False" />
		<memberdata name="getparentwindowref" type="method" display="getParentWindowRef" favorites="False" />
		<memberdata name="getreportscopedriver" type="method" display="getReportScopeDriver" favorites="False"/>
		<memberdata name="includeseconds" type="property" display="includeSeconds" favorites="True" />
		<memberdata name="initstatustext" type="property" display="initStatusText" favorites="True" />
		<memberdata name="onescapecommand" type="property" display="onEscapeCommand" favorites="False" />
		<memberdata name="prepassstatustext" type="property" display="prepassStatusText" favorites="True" />
		<memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" />
		<memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" />
		<memberdata name="resetuserfeedback" type="method" display="resetUserFeedback" favorites="False" />
		<memberdata name="runstatustext" type="property" display="runStatusText" favorites="True" />
		<memberdata name="secondstext" type="property" display="secondsText" favorites="True" />
		<memberdata name="setescape" type="property" display="setEscape" favorites="False" />
		<memberdata name="setnotifycursor" type="property" display="setNotifyCursor" favorites="False" />
		<memberdata name="setthermformcaption" type="method" display="setThermformCaption" favorites="False" />
		<memberdata name="thermcaption" type="property" display="thermCaption" favorites="True" />
		<memberdata name="thermform" type="property" display="thermForm" favorites="False" />
		<memberdata name="thermformcaption" type="property" display="thermFormCaption" favorites="True" />
		<memberdata name="thermformheight" type="property" display="thermFormHeight" favorites="True" />
		<memberdata name="thermformwidth" type="property" display="thermFormWidth" favorites="True" />
		<memberdata name="thermprecision" type="property" display="thermPrecision" favorites="True" />
		<memberdata name="thermmargin" type="property" display="thermMargin" favorites="True" />
		<memberdata name="synchstatus" type="method" display="synchStatus" favorites="False" />
		<memberdata name="successorsys2024" type="property" display="successorSys2024" favorites="False" />
		<memberdata name="dostatus" type="method" display="doStatus" favorites="True" />
		<memberdata name="clearstatus" type="method" display="clearStatus" favorites="True" />
		<memberdata name="updatestatus" type="method" display="updateStatus" favorites="True" />
		<memberdata name="pushuserfeedbackglobalsets" display="pushUserFeedbackGlobalSets" type="method"/>
		<memberdata name="popuserfeedbackglobalsets" display="popUserFeedbackGlobalSets" type="method"/>
		<memberdata name="synchuserinterface" display="synchUserInterface" type="method"/>
		<memberdata name="setupreport" type="method" display="setupReport"/>
		<memberdata name="drivingalias" type="method" display="drivingAlias"/>
		<memberdata name="persistbetweenruns" display="persistBetweenRuns" type="property" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'THERMBACK' AS shape WITH ;
		BackStyle = 0, ;
		DefHeight = , ;
		DefLeft = , ;
		DefTop = , ;
		DefWidth = , ;
		Height = 30, ;
		Left = 0, ;
		Name = "THERMBACK", ;
		Top = 5, ;
		Visible = .T., ;
		Width = 276
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'THERMLABEL' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "", ;
		DefTop = , ;
		ForeColor = 0,0,0, ;
		Left = 8, ;
		Name = "THERMLABEL", ;
		Top = ( (THISFORM.Height - THIS.Height) /2), ;
		Visible = .T., ;
		Width = 2
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'THERMSHAPE' AS shape WITH ;
		BackColor = (THISFORM.BackColor), ;
		BorderStyle = 0, ;
		DefHeight = , ;
		DefLeft = , ;
		DefTop = , ;
		DrawMode = 14, ;
		FillColor = 178,180,191, ;
		FillStyle = 0, ;
		Height = (THISFORM.ThermBack.Height -2), ;
		Left = (THISFORM.ThermBack.Left + 1), ;
		Name = "THERMSHAPE", ;
		Top = (THISFORM.ThermBack.Top + 1), ;
		Visible = .T., ;
		Width = 0
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE applyfx		&& Implements required API for an object included in the FXListener FXs collection.
		LPARAMETERS m.toListener, m.tcMethodToken,;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		
		LOCAL m.liSession            
		IF VARTYPE(m.toListener) = "O" && AND ;
		   (NOT m.toListener.IsSuccessor)
		   DO CASE
		   CASE m.tcMethodToken == "DOSTATUS"
		      THIS.DoStatus(m.toListener, m.tP1)
		   CASE m.tcMethodToken == "UPDATESTATUS"
		      THIS.UpdateStatus(m.toListener)    
		   CASE m.tcMethodToken == "CLEARSTATUS"
		      THIS.ClearStatus(m.toListener)
		   CASE m.tcMethodToken == "AFTERBAND"
		       THIS.synchStatus(m.toListener,m.tP1,m.tP2)
		   CASE m.tcMethodToken == "AFTERREPORT"
		      IF SYS(2024) # "Y" 
		         IF THIS.isRunning AND TYPE("m.toListener.CommandClauses.RecordTotal") = "N"
		            THIS.CurrentRecord = m.toListener.CommandClauses.RecordTotal
		         ENDIF   
		         THIS.UpdateStatus(m.toListener) 
		      ENDIF
		      THIS.designatedDriver = ""
		      THIS.drivingAlias = ""
		      THIS.successorSys2024 = "N"
		      THIS.Visible = .F.
		      THIS.ReportStopRunDateTime = DATETIME()
		      THIS.popUserFeedbackGlobalSets()
		      THIS.ClearStatus(m.toListener)       
		   CASE m.tcMethodToken == "BEFOREBAND"
		      IF THIS.successorSys2024 = "Y" AND ;
		         m.toListener.CurrentPass = LISTENER_FULLPASS
		         * user cancelled during the prepass,
		         * we need to re-cancel.
		         m.liSession = SET("DATASESSION")
		         SET DATASESSION TO (m.toListener.CurrentDataSession)
		         IF USED(THIS.designatedDriver)
		            GO BOTTOM IN (THIS.designatedDriver)
		         ENDIF   
		         SET DATASESSION TO (m.liSession)
		      ENDIF   
		      THIS.synchStatus(m.toListener,m.tP1,m.tP2)
		  CASE m.tcMethodToken == "BEFOREREPORT"
		      THIS.setupReport(m.toListener)
		   CASE m.tcMethodToken == "CANCELREPORT"
		      IF THIS.isRunning AND ;
		         (m.toListener.QuietMode OR ;
		         (m.toListener.pageLimit > 0 AND m.toListener.PageNo > m.toListener.pageLimit) OR ;
		          (NOT m.toListener.AllowModalMessages) OR ;
		          m.toListener.DoMessage(OUTPUTCLASS_REPORT_CANCELQUERY_LOC,;
		                                 MB_ICONQUESTION+MB_YESNO) =  IDYES )
		
		          m.toListener.cancelRequested = .T.
		
		          IF m.toListener.isSuccessor AND NOT EMPTY(THIS.designatedDriver)
		             * NB: FX should ordinarily not be used in a successor,
		             * but this won't hurt and will take care of the exception
		             THIS.successorSys2024 = "Y"
		             m.liSession = SET("DATASESSION")
		             SET DATASESSION TO (m.toListener.CurrentDataSession)
		             IF USED(THIS.designatedDriver)
		                GO BOTTOM IN (THIS.designatedDriver)
		             ENDIF   
		             SET DATASESSION TO (m.liSession)
		          ENDIF
		          IF SYS(2024) = "Y"  OR m.toListener.IsSuccessor
		             THIS.Visible = .F.
		             IF (m.toListener.pageLimit = -1 OR m.toListener.PageNo <= m.toListener.pageLimit)
		                m.toListener.DoMessage(OUTPUTCLASS_REPORT_INCOMPLETE_LOC, ;
		                               MB_ICONEXCLAMATION)
		             ENDIF                        
		          ENDIF
		          RETURN .F.
		       ELSE
		          RETURN .T. && did not handle, use default behavior          
		       ENDIF          
		   CASE m.tcMethodToken == "LOADREPORT"
		      THIS.ResetUserFeedback(.T.)
		      m.toListener.AddProperty("reportStartRunDatetime",THIS.reportStartRunDatetime)
		      IF NOT (m.toListener.QuietMode OR ;
		           (TYPE("m.toListener.CommandClauses.NoDialog") = "L" AND ;
		           m.toListener.CommandClauses.NoDialog) )
		           THIS.DoStatus(m.toListener,THIS.initStatusText) 
		          * NB: a user can call LoadReport manually,
		          * hence the need for a TYPE() check here.
		      ENDIF   
		      THIS.pushUserFeedbackGlobalSets(m.toListener) 
		   CASE m.tcMethodToken == "UNLOADREPORT"
		      THIS.ReportStopRunDateTime = DATETIME()
		      m.toListener.AddProperty("reportStopRunDatetime",THIS.reportStopRunDatetime)      
		      THIS.IsRunning = .F.
		      THIS.ClearStatus()       
		      IF NOT THIS.persistBetweenRuns 
		         SET DATASESSION TO (m.toListener.ListenerDataSession)      
		         THIS.Release()
		      ENDIF            
		   ENDCASE
		   SET DATASESSION TO (m.toListener.ListenerDataSession)
		ENDIF            
		
		
	ENDPROC

	PROCEDURE clearstatus		&& Delegate for ReportListener ClearStatus method.
		LPARAMETERS m.toListener
		IF THIS.Visible 
		   THIS.Visible = .F.
		ENDIF   
		
	ENDPROC

	PROCEDURE dostatus		&& Delegate for ReportListener DoStatus method.
		LPARAMETERS m.toListener, m.cMessage
		LOCAL m.loParentForm, m.lcCaption, m.lcParentFormName
		
		IF (VARTYPE(m.toListener) # "O") OR (NOT (m.toListener.QuietMode OR ;
		   (THIS.isRunning AND m.toListener.CommandClauses.NoDialog)))
		
		   IF EMPTY(m.cMessage) OR ISNULL(m.cMessage)
		      m.cMessage = ""
		   ENDIF
		
		   m.lcCaption = EVALUATE(THIS.ThermCaption)
		
		   WITH THIS
		      
		      IF THIS.isRunning
		         THIS.Closable = .F.
		         THIS.Movable = .F.
		      ENDIF
		     .ThermShape.Width = MAX( (((THIS.PercentDone/100) * .ThermBack.Width)-2) ,0)      
		     IF NOT .Visible
		        
		        m.loParentForm = THIS.GetParentWindowRef()
		        
		        DO CASE
		        CASE VARTYPE(m.loParentForm) # "O" AND (NOT _SCREEN.Visible)
		           m.lcParentFormName = "MACDESKTOP"
		        CASE VARTYPE(m.loParentForm) # "O"
		           m.lcParentFormName = "SCREEN"              
		        CASE (NOT m.loParentForm.Visible) AND ;
		           (m.loParentForm.DeskTop OR NOT EMPTY(m.loParentForm.MacDesktop) OR ;
		           m.loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
		           * in many cases, 
		           * they've probably made a programming error,
		           * the parent should be visible according to
		           * the requirements of REPORT FORM ... IN WINDOW
		           * if it's a WINDOW clause they
		           * have no need to show it, might not be an error
		           * Either way, they should see the therm
		           * to know that the report is progressing                
		           m.lcParentFormName = "MACDESKTOP"
		        CASE (NOT m.loParentForm.Visible) 
		           * same comment as above
		           m.lcParentFormName = "SCREEN"
		        OTHERWISE
		           m.lcParentFormName = m.loParentForm.Name
		        ENDCASE
		           
		        SHOW WINDOW (.Name) IN WINDOW (m.lcParentFormName) 
		        .AlwaysOnTop = .T.
		        .AutoCenter = .T.
		        .Visible = .T.
		     ENDIF
		     .ThermLabel.Visible = .F.
		     .ThermLabel.Caption = m.lcCaption     
		     .ThermLabel.Left = (.Width - .ThermLabel.Width) /2 && doesn't work until after visibility of form
		     .ThermLabel.Visible = .T.     
		      
		   ENDWITH
		   
		   m.loParentForm = NULL
		
		  
		ENDIF   
		
		
		
	ENDPROC

	PROTECTED PROCEDURE getparentwindowref		&& Provides a window reference for the top form in which the user feedback window should appear.
		LOCAL m.loForm, m.loTopForm, m.lcInWindow
		
		* first top form in the list
		* will be the current top form.
		
		ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
		       INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)
		
		m.loTopForm = NULL
		
		IF TYPE("THIS.CommandClauses.InWindow") = "C"
		   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.InWindow))
		ENDIF   
		
		IF EMPTY(lcInWindow) AND TYPE("THIS.CommandClauses.Window") = "C"
		   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.Window))
		ENDIF   
		
		
		IF NOT EMPTY(m.lcInWindow) 
		
		     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
		        IF m.loForm.ShowWindow = 2  AND ;
		           UPPER(m.loForm.Name) == m.lcInWindow
		           m.loTopForm = m.loForm
		           EXIT
		        ENDIF
		     ENDFOR
		     
		ENDIF
		
		DO CASE
		
		CASE VARTYPE(m.loTopForm) = "O"
		    * already found
		CASE _SCREEN.FormCount = 0 OR ;
		     (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		     _SCREEN.ActiveForm.ShowWindow = 0 )     && ShowWindow In Screen
				     
		     m.loTopForm = _SCREEN
		
		CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		      _SCREEN.ActiveForm.ShowWindow = 2 )    && ShowWindow As Top Form
		
		     m.loTopForm = _SCREEN.ActiveForm
				     
		OTHERWISE 
				                                       
		     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
		        IF m.loForm.ShowWindow = 2 
		           m.loTopForm = m.loForm
		           EXIT
		        ENDIF
		     ENDFOR
				     
		     IF VARTYPE(m.loTopForm) # "O"
		        m.loTopForm = _SCREEN
		     ENDIF
				          
		ENDCASE
		
		IF VARTYPE(m.loTopForm) # "O" OR ;
		   EMPTY(m.loTopForm.Name)
		   m.loTopForm = NULL
		ENDIF
		
		RETURN m.loTopForm     
		
	ENDPROC

	PROTECTED PROCEDURE getreportscopedriver		&& Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
		LPARAMETERS m.toListener
		
		LOCAL m.liSelect, m.lcAlias, ;
		      m.liSkips,  laSkips[1]
		
		IF m.toListener.FRXDataSession > 0
		   SET DATASESSION TO (m.toListener.FRXDataSession)
		ELSE
		   RETURN .F.
		ENDIF   
		
		THIS.designatedDriver = THIS.drivingAlias
		* used later if we have to cancel report as
		* a Successor
		
		IF USED("frx")
		
		   m.liSelect = SELECT(0)
		   m.lcAlias = ""
		
		   SELECT FRX
		   * first look for any target alias that
		   * is the same as the driver
		   
		   SCAN ALL FOR ObjType = FRX_OBJTYP_BAND AND ;
		           Objcode = FRX_OBJCOD_DETAIL AND ;
		           TYPE(Expr) = "C" AND ;
		           NOT (EMPTY(Expr)  OR DELETED())
		       m.lcAlias = ALLTRIM(Expr)
		       SET DATASESSION TO (m.toListener.CurrentDataSession)   
		       m.lcAlias = UPPER(EVALUATE(m.lcAlias)) 
		       SET DATASESSION TO (m.toListener.FRXDataSession)              
		       IF m.lcAlias == UPPER(THIS.drivingAlias)
		          EXIT
		       ENDIF
		   ENDSCAN
		
		   IF m.lcAlias == UPPER(THIS.drivingAlias)
		
		      SELECT (m.liSelect)
		      * if the driver is also a target alias,
		      * don't touch.
		      * otherwise:
		   ELSE 
		
		      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		              Objcode = FRX_OBJCOD_DETAIL AND ;
		              Platform = FRX_PLATFORM_WINDOWS AND ;
		              NOT (EMPTY(Expr) OR DELETED())
		      IF FOUND()
		         * use the first detail band, on the theory
		         * that people are going to put pre-processing 
		         * calculations before other bands, 
		         * so an early band has the best chance to be
		         * the right driver.
		         m.lcAlias = ALLTRIM(Expr)
		         SET DATASESSION TO (m.toListener.CurrentDataSession)
		         THIS.drivingAlias = UPPER(EVALUATE(m.lcAlias))
		         SET DATASESSION TO (m.toListener.FrxDataSession)
		         SELECT (m.liSelect)
		
		      ELSE   
		   
		         * adjust the driver based on any
		         * one to many relationships we can find.
		  
		         SELECT (m.liSelect)
		         SET DATASESSION TO (m.toListener.CurrentDataSession)
		
		         m.lcAlias = THIS.drivingAlias
		
		         m.liSelect = SELECT(0)
		
		         DO WHILE NOT EMPTY(m.lcAlias)
		
		            SELECT (m.lcAlias)
		            m.liSkips = ALINES(laSkips,SET("SKIP"),",")
		            IF m.liSkips = 0 OR EMPTY(laSkips[1])
		               THIS.drivingAlias = m.lcAlias
		               m.lcAlias = ""
		            ELSE
		               m.lcAlias = laSkips[1]
		               * it doesn't really matter how many lines there
		               * are in the array; this is not going to be perfect
		               * but we can't predict which child 
		               * has the most records.
		            ENDIF
		         ENDDO
		
		         SELECT (m.liSelect)
		   
		      ENDIF   
		    
		   ENDIF  
		ELSE
		   RETURN .F.    
		ENDIF
		
	ENDPROC

	PROCEDURE includeseconds_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.includeSeconds = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE Init
		THIS.Name = "X"+SYS(2015)
		WITH THIS
		     .InitStatusText = OUTPUTCLASS_INITSTATUS_LOC
		     .PrepassStatusText = OUTPUTCLASS_PREPSTATUS_LOC
		     .RunStatusText =  OUTPUTCLASS_RUNSTATUS_LOC
		     .SecondsText = OUTPUTCLASS_TIME_SECONDS_LOC
		     .thermCaption = OUTPUTCLASS_THERMCAPTION_LOC     
		     .resetUserFeedback()
		ENDWITH
		
		
		
	ENDPROC

	PROCEDURE initstatustext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.initStatusText = m.vNewVal
		ENDIF   
	ENDPROC

	PROCEDURE Load
		
		            
	ENDPROC

	PROCEDURE persistbetweenruns_assign
		LPARAMETERS vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.persistBetweenRuns = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE popuserfeedbackglobalsets		&& Handles non-session-specific user feedback SETtings and behavior.
		IF (NOT INLIST(_VFP.StartMode,2,3,5))
		   LOCAL m.lcRef
		   m.lcRef = THIS.EscapeReference
		   IF (NOT EMPTY(m.lcRef)) AND ;
		       TYPE(m.lcRef) = "O"
		      * push occurred earlier
		      STORE NULL TO (m.lcRef)
		      RELEASE &lcRef.
		      THIS.escapeReference = ""
		      m.lcRef = THIS.OnEscapeCommand
		      ON ESCAPE &lcRef
		      POP KEY
		      IF THIS.SetNotifyCursor
		         SET NOTIFY CURSOR ON
		      ENDIF   
		      IF THIS.SetEscape 
		         SET ESCAPE OFF
		      ENDIF   
		   ENDIF   
		ENDIF   
		   
		   
	ENDPROC

	PROCEDURE prepassstatustext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.prepassStatusText = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE pushuserfeedbackglobalsets		&& Handles non-session-specific user feedback SETtings and behavior.
		LPARAMETERS m.toListener
		IF (NOT INLIST(_VFP.StartMode,2,3,5))
		   PUSH KEY CLEAR
		   LOCAL m.lcRef
		   SET MESSAGE TO ""
		   THIS.SetNotifyCursor = (SET("Notify",2) = "ON")
		   IF THIS.SetNotifyCursor
		      SET NOTIFY CURSOR OFF
		   ENDIF   
		   THIS.OnEscapeCommand = ON("ESCAPE")   
		   m.lcRef = SYS(2015)   
		   PUBLIC &lcRef.   
		   STORE m.toListener TO (m.lcRef)
		   ON ESCAPE &lcRef..CancelReport()      
		   THIS.EscapeReference = m.lcRef   
		   THIS.SetEscape = (SET("ESCAPE")="OFF") 
		   IF THIS.SetEscape
		      SET ESCAPE ON
		   ENDIF   
		ENDIF   
		   
		   
	ENDPROC

	PROTECTED PROCEDURE resetuserfeedback		&& Sets user feedback to an initialized state.
		LPARAMETERS m.tlResetTimes
		
		THIS.CurrentRecord = 0
		THIS.PercentDone = 0
		IF m.tlResetTimes
		   THIS.ReportStartRunDateTime= DATETIME()
		   THIS.ReportStopRunDateTime= DTOT({})
		   THIS.thermFormCaption = ""
		   THIS.synchUserInterface()
		ENDIF
		
	ENDPROC

	PROCEDURE runstatustext_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		THIS.runStatusText = m.vNewVal
		
	ENDPROC

	PROCEDURE secondstext_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		THIS.secondsText = m.vNewVal
		
	ENDPROC

	PROTECTED PROCEDURE setthermformcaption		&& Sets the user feedback window title using the ThermFormCaption property.
		LPARAMETERS tcCommandClausesFile, tcPrintJobName
		IF EMPTY(THIS.ThermFormCaption)
		   IF VARTYPE(tcCommandClausesFile) = "C"
		      LOCAL m.cName
		      IF EMPTY( tcPrintJobName) OR VARTYPE( tcPrintJobName) # "C"
		         m.cName = PROPER(JUSTFNAME(tcCommandClausesFile))
		      ELSE
		         m.cName =  tcPrintJobName
		      ENDIF   
		      THIS.thermFormCaption = ;
		         m.cName + ": " + OUTPUTCLASS_CANCEL_INSTRUCTIONS_LOC
		   ELSE
		      THIS.thermFormCaption = ""
		   ENDIF
		ENDIF
		THIS.Caption = THIS.thermFormCaption
		
		
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE setupreport		&& Handles ReportListener's BeforeReport status preparation chores.
		LPARAMETERS m.toListener
		
		LOCAL m.llFRXAvailable, m.lcAlias
		
		THIS.isRunning = .T.
		
		WITH m.toListener
		   SET DATASESSION TO (.CurrentDataSession)
		   THIS.DrivingAlias = UPPER(ALIAS())
		   IF .FRXDataSession > 0
		      SET DATASESSION TO (.FRXDataSession)   
		   ENDIF
		   m.llFRXAvailable = THIS.getReportScopeDriver(m.toListener) 
		   
		   IF m.llFRXAvailable
		      THIS.setThermformCaption(m.toListener.CommandClauses.File, m.toListener.PrintJobName)
		
		      IF TYPE("m.toListener.CommandClauses.Summary") # "L"
		         ADDPROPERTY(.CommandClauses,"Summary",.F.)
		      ENDIF   
		      IF TYPE("m.toListener.CommandClauses.RecordTotal") # "N"
		         ADDPROPERTY(.CommandClauses,"RecordTotal",0)
		      ENDIF   
		      IF TYPE("m.toListener.CommandClauses.NoDialog") # "L"
		        ADDPROPERTY(.CommandClauses,"NoDialog",.F.)
		      ENDIF      
		      SET DATASESSION TO (.FRXDataSession)   
		      THIS.FRXBandRecno = 0
		      SELECT FRX
		   
		      IF .CommandClauses.Summary
		         * don't use groups unless
		         * we're forced to by Summary.
		         * Group usage will not work if
		         * there's a group on .T. or some
		         * other nonsensical expression that
		         * doesn't change.
		    
		         LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		             Objcode = FRX_OBJCOD_GROUPHEADER AND ;
		             Platform = FRX_PLATFORM_WINDOWS AND ;
		             NOT DELETED()
		         DO WHILE NOT EOF()
		            * find the innermost group
		            THIS.FRXBandRecno = RECNO()
		            CONTINUE
		         ENDDO        
		      
		         IF THIS.frxBandRecno = 0
		            * no groups in a Summary report
		            * doesn't make a lot of sense, but
		            * can happen.
		             LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		                Platform = FRX_PLATFORM_WINDOWS AND ;
		                Objcode = FRX_OBJCOD_PAGEHEADER AND ;
		                NOT DELETED()
		             IF NOT EOF()
		                THIS.FRXBandRecno = RECNO()
		             ENDIF     
		         ENDIF
		   
		      ENDIF
		
		      IF THIS.FRXBandRecno = 0
		         * not a Summary report.
		         * look for the appropriate detail
		         * using the report driver
		
		         LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		                    Objcode = FRX_OBJCOD_DETAIL AND ;
		                    Platform = FRX_PLATFORM_WINDOWS AND ;
		                    TYPE(Expr) = "C" AND ; 
		                    NOT (EMPTY(Expr) OR DELETED())
		         DO WHILE NOT EOF()
		             m.lcAlias = ALLTRIM(Expr)
		             SET DATASESSION TO (.CurrentDataSession)             
		             m.lcAlias = UPPER(EVALUATE(m.lcAlias))
		             SET DATASESSION TO (.FRXDataSession)                          
		             IF m.lcAlias == UPPER(THIS.DrivingAlias)             
		                THIS.FRXBandRecno = RECNO()
		             ENDIF   
		             CONTINUE && try not to use the first detail band
		         ENDDO
		   
		      ENDIF   
		   
		      IF THIS.frxBandRecno = 0
		         * couldn't match up a band with
		         * the known driver
		         LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		              Objcode = FRX_OBJCOD_DETAIL AND ;
		              Platform = FRX_PLATFORM_WINDOWS AND ;
		              EMPTY(Expr) AND NOT DELETED()
		         IF NOT EOF()
		            THIS.FRXBandRecno = RECNO()      
		         ELSE
		            IF THIS.FRXBandRecno = 0 
		               LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		                    Platform = FRX_PLATFORM_WINDOWS AND ;
		                    Objcode = FRX_OBJCOD_DETAIL AND ;
		                    NOT DELETED()
		               IF NOT EOF()
		                  THIS.FRXBandRecno = RECNO()
		               ENDIF  
		            ENDIF               
		         ENDIF        
		      ENDIF   
		   ENDIF
		   THIS.DrivingAliasCurrentRecno = 0
		   SET DATASESSION TO (.ListenerDataSession)   
		   
		ENDWITH   
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE synchstatus		&& Compares driving recno with currrently-saved information to evaluate need to update user feedback.
		LPARAMETERS m.toListener, m.nBandObjCode, m.nFRXRecNo
		
		IF THIS.isRunning AND ;
		   THIS.frxBandRecno = m.nFRXRecNo
		   WITH m.toListener
		      TRY
		         SET DATASESSION TO (.CurrentDataSession)
		         IF THIS.drivingAliasCurrentRecno  # RECNO(THIS.drivingAlias)
		            THIS.currentRecord = THIS.CurrentRecord + 1
		            THIS.drivingAliasCurrentRecno = RECNO(THIS.drivingAlias)
		         ENDIF   
		         IF THIS.currentRecord >= .CommandClauses.RecordTotal
		            IF .CurrentPass = 0 AND .TwoPassProcess
		               THIS.resetUserFeedback() 
		            ELSE
		               THIS.currentRecord = .CommandClauses.RecordTotal
		            ENDIF
		         ENDIF
		         THIS.updateStatus(m.toListener)
		       CATCH TO err
		          #IF OUTPUTCLASS_DEBUGGING 
		              SUSPEND
		          #ENDIF
		       ENDTRY         
		       SET DATASESSION TO (.ListenerDataSession)       
		   ENDWITH      
		ENDIF  
		
		
	ENDPROC

	PROTECTED PROCEDURE synchuserinterface		&& Set up therm form to match latest user specifications.
		
		#define CTLCOLOR_MSGBOX             0
		#define CTLCOLOR_EDIT               1
		#define CTLCOLOR_LISTBOX            2
		#define CTLCOLOR_BTN                3
		#define CTLCOLOR_DLG                4
		#define CTLCOLOR_SCROLLBAR          5
		#define CTLCOLOR_STATIC             6
		#define CTLCOLOR_MAX                7
		#define COLOR_SCROLLBAR             0
		#define COLOR_BACKGROUND            1
		#define COLOR_ACTIVECAPTION         2
		#define COLOR_INACTIVECAPTION       3
		#define COLOR_MENU                  4
		#define COLOR_WINDOW                5
		#define COLOR_WINDOWFRAME           6
		#define COLOR_MENUTEXT              7
		#define COLOR_WINDOWTEXT            8
		#define COLOR_CAPTIONTEXT           9
		#define COLOR_ACTIVEBORDER         10
		#define COLOR_INACTIVEBORDER       11
		#define COLOR_APPWORKSPACE         12
		#define COLOR_HIGHLIGHT            13
		#define COLOR_HIGHLIGHTTEXT        14
		#define COLOR_BTNFACE              15
		#define COLOR_BTNSHADOW            16
		#define COLOR_GRAYTEXT             17
		#define COLOR_BTNTEXT              18
		#define COLOR_INACTIVECAPTIONTEXT  19
		#define COLOR_BTNHIGHLIGHT         20
		#if("4" $ OS())
		#define COLOR_3DDKSHADOW           21
		#define COLOR_3DLIGHT              22
		#define COLOR_INFOTEXT             23
		#define COLOR_INFOBK               24
		#define COLOR_DESKTOP           COLOR_BACKGROUND
		#define COLOR_3DFACE            COLOR_BTNFACE
		#define COLOR_3DSHADOW          COLOR_BTNSHADOW
		#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
		#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
		#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
		#endif
		
		
		DECLARE INTEGER GetSysColor IN Win32API INTEGER  
		
		LOCAL m.liThermTop, m.liThermLeft, m.liThermWidth, m.liThermHeight
		
		WITH THIS
		     .Height = .ThermFormHeight     
		     .Width = .ThermFormWidth
		     .ControlBox = .F.
		     .Closable = .T.
		     .Movable = .T.     
		     m.liThermHeight = .Height - (.ThermMargin* 2)
		     m.liThermWidth =  .Width - (.ThermMargin*2)
		     .SetThermFormCaption()    
		     m.liThermTop =  .ThermMargin
		     m.liThermLeft = .ThermMargin  
		ENDWITH
		
		WITH THIS.ThermBack
		   .Top = m.liThermTop     
		   .Left = m.liThermLeft
		   .Height = m.liThermHeight
		   .Width = m.liThermWidth
		ENDWITH
		  
		WITH THIS.ThermLabel
		   .Top = (.Parent.Height - .Height) /2
		   .ForeColor = GetSysColor( COLOR_MENUTEXT )
		ENDWITH
		  
		WITH THIS.ThermShape
		   .Top = m.liThermTop +1    
		   .Left = m.liThermLeft+1
		   .Height = m.liThermHeight -2
		   .Width = 0
		   .BackColor = .Parent.BackColor
		   .FillColor = GetSysColor(COLOR_HIGHLIGHT)
		ENDWITH
		  
		  
		
		
	ENDPROC

	PROCEDURE thermcaption_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   LOCAL m.lcType, m.cMessage
		   m.cMessage = ""
		   TRY 
		    m.lcType = VARTYPE(EVALUATE(m.vNewVal))
		      IF m.lcType = "C"
		        THIS.thermCaption = m.vNewVal
		    ENDIF
		   CATCH 
		   ENDTRY     
		
		ENDIF   
		
	ENDPROC

	PROCEDURE thermformcaption_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.thermFormCaption = m.vNewVal
		   THIS.setThermFormCaption()
		ENDIF   
		
	ENDPROC

	PROCEDURE thermformheight_assign
		LPARAMETERS m.vNewVal
		IF  VARTYPE(m.vNewVal) = "N" AND ;
		   BETWEEN(m.vNewVal,30,SYSMETRIC(SYSMETRIC_SCREENHEIGHT )-30)  AND ;
		   INT(m.vNewVal) # THIS.thermFormHeight
		   THIS.thermFormHeight = INT(m.vNewVal)
		   IF THIS.thermMargin > THIS.thermFormHeight/4
		      THIS.thermMargin = THIS.thermFormHeight/4
		   ENDIF   
		   THIS.synchUserInterface() 
		ENDIF   
		
	ENDPROC

	PROCEDURE thermformwidth_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" AND ;
		   BETWEEN(m.vNewVal,100,SYSMETRIC( SYSMETRIC_SCREENWIDTH  )-100) AND ;
		   INT(m.vNewVal) # THIS.ThermFormWidth 
		   THIS.thermFormWidth = INT(m.vNewVal)
		   IF THIS.thermMargin > THIS.thermFormWidth/4
		      THIS.thermMargin = THIS.thermFormWidth/4
		   ENDIF   
		   THIS.synchUserInterface() 
		ENDIF   
		
	ENDPROC

	PROCEDURE thermmargin_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" AND ;
		   BETWEEN(m.vNewVal,1,MIN(THIS.ThermFormHeight/4,THIS.ThermFormWidth/4)) AND ;
		   INT(m.vNewVal) # THIS.thermMargin
		   THIS.thermMargin = INT(m.vNewVal)
		   THIS.synchUserInterface() 
		ENDIF   
		
	ENDPROC

	PROCEDURE thermprecision_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" 
		   THIS.thermPrecision  = ABS(INT(m.vNewVal))
		ENDIF 
	ENDPROC

	PROCEDURE updatestatus		&& Delegate for ReportListener UpdateStatus method.
		LPARAMETERS m.toListener
		IF VARTYPE(m.toListener) = "O" AND THIS.isRunning
		   LOCAL m.liRecTotal, m.lnNewPercent, m.llShow
		   m.liRecTotal = m.toListener.CommandClauses.RecordTotal 
		   IF m.liRecTotal > 0 
		      m.lnNewPercent = ROUND(THIS.CurrentRecord/m.liRecTotal,(THIS.ThermPrecision + 2) ) * 100
		      IF (THIS.PercentDone # m.lnNewPercent)
		         THIS.PercentDone = m.lnNewPercent
		         m.llShow = .T.
		         #IF OUTPUTCLASS_DEBUGGING 
		             ? THIS.PercentDone, THIS.CurrentRecord, m.liRecTotal, m.toListener.PageTotal
		             ? REPL(OUTPUTCLASS_STATUSCHAR_PCT_DONE,INT(THIS.PercentDone/100* OUTPUTCLASS_ONE_HUNDRED_PCT_MARK))+ ;
		               REPL(OUTPUTCLASS_STATUSCHAR_PCT_NOT_DONE,MAX(FLOOR(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK - ;
		                                                            (OUTPUTCLASS_ONE_HUNDRED_PCT_MARK *THIS.PercentDone/100)),0) ) 
		         #ENDIF                
		      ENDIF
		   ELSE
		      m.llShow = .T.         
		   ENDIF   
		   IF m.llShow
		      THIS.DoStatus(m.toListener, ;
		                    IIF(m.toListener.CurrentPass = LISTENER_PREPASS  AND m.toListener.TwoPassProcess,;
		                     THIS.PrepassStatusText, ;
		                     THIS.RunStatusText) )
		   ENDIF                     
		ENDIF   
		
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gfxexample AS fxabstract OF "_reportlistener.vcx" 		&& Example GFX class to show technique the object can use to remove itself from FXListener's collection at the conclusion of a report run. This technique is critical to safe use of FX and GFX objects that do not closely monitor their use of datasessions. 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: showdatasessionissue_assign
		*p: showdatasessionissue		&& Toggles demonstration of proper datasession handling in this example GFX class.
	*</DefinedPropArrayMethod>

	Name = "gfxexample"
	showdatasessionissue = .T.		&& Toggles demonstration of proper datasession handling in this example GFX class.
	_memberdata = <VFPData>
		<memberdata name="applyfx" type="property" display="applyFX" favorites="True"/>
		<memberdata name="showdatasessionissue" display="showDataSessionIssue" favorites="True" type="property"/>
		</VFPData>
	
	PROCEDURE applyfx
		LPARAMETERS m.toListener, m.tcMethodToken,;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6,;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		            
		
		IF m.tcMethodToken == "BEFOREREPORT" AND ;
		   THIS.showDataSessionIssue AND ;
		   (m.toListener.CurrentDataSession = m.toListener.CommandClauses.StartDataSession)
		   MESSAGEBOX("This report does not use a private data session," + CHR(13) + ;
		              "so you won't see the problem.")                          
		ENDIF              
		IF m.tcMethodToken == "BEFOREBAND" 
		   SET DATASESSION TO (m.toListener.CurrentDataSession)
		   m.toListener.doStatus("working here... ")
		   IF THIS.showDataSessionIssue 
		      * no switch back here.
		*!*	   ELSE
		*!*	      SET DATASESSION TO (m.toListener.ListenerDataSession)
		   ENDIF      
		ENDIF               
		
		IF (NOT THIS.showDataSessionIssue) AND ;
		   m.tcMethodToken == "AFTERREPORT"
		   * if the following is not included,
		   * a "stuck" datasession results unless
		   * some additional object later in 
		   * the collection did the switch back
		   m.toListener.removeCollectionMember(THIS.Name,.T.)
		   RELEASE THIS
		ENDIF
		
	ENDPROC

	PROCEDURE showdatasessionissue_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		  THIS.showDataSessionIssue = m.vNewVal
		ENDIF  
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gfxnorender AS fxabstract OF "_reportlistener.vcx" 
	*<ClassComment>
		*Conditionally eliminates default rendering behavior for report layout controls by evaluating a ReportListener-referencing expression specified in MemberData.
	*</ClassComment>
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: omitrendering		&& Evaluates Rendering requirements, returning True or False, in both current and frx data sessions.
		*p: listener		&& Holds a ReportListener reference during applyFX processing for use in evaluating "Render When" conditions.
		*p: norenderdataalias		&& Alias of private cursor for gfxNoRender subset of memberdata.
	*</DefinedPropArrayMethod>

	PROTECTED listener,norenderdataalias
	Height = 17
	listener = (.NULL.)		&& Holds a ReportListener reference during applyFX processing for use in evaluating "Render When" conditions.
	Name = "gfxnorender"
	norenderdataalias = ("GNR"+SYS(2015))		&& Alias of private cursor for gfxNoRender subset of memberdata.
	Width = 98
	_memberdata = <VFPData>
		<memberdata name="applyfx" type="property" display="applyFX" favorites="True"/>
		<memberdata name="omitrendering" display="omitRendering" type="method"/>
		<memberdata name="norenderdataalias" display="noRenderDataAlias" type="property"/>
		</VFPData>
	
	PROCEDURE applyfx
		LPARAMETERS m.toListener, m.tcMethodToken, ;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		
		LOCAL m.liSession, m.liSelect, m.liFRXRecno, m.liReturn, ;
		      m.llNoRender, m.llSwap, m.lcConditions, m.err AS Exception 
		m.liReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR  
		
		DO CASE
		CASE m.tcMethodToken == "RENDER" AND ;
		   NOT ISNULL(m.toListener.FFCGraphics)
		   TRY
		      m.liSession = SET("DATASESSION")
		      SET DATASESSION TO m.toListener.FRXDataSession
		      m.liSelect = SELECT(0)
		      IF USED(THIS.noRenderDataAlias) 
		         SELECT (THIS.noRenderDataAlias)
		         m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
		         LOCATE FOR FrxRecno = m.liFRXRecno AND PreProcess 
		         * there won't be any if it's a Sedna-type build, unless it was a built-in report
		         * to another app and we couldn't make the swap.                    
		         IF FOUND()
		            m.llNoRender = THIS.omitRendering(m.toListener, ALLTRIM(Execute))
		         ENDIF                          
		         IF NOT (m.llNoRender)
		            * rendering override for this instance in the report
		            LOCATE FOR FrxRecno = m.liFRXRecno AND NOT PreProcess
		            IF FOUND()        
		               m.llNoRender = THIS.omitRendering(m.toListener, ALLTRIM(Execute))
		            ENDIF   
		         ENDIF           
		         IF m.llNoRender
		            m.liReturn = OUTPUTFX_BASERENDER_NORENDER
		         ENDIF
		      ENDIF
		   CATCH TO m.err 
		      #IF OUTPUTCLASS_DEBUGGING
		         m.toListener.DoMessage(m.err.Message)
		      #ELSE
		         * could expose this error but won't,
		         * we'll just swallow it
		         * code line here for suspend capabilities
		         m.liReturn = m.liReturn
		      #ENDIF
		   FINALLY
		       SELECT (m.liSelect)
		       SET DATASESSION TO (m.liSession)
		   ENDTRY            
		CASE m.tcMethodToken == "LOADREPORT" AND ;
		    VERSION(4) > "09.00.0000.3504" AND ;
		   (NOT m.toListener.CommandClauses.IsDesignerLoaded) AND ;
		   FILE(m.toListener.CommandClauses.File)
		   
		    * We can't do this in a design session because
		    * of the Designer's lock on the original file.
		    * We also can't do this in SP1 or below, 
		    * or when the report is built in to a different app.
		    * (Note the use of FILE() rather than SYS(2000) here, 
		    * it's okay if it's not on disk.)
		    * We will still handle this at render time if we can't make the swap;
		    * (we just won't get the performance benefits of preprocess-deletion)
		   TRY
		      m.liSession = SET("DATASESSION")
		      SET DATASESSION TO m.toListener.FRXDataSession
		      m.liSelect = SELECT(0)
		      * nb: this is before memberdata is normally available.
		      SELECT 0
		        
		      USE (m.toListener.CommandClausesFile) ;
		          AGAIN NOUPDATE SHARED ALIAS  FRX
		      m.toListener.FRXCursor.UnpackFrxMemberData("FRX",;
		                   m.toListener.MemberDataAlias, m.toListener.FRXDataSession)
		      USE IN FRX
		      IF USED(m.toListener.MemberDataAlias) 
		         SELECT (m.toListener.MemberDataAlias)
		         LOCATE FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
		                    Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                    ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER AND ;
		                    NOT EMPTY(Execute)  
		         IF FOUND()           
		            * check to see if we are already working on 
		            * a temporary report.
		            IF (NOT m.toListener.isFRXSwapCopyPresent())
		               * must perform the swap, storing
		               * CommandClauses.File for later use
		               m.llSwap = .T.               
		               m.toListener.prepareFRXSwapCopy(,,.T.)
		            ENDIF   
		            * After creating swap report or ascertaining that
		            * we are already working with a temp report, 
		            * delete the items in that report as required.
		            * BUT FIRST make sure the swap went through as planned.
		            IF m.llSwap AND ;
		               (EMPTY(m.toListener.CommandClauses.File) OR ;
		                EMPTY(SYS(2000,m.toListener.CommandClauses.File)))
		               m.llSwap = .F.
		               m.toListener.CommandClauses.File = ;
		                 m.toListener.commandClausesFile
		            ENDIF
		            * now if we're positive we're in the right place
		            * and that we have possible memberdata content
		            * we can start deleting records out of the swap copy:
		            IF USED(m.toListener.MemberDataAlias) AND ;
		               NOT (m.toListener.CommandClauses.File == ;
		                    m.toListener.commandClausesFile)
		               USE (m.toListener.CommandClauses.File) IN 0 ;
		                      AGAIN EXCLU ALIAS FRX 
		                      * can't do a NOUP to do the delete.
		                      * since we're in a private copy,  
		                      * we switch this to an
		                      * EXCLU and PACK although it doesn't appear
		                      * to be necessary for the engine's POV.
		                      * This means users of this copy of the 
		                      * FRX don't have to pay attention to
		                      * whether some records are potentially-deleted.
		
		               SELECT (m.toListener.MemberDataAlias)                
		               SCAN FOR Type = FRX_BLDR_MEMBERDATATYPE AND ;
		                        Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                        ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER AND ;
		                        NOT EMPTY(Execute)  
		                  m.liRecno = FRXRecno                    
		                  m.llNoRender = THIS.omitRendering(m.toListener,ALLTRIM(Execute))
		                  IF m.llNoRender
		                     SELECT FRX
		                     DELETE ALL FOR RECNO() = m.liRecno
		                     SELECT (m.toListener.MemberDataAlias)
		                  ENDIF   
		               ENDSCAN
		               SELECT FRX
		               PACK
		            ENDIF   
		         ENDIF
		      ENDIF
		   CATCH TO m.err 
		      * revert the swap if we did one
		      * being careful not to remove the original report
		      #IF OUTPUTCLASS_DEBUGGING
		      m.toListener.DoMessage(OUTPUTFX_CONDITIONALRENDERING_UNAVAILABLE_LOC + ;
		                             CHR(13) + m.err.Message )
		      #ENDIF
		      IF m.llSwap 
		          m.toListener.removeFRXSwapCopy(,OUTPUTCLASS_DEBUGGING )           
		      ENDIF   
		   FINALLY
		       IF USED("FRX")
		          USE IN FRX
		       ENDIF
		       * we must close this early version of the
		       * memberdata cursor -- later its frxrecno values
		       * will be re-created correctly
		       IF USED(m.toListener.MemberDataAlias)
		          USE IN (m.toListener.MemberDataAlias)
		       ENDIF
		       SELECT (m.liSelect)
		       SET DATASESSION TO (m.liSession)
		   ENDTRY            
		CASE m.tcMethodToken == "BEFOREREPORT"
		   m.liSession = SET("DATASESSION")
		   SET Datasession TO m.toListener.FRXDataSession  
		   IF USED(m.toListener.MemberDataAlias)
		      m.liSelect = SELECT(0)
		      m.lcConditions = "(ExecWhen == '" + FRX_BLDR_ADVPROP_PREPROCESS_NORENDER + "' OR " + ;
		                       " ExecWhen == '" + FRX_BLDR_ADVPROP_INSTANCE_NORENDER +"' ) "
		      SELECT FrxRecno,ExecWhen,Execute, ;
		            IIF(ExecWhen == FRX_BLDR_ADVPROP_PREPROCESS_NORENDER, .T., .F.) AS PreProcess ;
		         FROM (m.toListener.MemberDataAlias) ;
		         INTO CURSOR (THIS.noRenderDataAlias) ;         
		         WHERE Type = FRX_BLDR_MEMBERDATATYPE AND ;
		               Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		               (NOT EMPTY(Execute)) AND &lcConditions.           
		      IF RECCOUNT(THIS.noRenderDataAlias) = 0
		         USE IN (THIS.noRenderDataAlias)
		      ELSE
		         SELECT (THIS.noRenderDataAlias)
		         INDEX ON FrxRecno TAG FrxRecno
		      ENDIF                    
		      SELECT (m.liSelect)
		   ENDIF   
		   SET Datasession TO (m.liSession)
		CASE m.tcMethodToken == "UNLOADREPORT"
		   * if swap was performed, and if the temporary
		   * report is still "in place" 
		   * as commandClausesFile 
		   * get rid of temporary report 
		   * if there is one and if it still exists
		   * and return CommandClauses.File to its original value
		   * it should not matter what order objects handle this
		   IF m.toListener.isFRXSwapCopyPresent()
		      m.liSession = SET("DATASESSION")
		      SET DATASESSION TO m.toListener.FRXDataSession
		      IF USED(THIS.noRenderDataAlias)
		         USE IN (THIS.noRenderDataAlias)
		      ENDIF
		      m.liSelect = SELECT(0)
		      IF USED("FRX")
		         m.llSwap = .T.
		         SELECT FRX
		         USE
		      ENDIF              
		      m.toListener.removeFRXSwapCopy(,OUTPUTCLASS_DEBUGGING )           
		      IF m.llSwap
		        SELECT 0
		        USE (m.toListener.CommandClauses.File) ALIAS FRX NOUPDATE
		      ENDIF
		      SELECT (m.liSelect)
		      SET DATASESSION TO (m.liSession)
		   ENDIF           
		ENDCASE   
		
		RETURN  m.liReturn
	ENDPROC

	PROCEDURE Destroy
		THIS.listener = NULL
	ENDPROC

	PROTECTED PROCEDURE omitrendering		&& Evaluates Rendering requirements, returning True or False, in both current and frx data sessions.
		LPARAMETERS m.toListener, m.tcExpr
		LOCAL m.llNoRender, m.liSession
		IF VARTYPE(m.tcExpr) = "C"
		   m.liSession = SET("DATASESSION")
		   THIS.listener = m.toListener               
		   SET DATASESSION TO m.toListener.CurrentDataSession
		   IF TYPE(m.tcExpr) = "L"
		      m.llNoRender = EVALUATE(m.tcExpr)
		      SET DATASESSION TO m.toListener.FRXDataSession               
		   ELSE
		      SET DATASESSION TO m.toListener.FRXDataSession
		      IF TYPE(m.tcExpr) = "L"
		         m.llNoRender = EVALUATE(m.tcExpr)                 
		     ENDIF
		   ENDIF
		   THIS.listener = NULL
		   SET DATASESSION TO (m.liSession)
		ENDIF            
		RETURN m.llNoRender
	ENDPROC

ENDDEFINE

DEFINE CLASS gfxoutputclip AS custom 		&& Provides copy-to-image file for designated page regions during a report run, so you can export the rendered regions for embedding in output targets. Alternative to xmlDisplayListener.copyImageFilesToExternalFileLocation handling custom-rendered content.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: applyfx		&& Implementation of required method for the FX interface.
		*m: cleanup		&& Cleanup code for each report run specific to this object.
		*m: forceon_assign
		*m: gdipluslibmodule_assign
		*m: gdipluslib_assign
		*m: getcurrentclipfilename		&& Provides generated output image copy filename for the current copy action.
		*m: getimageext		&& Derive file extension from current mimetype value.
		*m: listenersupportssaveclip		&& Evaluates whether the object can handle image copy processing in the current ReportListener output mode and during the current ReportListener event.
		*m: margin_assign
		*m: mimetype_assign
		*m: outputpageclip		&& Bindable procedure to save image copy files at the correct moment (the OutputPage event) during a paged report run.
		*m: saveimageclips		&& Performs image copy procedures on the page regions requested for one or more pages.
		*m: setup		&& Setup code for each report run specific to this object.
		*m: setupimageclip		&& Saves a row to the aImageCopies array during rendering procedures when a page region is marked for an image copy, for later use in image copy procedures.
		*p: forceon		&& Require this object to turn itself on for a report run, even if it does not see any objects tagged for its attention with the Memberdata values it expects.
		*p: gdipluslib		&& Class library to use for instantation of point, rect, and other helper objects.
		*p: gdipluslibmodule		&& Optional APP or EXE file (module) from which to instantiate helper objects in the gdiPlusLib class library.
		*p: iimageinstanceindex		&& Index of the current image copy file.
		*p: lonthisrun		&& Logical value determining whether the object should take action during this run.
		*p: margin		&& Integer value of frame margin to add to both width and height when determining the clip coordinates for the current portion of the page to be copied.
		*p: mimetype		&& Mimetype to use for image-copy files the object creates.
		*p: oimagedest		&& Helper object for image-copy process.
		*p: oimagesrc		&& Helper object for image-copy process.
		*p: opoint		&& Helper object for image-copy process.
		*p: oprivategraphics		&& Helper object for image-copy process.
		*p: orect		&& Helper object for image-copy process.
		*p: simagefullpath		&& Full path to which image copy files are saved, determined by ReportListener's externalFileLocation and targetFileName properties if they exist and are in use.
		*p: simagepath		&& Potentially relative path to which image copy files are saved, determined by ReportListener's externalFileLocation property (which may be relative) if it exists and is in use.
		*p: snamespace		&& Reporting Memberdata namespace for which the object will look when determining whether a layout control's page region has been  explicitly tagged for copy to an image file.
		*a: aimagecopies[1,6]		&& Collection of values about each image copy the object makes during a report run (each row contains PageNo, output filename, and Left,Top,Width,Height values for the copy).
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED aimagecopies,iimageinstanceindex,lonthisrun,oimagedest,oimagesrc,opoint,oprivategraphics,orect,simagefullpath,simagepath,snamespace
	forceon = .F.		&& Require this object to turn itself on for a report run, even if it does not see any objects tagged for its attention with the Memberdata values it expects.
	gdipluslib = ("")		&& Class library to use for instantation of point, rect, and other helper objects.
	gdipluslibmodule = ("")		&& Optional APP or EXE file (module) from which to instantiate helper objects in the gdiPlusLib class library.
	iimageinstanceindex = 0		&& Index of the current image copy file.
	lonthisrun = .F.		&& Logical value determining whether the object should take action during this run.
	margin = 10		&& Integer value of frame margin to add to both width and height when determining the clip coordinates for the current portion of the page to be copied.
	mimetype = ("image/png")		&& Mimetype to use for image-copy files the object creates.
	Name = "gfxoutputclip"
	oimagedest = NULL		&& Helper object for image-copy process.
	oimagesrc = NULL		&& Helper object for image-copy process.
	opoint = NULL		&& Helper object for image-copy process.
	oprivategraphics = NULL		&& Helper object for image-copy process.
	orect = NULL		&& Helper object for image-copy process.
	simagefullpath = ("")		&& Full path to which image copy files are saved, determined by ReportListener's externalFileLocation and targetFileName properties if they exist and are in use.
	simagepath = ("")		&& Potentially relative path to which image copy files are saved, determined by ReportListener's externalFileLocation property (which may be relative) if it exists and is in use.
	snamespace = ("")		&& Reporting Memberdata namespace for which the object will look when determining whether a layout control's page region has been  explicitly tagged for copy to an image file.
	_memberdata = <VFPData>
		<memberdata name="forceon" type="property" display="forceOn" favorites="True"/>
		<memberdata name="gdipluslib" type="property" display="gdiPlusLib" favorites="True"/>
		<memberdata name="iimageinstanceimage" type="property" display="iImageInstanceimage"/>
		<memberdata name="mimetype" type="property" display="mimetype" favorites="True"/>
		<memberdata name="aimagecopies" type="property" display="aImageCopies"/>
		<memberdata name="iimageinstanceindex" type="property" display="iImageInstanceIndex"/>
		<memberdata name="margin" type="property" display="margin" favorites="True"/>
		<memberdata name="lonthisrun" type="property" display="lOnThisRun"/>
		<memberdata name="lthisruninpagedmode" type="property" display="lThisRunInPagedMode"/>
		<memberdata name="oimagedest" type="property" display="oImageDest"/>
		<memberdata name="oimagesrc" type="property" display="oImageSrc"/>
		<memberdata name="opoint" type="property" display="oPoint"/>
		<memberdata name="oprivategraphics" type="property" display="oPrivateGraphics"/>
		<memberdata name="orect" type="property" display="oRect"/>
		<memberdata name="snamespace" type="property" display="sNamespace"/>
		<memberdata name="applyfx" type="method" display="applyFX"/>
		<memberdata name="getcurrentclipfilename" type="method" display="getCurrentClipFileName" favorites="True"/>
		<memberdata name="outputpageclip" type="method" display="outputPageClip" favorites="True"/>
		<memberdata name="setupimageclip" type="method" display="setupImageClip" favorites="True"/>
		<memberdata name="saveimageclips" type="method" display="saveImageClips"/>
		<memberdata name="getimageext" type="method" display="getImageExt"/>
		<memberdata name="setup" type="method" display="setup"/>
		<memberdata name="gdipluslibmodule" type="property" display="gdiPlusLibModule" favorites="True"/>
		<memberdata name="listenersupportssaveclip" type="method" display="listenerSupportsSaveClip"/>
		<memberdata name="cleanup" type="method" display="cleanup"/>
		<memberdata name="simagepath" type="property" display="sImagePath"/>
		<memberdata name="simagefullpath" type="property" display="sImageFullPath"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE applyfx		&& Implementation of required method for the FX interface.
		LPARAMETERS m.toListener, m.tcMethodToken, ;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		         
		LOCAL m.liSession, m.liSelect, m.liFRXRecno, m.lvReturn, ;
		      m.liDriver, m.err AS EXCEPTION
		
		m.lvReturn = .T.
		
		IF THIS.listenerSupportsSaveClip(m.toListener)
		
		   TRY
		
		      m.liSession = SET("DATASESSION")
		
		      IF m.toListener.FRXDATASESSION > -1
		
		         SET DATASESSION TO m.toListener.FRXDATASESSION
		         m.liSelect = SELECT(0)
		
		         DO CASE
		
		         CASE m.tcMethodToken == "BEFOREREPORT"
		
		            THIS.aImageCopies = .F.
		            THIS.iImageInstanceIndex = 0
		            IF USED (m.toListener.MemberDataAlias)
		               SELECT (m.toListener.MemberDataAlias)
		               LOCATE FOR ;
		                  NAME == THIS.sNameSpace 
		               THIS.lOnThisRun = (FOUND() OR THIS.forceOn)
		               IF THIS.lOnThisRun
		                  THIS.Setup(m.toListener)
		               ENDIF   
		            ENDIF
		
		         CASE m.tcMethodToken == "RENDER" AND ;
		              NOT ISNULL(m.toListener.FFCGraphics) AND ;
		              THIS.lOnThisRun
		 
		            m.lvReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR
		            m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
		            GO m.liFRXRecNo IN FRX
		            SELECT (m.toListener.MemberDataAlias)
		            LOCATE FOR FRXRecno = m.liFRXRecno AND ;
		                   NAME == THIS.sNameSpace
		            IF FOUND()
		               THIS.setupImageClip(m.toListener, ;
		                   m.tP2, m.tP3, m.tP4, m.tP5, @m.tP7, ;
		                   (FRX.ObjType = FRX_OBJTYP_PICTURE))
		            ENDIF    
		
		         CASE m.tcMethodToken == "AFTERREPORT"
		
		            IF THIS.listenerSupportsSaveClip(m.toListener,.F.)
		               THIS.saveImageClips(m.toListener)
		            ENDIF
		            THIS.Cleanup(m.toListener)
		
		         ENDCASE
		
		     ELSE
		         THIS.lOnThisRun = .F.   
		     ENDIF   
		         
		  CATCH TO m.err
		
		     #IF OUTPUTCLASS_DEBUGGING
		         SUSPEND
		     #ENDIF
		
		  FINALLY
		
		     IF VARTYPE(m.err) = "O" 
		        *&* this object cleans up after an error --
		        *&* doesn't provide a choice, although it could.
		        THIS.Cleanup(m.toListener)
		     ENDIF
		
		     IF m.toListener.FRXDataSession # -1
		        SET DATASESSION TO m.toListener.FrxDataSession
		        SELECT (m.liSelect)
		        SET DATASESSION TO (m.liSession)
		     ENDIF   
		
		  ENDTRY
		
		ENDIF
		
		RETURN  m.lvReturn
		
		      
		         
		         
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleanup code for each report run specific to this object.
		LPARAMETERS m.toListener
		
		IF THIS.lOnThisRun AND VARTYPE(m.toListener) = "O" AND ;
		   THIS.listenerSupportsSaveClip(m.toListener,.T.)
		   UNBINDEVENTS(THIS)
		ENDIF
		
		THIS.lOnThisRun = .F.
		
		STORE "" TO ;
		      THIS.sImagePath, ;
		      THIS.sImageFullPath
		
		STORE NULL TO  ;
		      THIS.oImageSrc, ;
		      THIS.oImageDest, THIS.oPrivateGraphics, ;
		      THIS.oPoint, THIS.oRect 
	ENDPROC

	PROCEDURE Destroy
		THIS.Cleanup()
	ENDPROC

	PROCEDURE forceon_assign
		LPARAMETERS m.tvValue
		IF VARTYPE(m.tvValue) = "L"
		   THIS.forceOn = m.tvValue
		ENDIF
		
	ENDPROC

	PROCEDURE gdipluslibmodule_assign
		LPARAMETERS m.tvValue
		IF VARTYPE(m.tvValue) = "C"
		   m.tvValue = ALLTRIM(m.tvValue)
		   IF(EMPTY(m.tvValue) OR (NOT EMPTY(SYS(2000,(m.tvValue)))))
		       THIS.gdiPlusLibModule = m.tvValue
		   ENDIF
		ENDIF   
		
		
	ENDPROC

	PROCEDURE gdipluslib_assign
		LPARAMETERS m.tvValue
		IF VARTYPE(m.tvValue) = "C"
		   m.tvValue = ALLTRIM(m.tvValue)
		   DO CASE
		   CASE(EMPTY(m.tvValue) OR FILE(m.tvValue))
		       THIS.gdiPlusLib = m.tvValue
		   CASE FILE(FORCEEXT(m.tvValue,"VCX"))
		       THIS.gdiPlusLib = FORCEEXT(m.tvValue,"VCX")
		   ENDCASE    
		ENDIF   
		
	ENDPROC

	PROCEDURE getcurrentclipfilename		&& Provides generated output image copy filename for the current copy action.
		IF THIS.iImageInstanceIndex = 0 OR ;
		   EMPTY(THIS.aImageCopies[THIS.iImageInstanceIndex,2])
		   RETURN ""
		ELSE
		   RETURN THIS.aImageCopies[THIS.iImageInstanceIndex,2]
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE getimageext		&& Derive file extension from current mimetype value.
		*&* override as you see fit.
		RETURN SUBSTR(THIS.mimetype,RAT("/",THIS.mimetype) + 1)
	ENDPROC

	PROCEDURE Init
		       #DEFINE THISNAMESPACE         "Spacefold.LSN.gfxOutputClip"
		       
		       *&* An appropriate namespace must be defined for cases in which
		       *&* you want to use this gfx on its own and share it
		       *&* by placing it in the GFXs collection.
		       *&* You can set the outputclip behavior to occur only 
		       *&* after all other rendering is through, and
		       *&* also ensure availability of the clip files and
		       *&* clip file names to all Successors, by using this 
		       *&* approach.  Simply add memberdata to the layout elements
		       *&* you want clipped (no other memberdata property besides 
		       *&* the name attribute is needed by this object).
		       *&* The layout elements to be clipped
		       *&* can be of any report control type.
		       
		       *&* However, this object can be invoked explicitly, even
		       *&* when shared, by a custom rendering extension
		       *&* using "ForceOn" behavior, and without
		       *&* any memberdata instructions in the report.
		       *&* It is also constructed to be 
		       *&* well-behaved if multiple custom rendering extensions
		       *&* keeps private copies and invoke them explicitly
		       *&* rather than putting a shared copy in the GFXs collection.
		       
		       *&* Now that you have read this note <g>
		       *&* and if you want this object to work on its
		       *&* own in the GFXs collection as a shared worker object,
		       *&* you can :
		       *&* override the Init in your subclass with 
		       *&* an appropriate namespace value 
		       *&* OR         
		       *&* uncomment the IF/ENDIF below and set 
		       *&* an appropriate default property definition
		       *&* in your subclass.     
		
		       *&* IF VARTYPE(THIS.sNamespace) # "C" OR EMPTY(THIS.sNamespace)
		          THIS.sNameSpace = THISNAMESPACE 
		       *&* ENDIF 
		
	ENDPROC

	PROTECTED PROCEDURE listenersupportssaveclip		&& Evaluates whether the object can handle image copy processing in the current ReportListener output mode and during the current ReportListener event.
		LPARAMETERS m.toListener,m.tlActInPagedMode
		
		DO CASE
		CASE m.toListener.ListenerType = LISTENER_TYPE_DEF
		   RETURN .F.
		CASE PCOUNT() < 2
		   RETURN m.toListener.ListenerType # LISTENER_TYPE_DEF
		CASE tlActInPagedMode
		   RETURN INLIST(m.toListener.ListenerType,LISTENER_TYPE_PRN,LISTENER_TYPE_PAGED)
		OTHERWISE
		   RETURN INLIST(m.toListener.ListenerType,LISTENER_TYPE_PRV,LISTENER_TYPE_ALLPGS)
		ENDCASE    
		
	ENDPROC

	PROCEDURE margin_assign
		LPARAMETERS m.tvNewVal
		IF VARTYPE(m.tvNewVal) = "N"
		   THIS.margin = INT(m.tvNewVal)
		ENDIF   
		
	ENDPROC

	PROCEDURE mimetype_assign
		LPARAMETERS m.tvValue
		
		IF VARTYPE(m.tvValue) = "C" AND "/" $ m.tvValue
		   THIS.mimetype = ALLTRIM(m.tvValue)
		ENDIF
		
	ENDPROC

	PROCEDURE outputpageclip		&& Bindable procedure to save image copy files at the correct moment (the OutputPage event) during a paged report run.
		LPARAMETERS m.nPageNo, ;
		            m.eDevice, ;
		            m.nDeviceType, ;
		            m.nleft, m.nTop, m.nWidth, m.nHeight, ;
		            m.nClipLeft,m.nClipTop, m.nClipWidth, m.nClipHeight
		
		  LOCAL m.laBind[1]
		  AEVENTS(m.laBind,0)
		  THIS.saveImageClips(laBind[1],m.nPageNo)
		
		
	ENDPROC

	PROTECTED PROCEDURE saveimageclips		&& Performs image copy procedures on the page regions requested for one or more pages.
		LPARAMETERS m.toListener, m.tiPage
		
		IF NOT THIS.listenerSupportsSaveClip(m.toListener)
		   RETURN .F.
		ENDIF
		   
		LOCAL m.lcTempfile, m.liPageIndex, m.liImageIndex, m.liStartPage, m.liEndPage
		
		m.lcTempFile = FORCEEXT(FORCEPATH(SYS(2015),SYS(2023)),"EMF") && always goes to temp dir
		
		THIS.oPoint.Set(0,0)
		
		IF THIS.listenerSupportsSaveClip(m.toListener, .T.) 
		   m.liStartPage = VAL(TRANSFORM(m.tiPage))
		   m.liEndPage  = m.liStartPage
		   UNBINDEVENTS(THIS)
		   * avoid recursion the easy way.
		ELSE
		   m.liStartPage = 1
		   m.liEndPage = m.toListener.PageTotal
		ENDIF
		
		IF EMPTY(THIS.sImageFullPath)
		   * should just happen the first time through
		   * in paged mode
		   IF PEMSTATUS(m.toListener,"targetFileName",5) AND ;
		      NOT EMPTY(JUSTPATH(m.toListener.targetFileName))
		      THIS.sImageFullPath = FULLPATH(THIS.sImagePath,m.toListener.targetFileName)
		   ELSE
		      THIS.sImageFullPath = FULLPATH(THIS.sImagePath)
		   ENDIF   
		ENDIF   
		
		
		m.liImageIndex = ASCAN(THIS.aImageCopies,m.liStartPage,1,THIS.iImageInstanceIndex,1,8)
		
		IF m.liImageIndex > 0
		   FOR m.liPageIndex = m.liStartPage TO m.liEndPage
		       m.toListener.OutputPage(m.liPageIndex,m.lcTempFile,100)
		       THIS.oImageSrc.CreateFromFile(m.lcTempFile)
		       DO WHILE m.liImageIndex <= THIS.iImageInstanceIndex
		          IF THIS.aImageCopies[m.liImageIndex,1] > m.liPageIndex
		              EXIT
		          ENDIF
		          THIS.oImageDest.Create(CEILING(THIS.aImageCopies[m.liImageIndex,5]/10) + ;
		                                 THIS.margin,;
		                                 CEILING(THIS.aImageCopies[liImageIndex,6]/10) + ;
		                                 THIS.margin)
		          THIS.oPrivateGraphics.CreateFromImage(THIS.oImageDest)
		          THIS.oRect.Set(FLOOR(THIS.aImageCopies[m.liImageIndex,3]/10) ,;
		                         FLOOR(THIS.aImageCopies[m.liImageIndex,4]/10) ,;
		                         CEILING(THIS.aImageCopies[m.liImageIndex,5]/10  + ;
		                         THIS.margin),;
		                         CEILING(THIS.aImageCopies[liImageIndex,6]/10) + ;
		                         THIS.margin)
		          THIS.oPrivateGraphics.DrawImagePortionAt(;
		                    THIS.oImageSrc, THIS.oPoint, THIS.oRect, 2)
		          THIS.oImageDest.SaveToFile(FORCEPATH(THIS.aImageCopies[m.liImageIndex,2], ;
		                                               THIS.sImageFullPath), ;
		                                     THIS.mimetype) 
		          m.liImageIndex = m.liImageIndex + 1 
		       ENDDO
		    NEXT
		    ERASE (m.lcTempFile)
		ENDIF   
		
		IF THIS.listenerSupportsSaveClip(m.toListener,.T.) 
		   BINDEVENT(m.toListener,"OutputPage",THIS,"outputPageClip")
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE setup		&& Setup code for each report run specific to this object.
		LPARAMETERS m.toListener
		
		IF VARTYPE(m.toListener) # "O" 
		   THIS.lOnThisRun = .F.
		   * early quit
		ENDIF
		   
		IF THIS.lOnThisRun 
		   IF EMPTY(THIS.gdiPlusLib) OR ;
		      NOT FILE(THIS.gdiPlusLib)
		      IF ISNULL(m.toListener.FFCGraphics)
		         THIS.lOnThisRun = .F.
		      ELSE
		         THIS.gdiPlusLib = m.toListener.FFCGraphics.ClassLibrary
		      ENDIF         
		   ENDIF
		   * test:
		   LOCAL loTemp
		   TRY
		      loTemp = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		   CATCH WHEN .T.
		      THIS.gdiPlusLib = "_gdiplus.vcx"
		      IF FILE(THIS.gdiPlusLib)
		         THIS.gdiPlusLib = ""
		      ELSE
		         THIS.gdiPlusLib = _REPORTOUTPUT
		      ENDIF 
		      * one more try  
		      TRY
		         loTemp = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		      CATCH WHEN .T.
		         loTemp = NULL
		      ENDTRY
		   FINALLY
		      IF VARTYPE(loTemp) # "O"
		         THIS.lOnThisRun = .F.
		      ENDIF
		      loTemp = NULL
		   ENDTRY      
		ENDIF
		
		IF THIS.lOnThisRun   
		   IF PEMSTATUS(m.toListener,"externalFileLocation",5) AND ;
		      (NOT EMPTY(m.toListener.externalFileLocation)) 
		      THIS.sImagePath = ADDBS(m.toListener.externalFileLocation)
		   ELSE
		      STORE SYS(2023) TO THIS.sImagePath, THIS.sImageFullPath 
		   ENDIF
		   IF THIS.listenerSupportsSaveClip(m.toListener,.T.)
		      * page-at-a-time mode
		      * bind to outputpage event
		      BINDEVENT(m.toListener,"OutputPage",THIS,"outputPageClip")
		   ENDIF
		   IF VARTYPE(THIS.oImageSrc) # "O"
		      THIS.oImageSrc = NEWOBJECT("gpBitMap",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		   ENDIF                             
		   IF VARTYPE(THIS.oImageDest) # "O"
		       THIS.oImageDest = NEWOBJECT("gpBitMap",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		   ENDIF                    
		   IF VARTYPE(THIS.oPoint) # "O"
		      THIS.oPoint = NEWOBJECT("gpPoint",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		   ENDIF         
		   IF VARTYPE(THIS.oRect) # "O"
		      THIS.oRect = NEWOBJECT("gpRectangle",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		   ENDIF        
		   IF VARTYPE(THIS.oPrivateGraphics) # "O"
		      THIS.oPrivateGraphics = NEWOBJECT("gpGraphics",THIS.gdiPlusLib,THIS.gdiPlusLibModule)
		   ENDIF
		 ENDIF   
		
	ENDPROC

	PROCEDURE setupimageclip		&& Saves a row to the aImageCopies array during rendering procedures when a page region is marked for an image copy, for later use in image copy procedures.
		LPARAMETERS m.toListener, ;
		            m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, ;
		            m.tvContentsToBeRendered, m.tlImageControl
		
		LOCAL m.lcFileName
		
		THIS.iImageInstanceIndex = THIS.iImageInstanceIndex + 1
		
		DIME THIS.aImageCopies[THIS.iImageInstanceIndex,6]
		       
		* create a file name based on THIS.Name and THIS.iImageInstanceIndex
		* unless the name of the object is the name of the class, which
		* may happen if it is a privately-owned object
		
		IF UPPER(THIS.Name) == UPPER(THIS.Class)
		   m.lcFileName = "C"+SYS(2015)
		ELSE
		   m.lcFileName = THIS.Name   
		ENDIF
		
		m.lcFileName = FORCEPATH(FORCEEXT(;
		               m.lcFileName + "_"+TRANSFORM(THIS.iImageInstanceIndex), ;
		              THIS.getImageExt()),THIS.sImagePath)                    
		
		IF m.tlImageControl  
		   m.tvContentsToBeRendered = m.lcFileName
		ELSE
		   #IF OUTPUTCLASS_DEBUGGING
		       m.tvContentsToBeRendered = STRCONV(m.lcFileName,STRCONV_DBCS_UNICODE)
		   #ENDIF 
		ENDIF   
		     
		THIS.aImageCopies[THIS.iImageInstanceIndex,1] = m.toListener.PageNo
		THIS.aImageCopies[THIS.iImageInstanceIndex,2] = m.lcFileName
		THIS.aImageCopies[THIS.iImageInstanceIndex,3] = m.tnLeft
		THIS.aImageCopies[THIS.iImageInstanceIndex,4] = m.tnTop
		THIS.aImageCopies[THIS.iImageInstanceIndex,5] = m.tnWidth
		THIS.aImageCopies[THIS.iImageInstanceIndex,6] = m.tnHeight     
	ENDPROC

ENDDEFINE

DEFINE CLASS gfxrotate AS fxabstract OF "_reportlistener.vcx" 		&& Changes default rendering behavior for report layout controls by rotating them according to a MemberData-specified number of degrees.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	Name = "gfxrotate"
	
	PROCEDURE applyfx		&& Implementation of required method for the FX interface.
		LPARAMETERS m.toListener, m.tcMethodToken, ;
		            m.tP1, m.tP2, m.tP3, m.tP4, m.tP5, m.tP6, ;
		            m.tP7, m.tP8, m.tP9, m.tP10, m.tP11, m.tP12
		
		LOCAL liSession, liAngle, liSelect, liFRXRecno, liReturn 
		
		m.liReturn = OUTPUTFX_DEFAULT_RENDER_BEHAVIOR  
		
		IF m.tcMethodToken == "RENDER" AND ;
		   NOT ISNULL(m.toListener.FFCGraphics)
		            
		   TRY
		      m.liSession = SET("DATASESSION")
		      IF m.toListener.FRXDataSession > -1
		         SET DATASESSION TO m.toListener.FRXDataSession
		      ENDIF         
		      m.liSelect = SELECT(0)
		      IF USED(m.toListener.MemberDataAlias) 
		         SELECT (m.toListener.MemberDataAlias)
		         m.liFRXRecno =  m.toListener.getFRXRecno(m.tcMethodToken,m.tP1, m.tP2)
		         LOCATE FOR FrxRecno = m.liFRXRecno AND ;
		                    Type = FRX_BLDR_MEMBERDATATYPE AND ;
		                    Name == FRX_BLDR_NAMESPACE_ROTATE AND ;
		                    NOT EMPTY(Execute)  
		                    
		         IF FOUND() AND NOT EMPTY(INT(VAL(Execute))) 
		            m.liAngle = INT(VAL(Execute))
		            m.toListener.FFCGraphics.TranslateTransform(tP2, tP3)
		            m.toListener.FFCGraphics.RotateTransform(m.liAngle)
		            m.liReturn = OUTPUTFX_BASERENDER_RENDER_BEFORE_RESTORE 
		            m.toListener.FFCGraphics.TranslateTransform(-tP2, -tP3)
		         ENDIF
		      ENDIF
		   CATCH TO err
		      * could expose the error but won't,
		      * we'll just swallow it
		   FINALLY
		       SELECT (m.liSelect)
		       SET DATASESSION TO (m.liSession)
		   ENDTRY            
		   
		ENDIF   
		
		RETURN  m.liReturn
	ENDPROC

ENDDEFINE

DEFINE CLASS htmllistener AS xmldisplaylistener OF "_reportlistener.vcx" 		&& Applies custom specifications, tuned to HTML production, to its parent class' XML generation process.
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: anchorattr_assign
		*m: cssclassattr_assign
		*m: cssclassoverrideattr_assign
		*m: getdefaultuserxsltasstring		&& Supplies default User XSLT document o the getDefaultUserXslt method as a string.
		*m: linkattr_assign
		*m: pathencode		&& Encodes sections of a URL path re-creates the URL from the elements, and optionally re-encodes suitable for including in well-formed XML.
		*m: titleattr_assign
		*m: urlstringencode		&& Encode string for purposes of using it as part of a link in an HTML page.
		*p: anchorattr		&& Supplies the name of the XML attribute used to supply HTML anchor instructions to the node representing an FRX layout control or band.
		*p: cssclassattr		&& Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, supplementing FRX design instructions.
		*p: cssclassoverrideattr		&& Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, overriding FRX design instructions.
		*p: linkattr		&& Supplies the name of the XML attribute used to supply HTML link information to the node representing a layout control containing an image or non-TEXTAREA text.
		*p: oldpageimagetype		&& Saves the user's preferred PageImageType settings during a run, if the Listener adjusts it to match HTML Page Link memberdata contents it finds in this report.
		*p: oldtextareasetting		&& Saves the user's pre-report XSLTParameters useTextAreaForStretchingText value, if the Listener adjusts the value to match memberdata settings it finds in the current report.
		*p: titleattr		&& Supplies the name of the XML attribute used to supply alternate text or tooltip information to a node representing an FRX layout control.
	*</DefinedPropArrayMethod>

	PROTECTED oldpageimagetype,oldtextareasetting
	anchorattr = ("anchor")		&& Supplies the name of the XML attribute used to supply HTML anchor instructions to the node representing an FRX layout control or band.
	applyusertransform = .T.
	cssclassattr = ("css")		&& Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, supplementing FRX design instructions.
	cssclassoverrideattr = ("CSS")		&& Supplies the name of the XML attribute used to supply HTML CSS class information to the node representing a layout control, overriding FRX design instructions.
	FRXDataSession = -1
	linkattr = ("hlink")		&& Supplies the name of the XML attribute used to supply HTML link information to the node representing a layout control containing an image or non-TEXTAREA text.
	ListenerType = 2
	Name = "htmllistener"
	oldpageimagetype = -1		&& Saves the user's preferred PageImageType settings during a run, if the Listener adjusts it to match HTML Page Link memberdata contents it finds in this report.
	oldtextareasetting = -1		&& Saves the user's pre-report XSLTParameters useTextAreaForStretchingText value, if the Listener adjusts the value to match memberdata settings it finds in the current report.
	targetfileext = ("HTM")
	titleattr = ("title")		&& Supplies the name of the XML attribute used to supply alternate text or tooltip information to a node representing an FRX layout control.
	_memberdata = <VFPData>
		<memberdata name="imagefieldinstance" type="property" display="imageFieldInstance" favorites="False" />
		<memberdata name="imagefieldtofile" type="property" display="imageFieldToFile" favorites="False" />
		<memberdata name="imagefilebasename" type="property" display="imageFileBaseName" favorites="True" />
		<memberdata name="imagesrcattr" type="property" display="imageSrcAttr" favorites="True" />
		<memberdata name="jpgclsid" type="property" display="JPGclsid" favorites="False" />
		<memberdata name="oldexternalfilelocation" type="property" display="oldExternalFileLocation" favorites="False" />
		<memberdata name="oldsendgdiplusimage" type="property" display="oldSendGDIPlusImage" favorites="False" />
		<memberdata name="checkreportforgeneralfields" type="method" display="checkReportForGeneralFields" favorites="False" />
		<memberdata name="getdefaultuserxsltasstring" type="method" display="getDefaultUserXsltAsString" favorites="False" />
		<memberdata name="initializefilecopysettings" type="method" display="initializeFileCopySettings" favorites="False"/>
		<memberdata name="titleattr" display="titleAttr" type="property" favorites="True"/>
		<memberdata name="linkattr" display="linkAttr" type="property" favorites="True"/>
		<memberdata name="cssclassattr" display="cssClassAttr" type="property" favorites="True"/>
		<memberdata name="cssclassoverrideattr" display="cssClassOverrideAttr" type="property" favorites="True"/>
		<memberdata name="anchorattr" display="anchorAttr" type="property" favorites="True"/>
		<memberdata name="oldpageimagetype" display="oldPageImageType" type="property"/>
		<memberdata name="oldtextareasetting" display="oldTextAreaSetting" type="property"/>
		<memberdata name="urlstringencode" type="method" favorites="True" display="urlStringEncode"/>
		<memberdata name="pathencode" type="method" favorites="True" display="pathEncode"/>
		</VFPData>
	
	PROCEDURE AfterReport
		LPARAMETERS tlCalledEarly
		DODEFAULT(tlCalledEarly)
		IF THIS.oldPageImageType <> -1
		   THIS.pageImageType = THIS.oldPageImageType 
		ENDIF
		THIS.resetDataSession()
	ENDPROC

	PROCEDURE anchorattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
		   AND NOT (m.vNewVal == THIS.anchorAttr)
		   THIS.anchorAttr = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
		
		
		
		
		
	ENDPROC

	PROCEDURE applyusertransformtooutput
		DODEFAULT()
		IF THIS.oldTextAreaSetting <> -1
		   THIS.adjustXSLTParameter( THIS.oldTextAreaSetting,"useTextAreaForStretchingText")                     
		   THIS.oldTextAreaSetting = -1
		ENDIF
		
	ENDPROC

	PROCEDURE BeforeReport
		DODEFAULT()
		
		THIS.oldPageImageType = -1
		
		IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
		   LOCAL llSetting, liSelect
		   THIS.setFRXDataSession()
		   IF USED(THIS.memberDataAlias)
		      m.liSelect = SELECT(0)
		      SELECT (THIS.memberDataAlias)
		      LOCATE FOR Type == FRX_BLDR_MEMBERDATATYPE AND ;
		                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                 ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
		                 THIS.evaluateStringToBoolean(Execute)         
		      IF FOUND() AND THIS.pageImageType = 0
		         THIS.oldPageImageType = 0
		         THIS.pageImageType =  OUTPUTHTML_DEFAULT_PAGEIMAGE_TYPE
		         IF THIS.ListenerType = LISTENER_TYPE_DEF
		            THIS.ListenerType = LISTENER_TYPE_PAGED
		         ENDIF
		         IF THIS.supportsPageImages()  
		            THIS.makeExternalFileLocationReachable() 
		         ELSE
		            IF NOT THIS.IsSuccessor
		               THIS.pageImageType =  0      
		            ENDIF
		         ENDIF   
		      ENDIF
		      IF NOT THIS.CommandClauses.NoPageEject
		         * we can only make this adjustment once per chain, 
		         * since it can only be applied once per chain.
		         * Last one wins.
		         LOCATE FOR Type == FRX_BLDR_MEMBERDATATYPE AND ;
		                    Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                    ExecWhen == FRX_BLDR_ADVPROP_HTML_TEXTAREAS_OFF 
		         IF FOUND()
		            llSetting = THIS.evaluateStringToBoolean(Execute)         
		            IF VARTYPE(THIS.xsltParameters) = "O" AND ;
		               THIS.xsltParameters.GetKey("useTextAreaForStretchingText") > 0
		               THIS.oldTextAreaSetting = THIS.xsltParameters["useTextAreaForStretchingText"]
		            ELSE
		               THIS.oldTextAreaSetting = 1               
		            ENDIF   
		            THIS.adjustXSLTParameter( ;
		                 IIF(llSetting,0,1),"useTextAreaForStretchingText")                     
		         ENDIF                    
		      ENDIF         
		   ENDIF
		ENDIF   
		THIS.resetDataSession()
	ENDPROC

	PROCEDURE cssclassattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
		   AND NOT (m.vNewVal == THIS.cssClassAttr)
		   THIS.cssClassAttr = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
		
		
		
		
		
		
	ENDPROC

	PROCEDURE cssclassoverrideattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
		   AND NOT (m.vNewVal == THIS.cssClassOverrideAttr)
		   THIS.cssClassOverrideAttr = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
		
		
		
		
		
		
	ENDPROC

	PROCEDURE fillruncollector
		DODEFAULT()
		IF NOT ISNULL(THIS.runCollector)
		   * should have been taken care of by superclass
		   THIS.setFRXDataSession()
		   IF USED(THIS.memberDataAlias) 
		      LOCAL m.lvValue, m.lcExpr, m.liSelect, m.loXML, m.loXMLTemp, m.loNode
		      IF USED("FRX") 
		         GO (THIS.frxHeaderRecno) IN FRX
		         #IF OUTPUTXML = OUTPUTXML_DOM
		            m.loXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		            m.loXMLTemp = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		         #ELSE
		            m.loXML = CREATEOBJECT("Microsoft.XMLDOM")
		            m.loXMLTemp = CREATEOBJECT("Microsoft.XMLDOM")
		         #ENDIF      
		         IF NOT m.loXML.LoadXML(FRX.Style)
		            m.loXML = NULL
		         ENDIF
		      ENDIF      
		      IF NOT ISNULL(m.loXML)
		         m.liSelect = SELECT(0)
		         SELECT (THIS.memberDataAlias)
		         LOCATE FOR FRXRecno = THIS.frxHeaderRecno AND ;
		                 Type = FRX_BLDR_MEMBERDATATYPE  ;
		                 AND Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS ;
		                 AND ExecWhen == FRX_BLDR_ADVPROP_HTML_HTTPEQUIV ;
		                 AND VAL(DeClass) = ADVPROP_EDITMODE_TEXT ;
		                 AND NOT EMPTY(Execute)
		         IF FOUND()                 
		            m.lvValue = ;
		                      m.loXML.SelectSingleNode("/VFPData/reportdata" + ;
		                      "[@name='" + Name + "' and @execwhen='" + ;
		                      FRX_BLDR_ADVPROP_HTML_HTTPEQUIV + "']/@execute")
		            IF (NOT ISNULL(m.lvValue)) AND ;
		                 m.loXMLTemp.LoadXML(m.lvValue.Text)
		                 m.loXML = m.loXMLTemp.SelectNodes("//meta")
		                 FOR EACH m.loNode IN m.loXML
		                    m.lcExpr = m.loNode.getAttribute("name")
		                    m.lvValue = m.loNode.getAttribute("content")
		                    IF NOT (ISNULL(m.lcExpr) OR ISNULL(m.lvValue) OR ;
		                           EMPTY(m.lcExpr) OR EMPTY(m.lvValue))
		                       IF VAL(m.loNode.getAttribute("type")) = ADVPROP_EDITMODE_GETEXPR
		                          m.lvValue = THIS.evaluateUserExpression(m.lvValue)
		                       ENDIF
		                      IF THIS.runCollector.getKey(FRX_BLDR_ADVPROP_HTML_HTTPEQUIV+"." + m.lcExpr) = 0
		                         THIS.runCollector.add(m.lvValue,FRX_BLDR_ADVPROP_HTML_HTTPEQUIV+"." + m.lcExpr)
		                      ENDIF   
		                   ENDIF  
		                NEXT
		            ENDIF                      
		         ENDIF
		         STORE NULL  TO m.loXML, m.loXMLTemp, m.loNode
		         SELECT (liSelect)         
		      ENDIF        
		   ENDIF      
		ENDIF
		
	ENDPROC

	PROCEDURE getdefaultuserxslt
		LOCAL m.lcResult
		m.lcResult = THIS.getDefaultUserXSLTAsString()
		
		* document properties, general
		m.lcResult = STRTRAN(m.lcResult,"@id='description'","@id='"+FRX_BLDR_ADVPROP_DESCRIPTION+"'")
		m.lcResult = STRTRAN(m.lcResult,"@id='author'","@id='"+FRX_BLDR_ADVPROP_AUTHOR+"'")
		m.lcResult = STRTRAN(m.lcResult,"@id='keywords'","@id='"+FRX_BLDR_ADVPROP_KEYWORDS+"'")
		m.lcResult = STRTRAN(m.lcResult,"@id='title'","@id='"+FRX_BLDR_ADVPROP_TITLE+"'")
		m.lcResult = STRTRAN(m.lcResult,"@id='copyright'","@id='"+FRX_BLDR_ADVPROP_COPYRIGHT+"'")
		m.lcResult = STRTRAN(m.lcResult,"@id='date'","@id='"+FRX_BLDR_ADVPROP_DATE+"'")
		
		* document properties, HTML-specific
		m.lcResult = STRTRAN(m.lcResult,"@id='css_sheet'","@id='"+FRX_BLDR_ADVPROP_HTML_CSS_FILE +"'")
		m.lcResult = STRTRAN(m.lcResult,"@id='http-equiv'","@id='"+FRX_BLDR_ADVPROP_HTML_HTTPEQUIV  +"'")
		
		* base VFP-RDL XML characteristics set
		m.lcResult = STRTRAN(m.lcResult,"@h","@"+ THIS.HeightAttr)
		m.lcResult = STRTRAN(m.lcResult,"@w","@"+ THIS.WidthAttr)
		m.lcResult = STRTRAN(m.lcResult,"@l","@"+ THIS.LeftAttr)
		m.lcResult = STRTRAN(m.lcResult,"@t","@"+ THIS.TopAttr)
		m.lcResult = STRTRAN(m.lcResult,"@c","@"+ THIS.ContAttr)
		m.lcResult = STRTRAN(m.lcResult,"@idref","@"+ THIS.IdRefAttribute)
		m.lcResult = STRTRAN(m.lcResult,"@id","@"+THIS.IdAttribute)
		m.lcResult = STRTRAN(m.lcResult,"@img","@"+THIS.imageSrcAttr )
		
		* dynamic data and page-image extension set implemented in XMLListener
		m.lcResult = STRTRAN(m.lcResult,"@DTEXT","@"+THIS.dataTextAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@DTYPE","@"+THIS.dataTypeAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@PLINK","@"+THIS.pageImageAttr  )
		
		* dynamic formatting extension set implemented in XMLDisplayListener
		m.lcResult = STRTRAN(m.lcResult,"@PA","@"+THIS.penAlphaAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@PR","@"+THIS.penRedAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@PG","@"+THIS.penGreenAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@PB","@"+THIS.penBlueAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FA","@"+THIS.fillAlphaAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FR","@"+THIS.fillRedAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FG","@"+THIS.fillGreenAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FB","@"+THIS.fillBlueAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FNAME","@"+THIS.fontNameAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FSIZE","@"+THIS.fontSizeAttr  )
		m.lcResult = STRTRAN(m.lcResult,"@FSTYLE","@"+THIS.fontStyleAttr  )
		
		* dynamic HTML extension set implemented in this class
		m.lcResult = STRTRAN(m.lcResult,"@title","@"+THIS.titleAttr )
		m.lcResult = STRTRAN(m.lcResult,"@alt","@"+THIS.titleAttr )
		m.lcResult = STRTRAN(m.lcResult,"@css","@"+THIS.cssClassAttr )
		m.lcResult = STRTRAN(m.lcResult,"@CSS","@"+THIS.cssClassOverrideAttr )
		m.lcResult = STRTRAN(m.lcResult,"@anchor","@"+THIS.anchorAttr )
		m.lcResult = STRTRAN(m.lcResult,"@hlink","@"+THIS.linkAttr )
		
		THIS.XSLTProcessorUser = m.lcResult
		
		
		
	ENDPROC

	PROTECTED PROCEDURE getdefaultuserxsltasstring		&& Supplies default User XSLT document o the getDefaultUserXslt method as a string.
		LOCAL m.lcResult
		SET TEXTMERGE TO MEMVAR m.lcResult NOSHOW
		SET TEXTMERGE ON 
		TEXT
		<?xml version="1.0"?>
		<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
		  <xsl:output method="html" version="1.0" encoding="UTF-8" indent="no" doctype-public="-//W3C//DTD HTML 4.0//EN" doctype-system="http://www.w3.org/TR/REC-html40/strict.dtd"/>
		
		  <xsl:param name="externalFileLocation"/>
		  <!--select="'./whatever/'" or 'http://something/myimages/' or "'./'" or... -->
		  <xsl:param name="copyImageFiles" select="0"/>
		  <xsl:param name="generalFieldDPI" select="96"/>
		  <xsl:param name="fillPatternShade" select="180*3"/>
		  <xsl:param name="fillPatternOffset" select="128"/>
		  <xsl:param name="numberPrecision" select="5"/>
		  <xsl:param name="fieldAlphaOpacityOffset" select="75"/>
		  <xsl:param name="fieldAlphaOpacityShade" select="180*3"/>
		  <xsl:param name="useTextAreaForStretchingText" select="1"/>
		  <xsl:param name="hideScrollbarsForTextAreas" select="0"/>
		  <xsl:param name="PageTitlePrefix_LOC" select="''"/>
		<!--    <xsl:param name="unpagedModeIncludesOnePageHeader" select="0"/> -->
		  <xsl:param name="unpagedModeIncludesTitle" select="1"/>
		  <xsl:param name="noBody" select="0"/>
		  <xsl:param name="useDynamicTextAttributes" select="1"/>
		  <xsl:param name="anchorAttrName" select="1"/>   
		  <!-- id is theoretically better if you wanted to write
		   script against this element, or in case name is 
		   deprecated in a future version of the standard, 
		   but a value of 1 forces name to be used instead. 
		   Current-newer browsers will be okay with this, and older 
		   browsers might prefer it. -->
		  <xsl:variable name="FRUs" select="10000"/>
		  <xsl:variable name="printDPI" select="960"/>
		  <xsl:variable name="FRUsInPixelsat96DPI" select="104.167"/>
		  <xsl:variable name="imagePixelRatio" select="$generalFieldDPI div $printDPI"/>
		  <xsl:variable name="zeros" select="substring('0000000000000000000000000',1,$numberPrecision)"/>
		  <xsl:variable name="thisPageHeight">
		    <xsl:value-of select="number(/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@pageheight  div $printDPI)"/>
		  </xsl:variable>
		  <xsl:variable name="lineNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=6]/name"/>
		  <xsl:variable name="labelNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=5]/name"/>
		  <xsl:variable name="fieldNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=8]/name"/>
		  <xsl:variable name="shapeNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=7]/name"/>
		  <xsl:variable name="pictureNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[type=17]/name"/>
		  <xsl:variable name="detailNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=4]/name"/>
		  <xsl:variable name="detailHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=9]/name"/>
		  <xsl:variable name="detailFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=10]/name"/>
		  <xsl:variable name="pageHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=1]/name"/>
		  <xsl:variable name="pageFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=7]/name"/>
		  <xsl:variable name="columnHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=2]/name"/>
		  <xsl:variable name="columnFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=6]/name"/>
		  <xsl:variable name="groupHeaderNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=3]/name"/>
		  <xsl:variable name="groupFooterNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=5]/name"/>
		  <xsl:variable name="titleNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=0]/name"/>
		  <xsl:variable name="summaryNodeName" select="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutNode[code=8]/name"/>
		  <xsl:variable name="anchorAttr">
		  <xsl:choose>
		  <xsl:when test="$anchorAttrName=1">name</xsl:when>
		  <xsl:otherwise>id</xsl:otherwise>
		  </xsl:choose> 
		  </xsl:variable>
		
		
		  <xsl:key name="Layout" match="/Reports/VFP-Report/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[platform='WINDOWS']" use="concat(frxrecno,../../@id)"/>
		
		
		  <xsl:template match="/">
		      <xsl:choose>
		        <xsl:when test="number($noBody)=1">
		        <div>
		         <meta http-equiv="Content-Type"  content="text/html; charset=UTF-8"/>        
		          <xsl:call-template name="renderStyles"/>
		          <xsl:call-template name="body"/>
		         </div>
		        </xsl:when>
		        <xsl:otherwise>
		          <xsl:apply-templates select="/" mode="full"/>
		        </xsl:otherwise>
		      </xsl:choose>
		  </xsl:template>
		  <xsl:template match="/" mode="full">
		    <html>
		       <xsl:if test="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=1 and (fontcharset=177 or fontcharset=178)]">
		       <xsl:attribute name="dir">rtl</xsl:attribute>
		       </xsl:if>
		      <head>
		        <meta  http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<xsl:comment> 
		the above repeated-explicit declaration is necessary because 
		some versions of MSXML xslt processing don't include the 
		charset as required by the XSLT standard when method="html".  
		Explicitly including the META creates a doubled meta content-type tag, 
		but we do need the encoding to be specified properly and the doubled tag is okay. 
		</xsl:comment>
		        <meta name="description" 
		content="{/Reports/VFP-Report[1]/Run/property[@id='description']/.}"/>
		        <meta name="author" 
		content="{/Reports/VFP-Report[1]/Run/property[@id='author']/.}"/>
		        <meta name="copyright" 
		content="{/Reports/VFP-Report[1]/Run/property[@id='copyright']/.}"/>
		        <meta name="date" 
		content="{/Reports/VFP-Report[1]/Run/property[@id='date']/.}"/>
		        <xsl:if test="/Reports/VFP-Report/Run/property[@id='keywords']">
		        <meta name="keywords">
		        <xsl:attribute name="content">
		         <xsl:for-each select="/Reports/VFP-Report/Run/property[@id='keywords']">
		         <xsl:value-of select="."/><xsl:if test="not(position()=last())">,</xsl:if>
		        </xsl:for-each>
		        </xsl:attribute>
		        </meta> 
		        </xsl:if>
		        <xsl:if test="/Reports/VFP-Report/Run/property[@id='http-equiv']">
		            <xsl:for-each select="/Reports/VFP-Report/Run/property[@id='http-equiv']//meta">
		          <xsl:variable name="thisMeta" select="concat(ancestor-or-self::*[@id='http-equiv']/@id ,'.',@name)"/>
		          <!-- the extra Run nodes being looked up are potentially evaluated, not original values of the property, 
		          so we can account for expressions -->
		          <meta  http-equiv="{@name}" content="{/Reports/VFP-Report/Run/property[@id=$thisMeta]}"/>
		          </xsl:for-each>
		        </xsl:if>
		
		        <title>
		          <xsl:choose>
		          <xsl:when test="/Reports/VFP-Report[1]/Run/property[@id='title']">
		            <xsl:value-of select="/Reports/VFP-Report[1]/Run/property[@id='title']/."/>
		          </xsl:when>
		          <xsl:otherwise>
		            <!-- default/VFP 9.0 RTM handling -->
		             <xsl:value-of select="$PageTitlePrefix_LOC"/>
		             <xsl:if test="string-length(/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@name) = 0">
		               <xsl:value-of select="/Reports/VFP-Report[1]/VFP-RDL/@id"/>
		             </xsl:if>
		             <xsl:value-of select="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXPrintJob/@name"/>
		          </xsl:otherwise>
		          </xsl:choose>
		        </title>
		        <xsl:call-template name="renderStyles"/>
		      </head>
		      <body>
		        <xsl:call-template name="body"/>
		      </body>
		    </html>
		  </xsl:template>
		  <xsl:template name="renderStyles">
		     <xsl:call-template name="DocumentStyles"/>
		    <xsl:for-each select="/Reports/VFP-Report">
		      <xsl:call-template name="Styles">
		        <xsl:with-param name="thisReport" select="position()"/>
		        <xsl:with-param name="thisReportID" select="./VFP-RDL/@id"/>
		      </xsl:call-template>
		      <!--        <xsl:call-template name="Script"/> avoid security problems: no script, not even a lone comment indicating TBD -->
		    </xsl:for-each>
		  </xsl:template>
		  <xsl:template name="body">
		    <xsl:for-each select="/Reports/VFP-Report">
		      <xsl:variable name="thisReport" select="position()"/>
		      <xsl:variable name="thisReportID" select="./VFP-RDL/@id"/>
		      <xsl:variable name="thisReportRangeFrom" select="number(./VFP-RDL/VFPDataSet/VFPFRXCommand/@RANGEFROM)"/>
		      <xsl:variable name="separateTitlePage" select="./Data/*[name()=$titleNodeName] and ./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='0' and pagebreak='true']"/>
		      <xsl:variable name="separateSummaryPage" select="./Data/*[name()=$summaryNodeName] and ./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='8' and pagebreak='true' and ejectbefor='false']"/>
		      <xsl:variable name="reportPages" select="count(./Data/*[(name()=$pageHeaderNodeName) or (name()=$titleNodeName and $separateTitlePage=true()) or  (name()=$summaryNodeName and $separateSummaryPage=true())])"/>
		      <div>
		        <xsl:if test="number($noBody)=1">
		          <xsl:attribute name="style">
		               position=relative;height=<xsl:value-of select="$reportPages * $thisPageHeight"/>in;
		               </xsl:attribute>
		        </xsl:if>
		        <xsl:choose>
		          <xsl:when test="./Data/*[name() = $pageHeaderNodeName]">
		            <xsl:if test="$separateTitlePage">
		              <xsl:apply-templates select="./Data/*[name()=$titleNodeName]" mode="titlesummarypage">
		                <xsl:with-param name="thisReport" select="$thisReport"/>
		                <xsl:with-param name="thisReportID" select="$thisReportID"/>
		              </xsl:apply-templates>
		            </xsl:if>
		            <xsl:apply-templates select="./Data/*[name()=$pageHeaderNodeName]" mode="page">
		              <xsl:with-param name="thisReport" select="$thisReport"/>
		              <xsl:with-param name="thisReportID" select="$thisReportID"/>
		              <xsl:with-param name="thisReportRangeFrom" select="$thisReportRangeFrom"/>
		            </xsl:apply-templates>
		            <xsl:if test="$separateSummaryPage">
		              <xsl:apply-templates select="./Data/*[name()=$summaryNodeName]" mode="titlesummarypage">
		                <xsl:with-param name="thisReport" select="$thisReport"/>
		                <xsl:with-param name="thisReportID" select="$thisReportID"/>
		              </xsl:apply-templates>
		            </xsl:if>
		          </xsl:when>
		          <xsl:otherwise>
		            <!-- unpaginated-->
		            <xsl:variable name="thisPageHeaderHeight" select="/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header'][1]/height  div $FRUs"/>
		            <xsl:variable name="thisReportPageHeight" select="number($thisPageHeight - ( $thisPageHeaderHeight +  (/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Footer'][1]/height div $FRUs)) )"/>
		            <xsl:if test="./Data/Pages/*[name() = $pageHeaderNodeName]"> <!-- $unpagedModeIncludesOnePageHeader=1" -->
		              <!-- show the contents of the first page header -->
		              <xsl:apply-templates mode="formattingBand" select="./Data/Pages/*[@idref = /Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header']/frxrecno][1]">
		                <xsl:with-param name="thisReport" select="$thisReport"/>
		                <xsl:with-param name="thisReportID" select="$thisReportID"/>
		                <xsl:with-param name="thisReportPageHeight" select="$thisReportPageHeight"/>
		                <xsl:with-param name="thisPageHeight" select="$thisPageHeight"/>
		              </xsl:apply-templates>
		            </xsl:if>
		            
		            <!-- the @id criteria below leaves out the Pages and Columns collections, if any -->
		            <!-- we could add in an initial page header but then we'd have to do the additional work to handle any title, etc; all the height offsets will change -->
		            <xsl:apply-templates select="./Data/*[@idref and ($unpagedModeIncludesTitle=1 or not(name() = $titleNodeName))]" mode="unpagedBand">
		              <xsl:with-param name="thisReport" select="$thisReport"/>
		              <xsl:with-param name="thisReportID" select="$thisReportID"/>
		              <xsl:with-param name="thisPageHeight" select="$thisPageHeight"/>
		              <xsl:with-param name="thisReportPageHeight" select="$thisReportPageHeight"/>
		              <xsl:with-param name="thisPageHeaderHeight" select="$thisPageHeaderHeight"/>
		            </xsl:apply-templates>
		          </xsl:otherwise>
		        </xsl:choose>
		      </div>
		    </xsl:for-each>
		  </xsl:template>
		  <xsl:template match="/Reports/VFP-Report/Data/*" mode="titlesummarypage">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:param name="thisReportRangeFrom" select="1"/>
		    <xsl:variable name="thisBand" select="@id"/>
		    <div>
		      <xsl:attribute name="style"> width:100%;top:<xsl:value-of select="$thisPageHeight * (number( ./@idref) -$thisReportRangeFrom)"/>in; position:absolute; </xsl:attribute>
		      <xsl:apply-templates select="." mode="band">
		        <xsl:with-param name="thisReport" select="$thisReport"/>
		        <xsl:with-param name="thisReportID" select="$thisReportID"/>
		      </xsl:apply-templates>
		      <xsl:if test="/Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[frxrecno=$thisBand and ejectafter='true']">
		        <!-- page footer for this summary page -->
		        <xsl:apply-templates select="/Reports/VFP-Report[$thisReport]/Data/*[name()=$pageFooterNodeName][position()=last()]" mode="band">
		          <xsl:with-param name="thisReport" select="$thisReport"/>
		          <xsl:with-param name="thisReportID" select="$thisReportID"/>
		        </xsl:apply-templates>
		      </xsl:if>
		    </div>
		  </xsl:template>
		  <xsl:template match="/Reports/VFP-Report/Data/*" mode="page">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:param name="thisReportRangeFrom" select="1"/>
		    <xsl:variable name="thisPage" select="@id"/>
		    <div>
		      <xsl:attribute name="style"> width:100%;top:<xsl:value-of select="$thisPageHeight * ($thisPage -$thisReportRangeFrom)"/>in;position:absolute; </xsl:attribute>
		      <xsl:apply-templates select="." mode="band">
		        <xsl:with-param name="thisReport" select="$thisReport"/>
		        <xsl:with-param name="thisReportID" select="$thisReportID"/>
		      </xsl:apply-templates>
		      <xsl:if test="$thisPage = 1 and /Reports/VFP-Report[$thisReport]/Data/*[name()=$titleNodeName] and /Reports/VFP-Report[$thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandtype='0' and pagebreak='false']">
		        <xsl:apply-templates select="/Reports/VFP-Report[$thisReport]/Data/*[name()=$titleNodeName]" mode="band">
		          <xsl:with-param name="thisReport" select="$thisReport"/>
		          <xsl:with-param name="thisReportID" select="$thisReportID"/>
		        </xsl:apply-templates>
		      </xsl:if>
		      <xsl:apply-templates select="/Reports/VFP-Report/Data/*[( (@id=$thisPage and contains(concat('|',$pageFooterNodeName,'|',$columnHeaderNodeName,'|',$columnFooterNodeName,'|'),concat('|',name(),'|'))) or (@idref=$thisPage and contains(concat('|',$detailHeaderNodeName,'|',$detailFooterNodeName,'|',$detailNodeName,'|',$groupHeaderNodeName,'|',$groupFooterNodeName,'|',$summaryNodeName,'|'),concat('|',name(),'|'))) )]" mode="band">
		        <xsl:with-param name="thisReport" select="$thisReport"/>
		        <xsl:with-param name="thisReportID" select="$thisReportID"/>
		      </xsl:apply-templates>
		    </div>
		  </xsl:template>
		  <xsl:template match="/Reports/VFP-Report/Data/Pages/*" mode="formattingBand">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:param name="thisPageHeight"/>
		    <xsl:param name="thisReportPageHeight"/>
		    <xsl:variable name="thisPage" select="@id"/>
		    <xsl:variable name="thisPageRenderOffset" select="(($thisPage - 1) * $thisReportPageHeight)  + sum((/Reports/VFP-Report[position() &lt; $thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header']/height) ) "/>
		    <xsl:for-each select="./*">
		      <xsl:variable name="thisID" select="translate(@id,'+','')"/>
		      <xsl:call-template name="Render">
		        <xsl:with-param name="thisID" select="$thisID"/>
		        <xsl:with-param name="thisZ" select="position()"/>
		        <xsl:with-param name="thisPage" select="../@idref"/>
		        <xsl:with-param name="thisReport" select="$thisReport"/>
		        <xsl:with-param name="thisReportID" select="$thisReportID"/>
		        <xsl:with-param name="topOffset" select="number($thisPageRenderOffset) * $printDPI"/>
		      </xsl:call-template>
		    </xsl:for-each>
		  </xsl:template>
		  <xsl:template match="/Reports/VFP-Report/Data/*" mode="unpagedBand">
		      <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:param name="thisPageHeight"/>
		    <xsl:param name="thisReportPageHeight"/>
		    <xsl:param name="thisPageHeaderHeight"/>
		    <xsl:variable name="thisPage" select="@idref"/>
		    <xsl:variable name="thisPageRenderOffset">
		      <xsl:choose>
		        <xsl:when test="../Pages/*[name() = $pageHeaderNodeName]"> <!-- $unpagedModeIncludesOnePageHeader=1" -->
		          <xsl:value-of select="(($thisPage - 1) * $thisReportPageHeight) + (sum(/Reports/VFP-Report[position() &lt; $thisReport]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[bandlabel='Page Header'][1]/height)div $FRUs)  + $thisPageHeaderHeight "/>
		        </xsl:when>
		        <xsl:otherwise>
		          <xsl:value-of select="(($thisPage - 1) * $thisReportPageHeight) -($thisPageHeaderHeight*$thisPage)  "/>
		        </xsl:otherwise>
		      </xsl:choose>
		    </xsl:variable>
		    <xsl:call-template name="addAnchor"/>
		    <xsl:for-each select="./*">
		      <xsl:variable name="thisID" select="translate(@id,'+','')"/>
		      <xsl:call-template name="Render">
		        <xsl:with-param name="thisID" select="$thisID"/>
		        <xsl:with-param name="thisZ" select="position()"/>
		        <xsl:with-param name="thisPage" select="../@idref"/>
		        <xsl:with-param name="thisReport" select="$thisReport"/>
		        <xsl:with-param name="thisReportID" select="$thisReportID"/>
		        <xsl:with-param name="topOffset" select="number($thisPageRenderOffset) * $printDPI"/>
		      </xsl:call-template>
		    </xsl:for-each>
		  </xsl:template>
		
		  <xsl:template match="/Reports/VFP-Report/Data/*" mode="band">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:call-template name="addAnchor"/>
		    <xsl:for-each select="./*">
		      <xsl:variable name="thisID" select="translate(@id,'+','')"/>
		      <!--        <xsl:if test="key('Layout',concat($thisID, $thisReportID))/vpos &gt; key('Layout',preceding-sibling::*/concat(@id,$thisReportID))/vpos"><div style="position=absolute;"/></xsl:if>  -->
		      <xsl:call-template name="Render">
		        <xsl:with-param name="thisID" select="$thisID"/>
		        <xsl:with-param name="thisZ" select="position()"/>
		        <xsl:with-param name="thisPage" select="../@idref"/>
		        <xsl:with-param name="thisReport" select="$thisReport"/>
		        <xsl:with-param name="thisReportID" select="$thisReportID"/>
		      </xsl:call-template>
		    </xsl:for-each>
		  </xsl:template>
		  <xsl:template name="Render">
		    <xsl:param name="thisID"/>
		    <xsl:param name="thisZ"/>
		    <xsl:param name="thisPage"/>
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID" select="1"/>
		    <xsl:param name="topOffset" select="0"/>
		    <xsl:call-template name="addAnchor"/>
		    <xsl:choose>
		      <xsl:when test="name()=$lineNodeName and key('Layout',concat($thisID, $thisReportID))/height &lt;  key('Layout',concat($thisID, $thisReportID))/width">
		        <hr>
		          <xsl:call-template name="addClassAttribute">
		        <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
		        </xsl:call-template>
		        <xsl:call-template name="addTitleAttribute"/>
		          <xsl:call-template name="addStyleAttribute">
		            <xsl:with-param name="topOffset" select="$topOffset"/>
		            <xsl:with-param name="thisZ" select="$thisZ"/>
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		           <xsl:with-param name="thisID" select="$thisID"/>
		           <xsl:with-param name="styleType" select="'HR'"/>
		          </xsl:call-template>
		        </hr>
		      </xsl:when>
		      <xsl:when test="name()=$lineNodeName">
		        <!-- vertical line -->
		        <span>
		          <xsl:call-template name="addClassAttribute">
		            <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
		        </xsl:call-template>
		          <xsl:call-template name="addTitleAttribute"/>
		          <xsl:call-template name="addStyleAttribute">
		            <xsl:with-param name="topOffset" select="$topOffset"/>
		            <xsl:with-param name="thisZ" select="$thisZ"/>
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		           <xsl:with-param name="thisID" select="$thisID"/>
		              <xsl:with-param name="styleType" select="'VR'"/>
		          </xsl:call-template>
		        </span>
		      </xsl:when>
		      <xsl:when test="$useTextAreaForStretchingText=1 and string-length(@hlink) = 0  and name()=$fieldNodeName and key('Layout',concat($thisID, $thisReportID))[stretch='true']">
		        <textarea readonly="readonly" rows="0" cols="0">
		          <xsl:call-template name="addClassAttribute">
		             <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
		        </xsl:call-template>
		          <xsl:call-template name="addTitleAttribute"/>
		          <xsl:call-template name="addStyleAttribute">
		            <xsl:with-param name="topOffset" select="$topOffset"/>
		            <xsl:with-param name="thisZ" select="$thisZ"/>
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		          <xsl:with-param name="thisID" select="$thisID"/>
		          <xsl:with-param name="styleType" select="'TextArea'"/>
		          </xsl:call-template>
		          <xsl:value-of select="."/>
		        </textarea>
		      </xsl:when>
		      <xsl:otherwise>
		        <div>
		          <xsl:call-template name="addClassAttribute">
		            <xsl:with-param name="default" select="concat('FRX',$thisReport,'_',$thisID)"/> 
		        </xsl:call-template>
		          <xsl:call-template name="addTitleAttribute"/>
		          <xsl:call-template name="addStyleAttribute">
		            <xsl:with-param name="topOffset" select="$topOffset"/>
		            <xsl:with-param name="thisZ" select="$thisZ"/>
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		          <xsl:with-param name="thisID" select="$thisID"/>
		          <xsl:with-param name="styleType" select="'Div'"/>
		          </xsl:call-template>
		          <xsl:choose>
		            <xsl:when test="name()=$shapeNodeName or name()=$lineNodeName">
		              <!-- nothing -->
		            </xsl:when>
		            <xsl:when test="name()=$pictureNodeName and string-length(@hlink) &gt; 0">
		              <a href="{@hlink}">
		                <xsl:call-template name="renderPicture">
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		            <xsl:with-param name="thisID" select="$thisID"/>
		                </xsl:call-template>
		              </a>
		            </xsl:when>
		            <xsl:when test="name()=$pictureNodeName and string-length(@PLINK) &gt; 0">
		              <a href="{translate(@PLINK,'\','/')}"  target="blank">
		                <xsl:call-template name="renderPicture">
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		            <xsl:with-param name="thisID" select="$thisID"/>
		                </xsl:call-template>
		              </a>
		            </xsl:when>
		            <xsl:when test="name()=$pictureNodeName">
		              <xsl:call-template name="renderPicture">
		            <xsl:with-param name="thisReportID" select="$thisReportID"/>
		            <xsl:with-param name="thisID" select="$thisID"/>
		              </xsl:call-template>
		            </xsl:when>
		            <xsl:when test="string-length(@hlink) &gt; 0">
		              <a href="{@hlink}">
		                <xsl:call-template name="replaceText"/>
		              </a>
		            </xsl:when>
		            <xsl:when test="string-length(@PLINK) &gt; 0">
		              <a href="{translate(@PLINK,'\','/')}" target="blank">
		                <xsl:call-template name="replaceText"/>
		              </a>
		            </xsl:when>
		            <xsl:otherwise>
		              <xsl:call-template name="replaceText"/>
		            </xsl:otherwise>
		          </xsl:choose>
		        </div>
		      </xsl:otherwise>
		    </xsl:choose>
		    <!-- /xsl:if -->
		  </xsl:template>
		  <xsl:template name="getCSSName">
		  <xsl:param name="thisReport" select="1"/>
		  <xsl:param name="thisItem" select="0"/>
		  <xsl:param name="firstPass" select="1"/>
		  <xsl:variable name="subst" select="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$thisItem]/@css"/>
		    <xsl:choose>
		     <xsl:when test="number($firstPass)=1 or string-length($subst) = 0"><xsl:value-of select="concat('.FRX',$thisReport,'_',$thisItem)"/></xsl:when>
		     <xsl:otherwise>.<xsl:value-of select="$subst"/></xsl:otherwise>
		     </xsl:choose>
		  </xsl:template>
		  <xsl:template match="VFPFRXLayoutObject" mode="imagestyles">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="firstPass" select="1"/>
		     <xsl:call-template name="getCSSName">
		     <xsl:with-param name="thisReport" select="$thisReport"/>
		     <xsl:with-param name="thisItem" select="frxrecno"/>
		     <xsl:with-param name="firstPass" select="$firstPass"/>
		     </xsl:call-template>{
		  position: absolute;overflow: hidden;width: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="width div $FRUs"/></xsl:call-template>in;height: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="height div $FRUs"/></xsl:call-template>in;
		  }
		  <!-- <xsl:if test="offset=0">
		left: <xsl:value-of select="hpos div $FRUs"/>in; 
		</xsl:if>
		<xsl:if test="offset=2">
		left: <xsl:value-of select="hpos div $FRUs"/>in; 
		</xsl:if> -->
		 </xsl:template>
		  <xsl:template match="VFPFRXLayoutObject" mode="shapestyles">
		    <xsl:param name="thisReport" select="1"/>
		   <xsl:param name="firstPass" select="1"/>
		     <xsl:call-template name="getCSSName">
		     <xsl:with-param name="thisReport" select="$thisReport"/>
		     <xsl:with-param name="thisItem" select="frxrecno"/>
		     <xsl:with-param name="firstPass" select="$firstPass"/>
		     </xsl:call-template>{
		   position: absolute ;font-size:1pt; border: <xsl:value-of select="pensize"/>px <xsl:call-template name="pattern"/><xsl:call-template name="pencolor"/>;<xsl:if test="(mode=0 and not(fillpat=0)) or (mode=1 and fillpat=1)">background-color:<xsl:call-template name="fillcolor"/>;</xsl:if>width: <xsl:call-template name="setPrecision"> <xsl:with-param name="theNumber" select="width div $FRUs"/></xsl:call-template>in;left: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="hpos div $FRUs"/></xsl:call-template>in;
		      }
		      <!--    <xsl:if test="stretch='true'">
		overflow: auto;
		   </xsl:if> -->
		  </xsl:template>
		  <xsl:template match="VFPFRXLayoutObject" mode="textstyles">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="firstPass" select="1"/>
		     <xsl:call-template name="getCSSName">
		     <xsl:with-param name="thisReport" select="$thisReport"/>
		     <xsl:with-param name="thisItem" select="frxrecno"/>
		     <xsl:with-param name="firstPass" select="$firstPass"/>
		     </xsl:call-template>{
		  <xsl:call-template name="getTextAlignment"/>vertical-align: top; font-family: "<xsl:value-of select="fontface"/>"; font-size: <xsl:value-of select="fontsize"/>pt; border: 0px none; padding: 0px; margin: 0px;<xsl:call-template name="getFontAttributes"/>color:<xsl:call-template name="pencolor"/>;<xsl:choose>
		      <xsl:when test="mode mod 2 = 1">background-color:transparent;</xsl:when>
		      <xsl:otherwise>background-color: <xsl:call-template name="fillcolor"/>;</xsl:otherwise>
		    </xsl:choose><xsl:choose>
		      <xsl:when test="stretch='true' and objtype=8 and $useTextAreaForStretchingText=1 and $hideScrollbarsForTextAreas=1"> overflow:hidden;margin-top:4px;</xsl:when>
		      <xsl:when test="stretch='true' and objtype=8 and $useTextAreaForStretchingText=1"> overflow: auto;margin-top:4px;</xsl:when>
		      <xsl:otherwise>overflow:hidden;</xsl:otherwise>
		    </xsl:choose> position: absolute;
		   }   
		    <!-- tbd, make vertical-align more dynamic -->  
		  </xsl:template>
		  <xsl:template match="VFPFRXLayoutObject" mode="linestyles">
		    <xsl:param name="thisReport" select="1"/>
		   <xsl:param name="firstPass" select="1"/>
		     <xsl:call-template name="getCSSName">
		     <xsl:with-param name="thisReport" select="$thisReport"/>
		     <xsl:with-param name="thisItem" select="frxrecno"/>
		      <xsl:with-param name="firstPass" select="$firstPass"/>
		     </xsl:call-template>{
		   position:absolute;font-size:1pt;border: <xsl:value-of select="pensize"/>px <xsl:call-template name="pattern"/><xsl:call-template name="pencolor"/>;left: <xsl:value-of select="hpos div $FRUs"/>in;
		      <xsl:choose>
		      <xsl:when test="height &lt; width"> width: <xsl:value-of select="width div $FRUs"/>in;
		  height: <xsl:value-of select="floor(height div $FRUsInPixelsat96DPI)"/>px; margin: 0px;</xsl:when>
		      <xsl:otherwise>  height: <xsl:value-of select="height div $FRUs"/>in;
		  width: <xsl:value-of select="floor(width div $FRUsInPixelsat96DPI)"/>px;  </xsl:otherwise>
		    </xsl:choose>
		   }
		  </xsl:template>
		  <xsl:template name="pattern">
		    <xsl:choose>
		      <xsl:when test="penpat=0"> none </xsl:when>
		      <xsl:when test="penpat=1"> dotted </xsl:when>
		      <xsl:when test="penpat=2"> dashed </xsl:when>
		      <xsl:otherwise> solid </xsl:otherwise>
		    </xsl:choose>
		  </xsl:template>
		  <xsl:template name="pencolor">#<xsl:call-template name="getHexColorValue">
		      <xsl:with-param name="theNumber" select="penred"/>
		    </xsl:call-template>
		    <xsl:call-template name="getHexColorValue">
		      <xsl:with-param name="theNumber" select="pengreen"/>
		    </xsl:call-template>
		    <xsl:call-template name="getHexColorValue">
		      <xsl:with-param name="theNumber" select="penblue"/>
		    </xsl:call-template>
		  </xsl:template>
		  <xsl:template name="fillcolor">#<xsl:call-template name="getHexColorValue">
		      <xsl:with-param name="theNumber" select="fillred"/>
		      <xsl:with-param name="fill" select="1"/>
		    </xsl:call-template>
		    <xsl:call-template name="getHexColorValue">
		      <xsl:with-param name="theNumber" select="fillgreen"/>
		      <xsl:with-param name="fill" select="1"/>
		    </xsl:call-template>
		    <xsl:call-template name="getHexColorValue">
		      <xsl:with-param name="theNumber" select="fillblue"/>
		      <xsl:with-param name="fill" select="1"/>
		    </xsl:call-template>
		  </xsl:template>
		  <xsl:template name="getFontAttributes">
		    <xsl:param name="theStyles" select="0"/>
		    <xsl:choose>
		      <xsl:when test="fontbold='true'">font-weight: bold;</xsl:when>
		      <xsl:otherwise>font-weight: normal;</xsl:otherwise>
		    </xsl:choose>
		    <xsl:if test="fontstrikethrough='true' or fontunderline='true'">text-decoration: <xsl:if test="fontstrikethrough='true'">line-through </xsl:if>
		      <xsl:if test="fontunderline='true'">underline</xsl:if>;</xsl:if>
		    <xsl:if test="fontitalic='true'">font-style: italic;</xsl:if>
		  </xsl:template>
		  <xsl:template name="getHexColorValue">
		    <xsl:param name="theNumber" select="-1"/>
		    <xsl:param name="fill" select="0"/>
		    <xsl:variable name="useNumber">
		      <xsl:choose>
		        <xsl:when test="$fill=1 and fillpat &gt; 1 and ((fillred+fillblue+fillgreen) &lt; $fillPatternShade)">
		          <xsl:choose>
		            <xsl:when test="($fillPatternOffset + $theNumber) &gt; 254">255</xsl:when>
		            <xsl:otherwise>
		              <xsl:value-of select="$fillPatternOffset + $theNumber"/>
		            </xsl:otherwise>
		          </xsl:choose>
		        </xsl:when>
		        <xsl:otherwise>
		          <xsl:value-of select="$theNumber"/>
		        </xsl:otherwise>
		      </xsl:choose>
		    </xsl:variable>
		    <xsl:choose>
		      <xsl:when test="$useNumber=-1 and $fill=1">FF</xsl:when>
		      <xsl:when test="$useNumber=-1">00</xsl:when>
		      <xsl:otherwise>
		        <xsl:call-template name="getHexForNumber">
		          <xsl:with-param name="theNumber" select="floor($useNumber div 16)"/>
		        </xsl:call-template>
		        <xsl:call-template name="getHexForNumber">
		          <xsl:with-param name="theNumber" select="round($useNumber mod 16)"/>
		        </xsl:call-template>
		      </xsl:otherwise>
		    </xsl:choose>
		  </xsl:template>
		  <xsl:template name="setPrecision">
		    <xsl:param name="theNumber" select="-1"/>
		    <xsl:choose>
		      <xsl:when test="$numberPrecision = -1 or not(contains(string($theNumber),'.'))">
		        <xsl:value-of select="$theNumber"/>
		      </xsl:when>
		      <xsl:when test="$numberPrecision &gt; 0">
		        <!--        <xsl:value-of select="concat(string(floor($theNumber)),'.',substring(substring-after(string($theNumber),'.'),1,$numberPrecision))"/>  -->
		        <xsl:value-of select="format-number($theNumber,concat('##0.',$zeros))"/>
		      </xsl:when>
		      <xsl:when test="$numberPrecision=0">
		        <xsl:value-of select="round($theNumber)"/>
		      </xsl:when>
		      <xsl:otherwise>
		        <!-- shouldn't happen-->
		        <xsl:value-of select="$theNumber"/>
		      </xsl:otherwise>
		    </xsl:choose>
		  </xsl:template>
		  <xsl:template name="getHexForNumber">
		    <xsl:param name="theNumber" select="-1"/>
		    <xsl:choose>
		      <xsl:when test="$theNumber=-1">00</xsl:when>
		      <xsl:when test="$theNumber &lt; 10">
		        <xsl:value-of select="$theNumber"/>
		      </xsl:when>
		      <xsl:when test="$theNumber = 10">A</xsl:when>
		      <xsl:when test="$theNumber = 11">B</xsl:when>
		      <xsl:when test="$theNumber = 12">C</xsl:when>
		      <xsl:when test="$theNumber = 13">D</xsl:when>
		      <xsl:when test="$theNumber = 14">E</xsl:when>
		      <xsl:when test="$theNumber = 15">F</xsl:when>
		    </xsl:choose>
		  </xsl:template>
		  <xsl:template name="getTextAlignment">text-align:<xsl:choose>
		      <xsl:when test="objtype=5"><!-- picture field empty for left (default), @I for centered and @J right -->
		        <xsl:choose>
		          <xsl:when test="string-length(picture) = 0">left;</xsl:when>
		          <xsl:when test="contains(picture,'@J')">right;</xsl:when>
		          <xsl:otherwise>center;</xsl:otherwise>
		        </xsl:choose>
		      </xsl:when>
		      <xsl:otherwise>
		        <xsl:choose>
		          <xsl:when test="offset=0">left;</xsl:when>
		          <xsl:when test="offset=1">right;</xsl:when>
		          <xsl:otherwise>center;</xsl:otherwise>
		        </xsl:choose>
		      </xsl:otherwise>
		    </xsl:choose>
		    <!-- don't include direction at all if you want context -->
		    <xsl:if test="mode &lt; 4">direction:<xsl:choose>
		        <xsl:when test="mode &gt; 1">rtl;</xsl:when>
		        <xsl:otherwise>ltr;</xsl:otherwise>
		      </xsl:choose>
		    </xsl:if>
		  </xsl:template>
		  <xsl:template name="ExternalStyleSheets">
		    <xsl:param name="thisReportNode" select="/Reports/VFP-Report[1]"/>
		    <xsl:param name="thisReportID" select="'this report'"/>
		   <xsl:if test="count($thisReportNode/Run/property[@id='css_sheet']) &gt; 0">
		   <xsl:comment>
		   External stylesheet(s) for <xsl:value-of select="$thisReportID"/>
		   </xsl:comment>
		   <xsl:for-each select="$thisReportNode/Run/property[@id='css_sheet']">
		      <link type="text/css" href="{./text()}" rel="stylesheet"/>
		   </xsl:for-each>
		   </xsl:if>   
		  </xsl:template>
		  <xsl:template name="DocumentStyles">
		  <xsl:comment>Global document styles, if any</xsl:comment>
		    <style type="text/css">
		     <xsl:comment><xsl:if test="/Reports/VFP-Report[1]/VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=1 and (fontcharset=177 or fontcharset=178)]">
		     <xsl:if test="number($noBody)!=1">html{direction:rtl;} 
		     body{direction:rtl;}</xsl:if>
		     div{direction:rtl;} 
		     span{direction:rtl;}
		     </xsl:if>
		     </xsl:comment>
		    </style>
		  
		  </xsl:template>
		  <xsl:template name="Styles">
		    <xsl:param name="thisReport" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:comment>
		    Styles for report # <xsl:value-of select="$thisReport"/>  in this run, 
		    <xsl:value-of select="$thisReportID"/>
		    </xsl:comment>
		    
		    <style type="text/css">
		    
		      <xsl:comment>
		    
		        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=6]" mode="linestyles">
		          <xsl:with-param name="thisReport" select="$thisReport"/>
		        </xsl:apply-templates>
		      
		      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=6]">
		        <xsl:variable name="frxrecno" select="frxrecno"/>
		        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
		              <xsl:apply-templates select="." mode="linestyles">
		              <xsl:with-param name="thisReport" select="$thisReport"/>
		                 <xsl:with-param name="firstPass" select="0"/>
		              </xsl:apply-templates>
		        </xsl:if>
		      </xsl:for-each>
		        
		        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=7]" mode="shapestyles">
		          <xsl:with-param name="thisReport" select="$thisReport"/>
		        </xsl:apply-templates>
		
		      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=7]">
		         <xsl:variable name="frxrecno" select="frxrecno"/>
		        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
		              <xsl:apply-templates select="." mode="shapestyles">
		              <xsl:with-param name="thisReport" select="$thisReport"/>
		                 <xsl:with-param name="firstPass" select="0"/>
		              </xsl:apply-templates>
		        </xsl:if>
		      </xsl:for-each>
		
		        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[contains('|5|8|',concat('|',./objtype,'|'))]" mode="textstyles">
		          <xsl:with-param name="thisReport" select="$thisReport"/>
		        </xsl:apply-templates>
		
		      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[contains('|5|8|',concat('|',./objtype,'|'))]">
		        <xsl:variable name="frxrecno" select="frxrecno"/>
		        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
		              <xsl:apply-templates select="." mode="textstyles">
		              <xsl:with-param name="thisReport" select="$thisReport"/>
		                 <xsl:with-param name="firstPass" select="0"/>
		              </xsl:apply-templates>
		        </xsl:if>
		      </xsl:for-each>
		        
		        <xsl:apply-templates select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=17]" mode="imagestyles">
		          <xsl:with-param name="thisReport" select="$thisReport"/>
		        </xsl:apply-templates>
		
		      <xsl:for-each select="./VFP-RDL/VFPDataSet/VFPFRXLayoutObject[objtype=17]">
		        <xsl:variable name="frxrecno" select="frxrecno"/>
		        <xsl:if test="/Reports/VFP-Report[$thisReport]/Data/*/*[@id=$frxrecno]/@css">
		              <xsl:apply-templates select="." mode="imagestyles">
		              <xsl:with-param name="thisReport" select="$thisReport"/>
		                 <xsl:with-param name="firstPass" select="0"/>
		              </xsl:apply-templates>
		        </xsl:if>
		      </xsl:for-each>
		
		    
		      </xsl:comment>
		    
		    </style>
		
		   <xsl:call-template name="ExternalStyleSheets">
		   <xsl:with-param name="thisReportNode" select="/Reports/VFP-Report[$thisReport]"/> 
		   <xsl:with-param name="thisReportID" select="$thisReportID"/>
		   </xsl:call-template>
		
		  </xsl:template>
		  <xsl:template name="replaceText">
		    <xsl:choose>
		      <xsl:when test="$useTextAreaForStretchingText=1">
		        <xsl:value-of select="."/>
		      </xsl:when>
		      <xsl:otherwise>
		        <xsl:call-template name="replaceWhiteSpace">
		          <xsl:with-param name="string" select="."/>
		        </xsl:call-template>
		      </xsl:otherwise>
		    </xsl:choose>
		  </xsl:template>
		  <xsl:template name="renderPicture">
		  <xsl:param name="thisReportID"/>
		  <xsl:param name="thisID"/>
		    <img>
		      <xsl:attribute name="alt"><xsl:choose><xsl:when test="@alt"><xsl:value-of select="@alt"/></xsl:when><xsl:otherwise><xsl:value-of select="key('Layout',concat($thisID, $thisReportID))/unpathedimg"/></xsl:otherwise></xsl:choose></xsl:attribute>
		      <xsl:variable name="srcImage">
		   <xsl:choose>
		          <xsl:when test="@img and $externalFileLocation">
		            <xsl:value-of select="translate(concat($externalFileLocation,@img),'\','/')"/>
		          </xsl:when>
		          <xsl:when test="@img and not(contains(./@img,':'))">
		               <xsl:value-of select="translate(@img,'\','/')"/>
		          </xsl:when>
		          <xsl:when test="@img">
		            <xsl:value-of select="concat('file://',translate(@img,'\','/'))"/>
		          </xsl:when>
		          <xsl:when test="$copyImageFiles = '1'">
		            <xsl:value-of select="translate(concat($externalFileLocation,key('Layout',concat($thisID, $thisReportID))/unpathedimg),'\','/')"/>
		          </xsl:when>
		          <xsl:when test="string-length(./text()) &gt; 0 and not(contains(./text(),':')) ">
		            <xsl:value-of select="translate(./text(),'\','/')"/>
		          </xsl:when>
		          <xsl:when test="string-length(./text()) &gt; 0">
		            <xsl:value-of select="concat('file://',translate(./text(),'\','/'))"/>
		          </xsl:when>
		          <xsl:otherwise>
		            <xsl:value-of select="concat('file://',translate(key('Layout',concat($thisID, $thisReportID))/pathedimg,'\','/'))"/>
		          </xsl:otherwise>
		        </xsl:choose>
		      </xsl:variable>
		      <xsl:attribute name="src"><xsl:value-of select="$srcImage"/></xsl:attribute>
		      <xsl:attribute name="style"><xsl:variable name="imgGeneral" select="key('Layout',concat($thisID, $thisReportID))"/><xsl:choose><xsl:when test="$imgGeneral/general='0' "><!-- clip top, right, bottom, left -->
		 clip: rect(0in,<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in,<xsl:value-of select="@h div $printDPI"/>in,0in);
		 </xsl:when><xsl:when test="$imgGeneral/general='1'"><!-- scale and retain --><xsl:choose><xsl:when test="@h &gt; @w">
		 width:100%;
		 </xsl:when><xsl:otherwise>
		 height:100%;
		 </xsl:otherwise></xsl:choose></xsl:when><xsl:otherwise><!-- stretch to fill frame -->
		 height: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@h div $printDPI"/></xsl:call-template>in;    
		width: <xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in;    
		 </xsl:otherwise></xsl:choose></xsl:attribute>
		    </img>
		  </xsl:template>
		  <xsl:template name="addClassAttribute">
		  <xsl:param name="item" select="."/>
		  <xsl:param name="default" select="''"/>
		  <xsl:attribute name="class"><xsl:choose>
		  <xsl:when test="string-length($item/@CSS) &gt; 0">
		  <xsl:value-of select="$item/@CSS"/>
		  </xsl:when>
		  <xsl:when test="string-length($item/@css) = 0">
		  <xsl:value-of select="$default"/>
		  </xsl:when>
		  <xsl:otherwise>
		  <xsl:value-of select="$item/@css"/>
		  </xsl:otherwise>
		  </xsl:choose></xsl:attribute>
		  </xsl:template>
		  <xsl:template name="addTitleAttribute">
		    <xsl:param name="item" select="."/>
		    <xsl:if test="string-length($item/@title) &gt; 0">
		      <xsl:attribute name="title"><xsl:value-of select="$item/@title"/></xsl:attribute>
		    </xsl:if>
		  </xsl:template>
		  <xsl:template name="addAnchor">
		    <xsl:param name="item" select="."/>
		    <xsl:if test="string-length($item/@anchor) &gt; 0">
		      <a>
		     <xsl:attribute name="{$anchorAttr}"><xsl:value-of select="$item/@anchor"/></xsl:attribute> 
		        <xsl:text disable-output-escaping="yes">&amp;nbsp;</xsl:text>
		      </a>
		    </xsl:if>
		  </xsl:template>
		  <xsl:template name="addStyleAttribute">
		    <xsl:param name="topOffset" select="0"/>
		    <xsl:param name="thisZ" select="1"/>
		    <xsl:param name="thisReportID"/>
		    <xsl:param name="thisID"/>
		    <xsl:param name="styleType" select="'Div'"/>
		<!-- do NOT mess around with the white space in here, even though it 
		looks ugly the way it is!! -->
		<xsl:attribute name="style">z-Index:<xsl:value-of select="$thisZ"/>;left:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@l div $printDPI"/></xsl:call-template>in;
		top:<xsl:choose>
		  <xsl:when test="styleType='TextArea'"><xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="((@t  + $topOffset) div $printDPI) - .1"/></xsl:call-template></xsl:when>
		  <xsl:otherwise><xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="(@t +$topOffset) div $printDPI"/></xsl:call-template></xsl:otherwise>
		</xsl:choose>in;<xsl:choose>
		  <xsl:when test="$styleType='VR'">width:0in;</xsl:when>
		  <xsl:when test="$styleType='TextArea'">width:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in;</xsl:when>
		<xsl:when test="$styleType='Div'">width:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@w div $printDPI"/></xsl:call-template>in;height:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@h div $printDPI"/></xsl:call-template>in;</xsl:when></xsl:choose><xsl:if test="not($styleType='Div')">height:<xsl:call-template name="setPrecision"><xsl:with-param name="theNumber" select="@h div $printDPI"/></xsl:call-template>in;</xsl:if>
		<xsl:if test="$useDynamicTextAttributes=1 and key('Layout',concat($thisID,$thisReportID))[objtype=5 or objtype=8]">
		<xsl:call-template name="addDynamicTextStyleAttributes"/>
		</xsl:if>
		</xsl:attribute>
		    </xsl:template>
		    <xsl:template name="addDynamicTextStyleAttributes">
		  <!-- dynamic values for font, omit these attributes if they don't appear on each object-->
		  <xsl:if test="@FNAME">
		    font-family:'<xsl:value-of select="@FNAME"/>';font-size:<xsl:value-of select="@FSIZE"/>pt;
		    <xsl:if test="((@FSTYLE div 128) mod 2 = 1) or ( (@FSTYLE div 4) mod 2 = 1)">text-decoration:<xsl:if test="((@FSTYLE div 128) mod 2 = 1)">line-through</xsl:if><xsl:if test="( (@FSTYLE div 8) mod 2 = 1)">underline</xsl:if>;</xsl:if>
		    font-weight:<xsl:choose><xsl:when test="@FSTYLE mod 2 = 1">bold</xsl:when><xsl:otherwise>normal</xsl:otherwise></xsl:choose>;
		    font-style:<xsl:choose><xsl:when test="(@FSTYLE div 2) mod 2 =1">italic</xsl:when><xsl:otherwise>normal</xsl:otherwise></xsl:choose>;
		   background-color:<xsl:call-template name="getAlphaColor">
		   <xsl:with-param name="alpha" select="@FA"/>
		   <xsl:with-param name="r" select="@FR"/>
		   <xsl:with-param name="g" select="@FG"/>
		   <xsl:with-param name="b" select="@FB"/>
		   </xsl:call-template>;color:<xsl:call-template name="getAlphaColor"/>;
		    </xsl:if>
		    </xsl:template>
		
		   <xsl:template name="getAlphaColor">
		   <xsl:param name="alpha" select="@PA"/>
		   <xsl:param name="r" select="@PR"/>
		   <xsl:param name="g" select="@PG"/>
		   <xsl:param name="b" select="@PB"/>
		   <xsl:choose>
		   <xsl:when test="$alpha=0">transparent</xsl:when>
		   <xsl:when test="$alpha=255 or ($r+$g+$b &gt; $fieldAlphaOpacityShade)"><xsl:value-of select="concat('rgb(',$r,',',$g,',',$b,')')"/></xsl:when>
		   <xsl:otherwise><xsl:value-of select="concat('rgb(',$r+$fieldAlphaOpacityOffset,',',$g+$fieldAlphaOpacityOffset,',',$b+$fieldAlphaOpacityOffset,')')"/></xsl:otherwise>
		   </xsl:choose>
		
		
		   </xsl:template>
		  
		    <xsl:template name="replaceWhiteSpace">
		    <xsl:param name="string" select="."/>
		    <xsl:choose>
		      <xsl:when test="contains($string,'&#xA;')">
		        <xsl:call-template name="replaceWhiteSpace">
		          <xsl:with-param name="string" select="substring-before($string, '&#xA;')"/>
		        </xsl:call-template>
		        <br/>
		        <xsl:call-template name="replaceWhiteSpace">
		          <xsl:with-param name="string" select="substring-after($string, '&#xA;')"/>
		        </xsl:call-template>
		      </xsl:when>
		      <xsl:otherwise>
		        <xsl:value-of select="$string"/>
		      </xsl:otherwise>
		    </xsl:choose>
		  </xsl:template>
		  <xsl:template name="Script">
		    <script language="JavaScript">
		      <xsl:comment>
		     //TBD
		      </xsl:comment>
		    </script>
		  </xsl:template>
		  <xsl:template match="*|@*" mode="debug">
		   <xsl:copy-of select="."/>
		  </xsl:template> 
		</xsl:stylesheet>
		
		
		ENDTEXT
		SET TEXTMERGE OFF
		SET TEXTMERGE TO
		
		RETURN m.lcResult
	ENDPROC

	PROCEDURE getrawformattinginfo
		LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
		LOCAL m.lcInfo, m.lcVal, m.liRecno
		m.lcInfo = DODEFAULT(m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType)
		THIS.setFRXDataSession()
		m.liRecno = RECNO("FRX")
		IF USED(THIS.MemberDataAlias) AND ;
		   SEEK(m.liRecno,THIS.MemberDataAlias,"FRXRecno")          
		   SELECT (THIS.MemberDataAlias)
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSOVERRIDE
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   SELECT (THIS.MemberDataAlias)         
		   IF NOT EMPTY(m.lcVal)
		      m.lcInfo = m.lcInfo + " "+THIS.cssClassOverrideAttr+"='"+m.lcVal+"'"      
		   ELSE
		      * try again with other css class attribute
		      LOCATE FOR FRXRecno = m.liRecno AND ;
		             Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		             Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		             ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSEXTEND
		      IF FOUND()
		         IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		            m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		         ELSE
		            m.lcVal = Execute
		         ENDIF         
		      ENDIF
		      IF NOT EMPTY(m.lcVal)
		         m.lcInfo = m.lcInfo + " "+THIS.cssClassAttr+"='"+m.lcVal+"'"            
		      ENDIF   
		   ENDIF
		   SELECT (THIS.MemberDataAlias)         
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMHREF
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   IF NOT EMPTY(m.lcVal)
		      m.lcInfo = m.lcInfo + " "+ ;
		        THIS.linkAttr +"='"+ ;
		        THIS.pathEncode(m.lcVal, .T.)+"'"      
		   ENDIF
		   SELECT (THIS.MemberDataAlias)         
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMTITLE
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   IF NOT EMPTY(m.lcVal)
		      m.lcInfo = m.lcInfo + " "+THIS.titleAttr +"='"+m.lcVal+"'"      
		   ENDIF
		   SELECT (THIS.MemberDataAlias)         
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMANCHOR       
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   IF NOT EMPTY(m.lcVal)
		      m.lcInfo = m.lcInfo + " "+ ;
		                 THIS.anchorAttr +"='"+ ;
		                 THIS.pathEncode(m.lcVal, .T.)+"'"
		   ENDIF
		   SELECT FRX
		ENDIF
		
		RETURN m.lcInfo
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   THIS.AppName = OUTPUTHTML_APPNAME_LOC
		ELSE
		   RETURN .F.   
		ENDIF
		
		RETURN NOT THIS.HadError
	ENDPROC

	PROCEDURE linkattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
		   AND NOT (m.vNewVal == THIS.linkAttr)
		   THIS.linkAttr = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
		
		
		
		
		
	ENDPROC

	PROCEDURE pathencode		&& Encodes sections of a URL path re-creates the URL from the elements, and optionally re-encodes suitable for including in well-formed XML.
		LPARAMETERS m.tcVal, m.tlXMLEncode
		LOCAL m.lcVal, m.lcTempVal, m.laVals[1], m.liIndex, m.liSeparators
		m.lcVal = ALLTRIM(CHRTRAN(m.tcVal,"\","/"))
		* default XSLT would take care of the above anyway, but 
		* no harm in doing it here
		DO CASE
		CASE LEN(m.lcVal) = 0
		   * nothing
		CASE AT("/",m.lcVal) > 0
		   m.lcTempVal = ""
		   m.liSeparators = ALINES(m.laVals,m.lcVal,0,"/")
		   FOR m.liIndex = 1 TO m.liSeparators
		      IF ":" $ m.laVals[m.liIndex]
		         m.lcTempVal = m.lcTempVal + m.laVals[m.liIndex]
		      ELSE   
		         m.lcTempVal = m.lcTempVal + ;
		                       THIS.urlStringEncode(m.laVals[m.liIndex])
		      ENDIF                 
		      IF m.liIndex < m.liSeparators
		         m.lcTempVal = m.lcTempVal + "/"  
		      ENDIF
		   ENDFOR
		   IF RIGHT(m.lcVal,1) = "/"
		      m.lcTempVal = m.lcTempVal + "/"  
		   ENDIF
		   m.lcVal = m.lcTempVal
		OTHERWISE
		   m.lcVal = THIS.urlStringEncode(m.lcVal)
		ENDCASE
		
		#IF OUTPUTXML = OUTPUTXML_RAW
		   IF m.tlXMLEncode
		      * the result is going to an XML document
		      m.lcVal = THIS.xmlRawConv(m.lcVal) 
		   ENDIF   
		#ENDIF   
		
		RETURN m.lcVal
		
	ENDPROC

	PROCEDURE setdomformattinginfo
		LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
		LOCAL  m.lcVal, m.liRecno
		DODEFAULT( m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType)
		THIS.setFRXDataSession()
		m.liRecno = RECNO("FRX")
		IF USED(THIS.MemberDataAlias) AND ;
		   SEEK(m.liRecno,THIS.MemberDataAlias,"FRXRecno")          
		   SELECT (THIS.MemberDataAlias)
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSOVERRIDE
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   SELECT (THIS.MemberDataAlias)         
		   IF NOT EMPTY(m.lcVal)
		      m.toNode.SetAttribute(THIS.cssClassOverrideAttr,m.lcVal )                  
		   ELSE
		      * try again with other css class attribute
		      LOCATE FOR FRXRecno = m.liRecno AND ;
		             Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		             Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		             ExecWhen =  FRX_BLDR_ADVPROP_HTML_CSS_CLASSEXTEND
		      IF FOUND()
		         IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		            m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		         ELSE
		            m.lcVal = Execute
		         ENDIF         
		      ENDIF
		      IF NOT EMPTY(m.lcVal)
		         m.toNode.SetAttribute(THIS.cssClassAttr,m.lcVal )                  
		      ENDIF   
		   ENDIF
		   SELECT (THIS.MemberDataAlias)         
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMHREF
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   IF NOT EMPTY(m.lcVal)
		      m.toNode.SetAttribute(THIS.linkAttr,THIS.pathEncode(m.lcVal))
		   ENDIF
		   SELECT (THIS.MemberDataAlias)         
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMTITLE
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   IF NOT EMPTY(m.lcVal)
		      m.toNode.SetAttribute(THIS.titleAttr,m.lcVal )                  
		   ENDIF
		   SELECT (THIS.MemberDataAlias)         
		   m.lcVal = ""
		   LOCATE FOR FRXRecno = m.liRecno AND ;
		          Type = FRX_BLDR_MEMBERDATATYPE  AND  ;
		          Name = FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		          ExecWhen =  FRX_BLDR_ADVPROP_HTML_ITEMANCHOR       
		   IF FOUND()
		      IF VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		         m.lcVal = TRANSFORM(THIS.evaluateUserExpression(Execute))
		      ELSE
		         m.lcVal = Execute
		      ENDIF         
		   ENDIF      
		   IF NOT EMPTY(m.lcVal)
		      m.toNode.SetAttribute(THIS.anchorAttr,THIS.pathEncode(m.lcVal) )                  
		   ENDIF
		   SELECT FRX
		ENDIF
		
		
	ENDPROC

	PROCEDURE titleattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
		   AND NOT (m.vNewVal == THIS.titleAttr )
		   THIS.titleAttr  = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
		
		
		
		
		
	ENDPROC

	PROCEDURE urlstringencode		&& Encode string for purposes of using it as part of a link in an HTML page.
		LPARAMETER m.tcValue, m.tlEncodeURLControlChars, m.tlEncodeSpace
		* Thanks to Rick Strahl and West Wind for help and advice!
		IF VARTYPE(m.tcValue) # "C" 
		   RETURN ""
		ENDIF   
		LOCAL m.lcResult, m.lcChar, m.ii, m.lcOKChars
		
		m.lcResult=""
		m.lcOKChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
		
		IF NOT m.tlEncodeURLControlChars
		   * by default, we also exempt chars that might
		   * indicate an anchor or a query string element
		   m.lcOKChars = m.lcOKChars + ".?=&#"
		ENDIF
		
		FOR m.ii=1 TO LEN(m.tcValue)
		   m.lcChar = SUBSTR(m.tcValue,m.ii,1)
		   IF ATC(m.lcChar,m.lcOKChars) > 0
		      m.lcResult=m.lcResult + m.lcChar
		      LOOP
		   ENDIF
		   IF m.lcChar=" " AND NOT m.tlEncodeSpace
		      m.lcResult = m.lcResult + "+"
		      LOOP
		   ENDIF
		   m.lcResult = m.lcResult + "%" + RIGHT(TRANSFORM(ASC(m.lcChar),"@0"),2)
		ENDFOR 
		
		RETURN m.lcResult
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS updatelistener AS _reportlistener OF "_reportlistener.vcx" 		&& Provides user feedback while report output is generated.
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: createtherm		&& Creates and configures the "update" feedback window.
		*m: getparentwindowref		&& Provides a window reference for the top form in which the user feedback window should appear.
		*m: getreportscopedriver		&& Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
		*m: includeseconds_assign
		*m: initstatustext_assign
		*m: prepassstatustext_assign
		*m: resetuserfeedback		&& Sets user feedback to an initialized state.
		*m: runstatustext_assign
		*m: secondstext_assign
		*m: setthermformcaption		&& Sets the user feedback window title using the ThermFormCaption property.
		*m: synchstatus		&& Compares driving recno with currrently-saved information to evaluate need to update user feedback.
		*m: thermcaption_assign
		*m: thermformcaption_assign
		*m: thermformheight_assign
		*m: thermformwidth_assign
		*m: thermmargin_assign
		*m: thermprecision_assign
		*p: currentrecord		&& Holds the current record relative to the recordtotal in scope for the current report run.
		*p: designateddriver		&& Original selected alias for the report.
		*p: drivingaliascurrentrecno		&& Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
		*p: escapereference		&& Holds the name of a public variable used to facilitate interrupting a report run.
		*p: frxbandrecno		&& Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
		*p: includeseconds		&& Indicates whether the default user feedback message should include timing data.
		*p: initstatustext		&& Provides the user message shown when user feedback first appears.
		*p: onescapecommand		&& Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
		*p: percentdone		&& Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
		*p: prepassstatustext		&& User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
		*p: reportstartrundatetime		&& A datetime value indicating when the last report generation run began.
		*p: reportstoprundatetime		&& A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
		*p: runstatustext		&& Provides a user message shown during the course of a report run.
		*p: secondstext		&& Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
		*p: setescape		&& Saves the state of SET ESCAPE previous to the report run, for later restoration.
		*p: setnotifycursor		&& Saves the state of SET NOTIFY CURSOR previous to the report run, for later restoration.
		*p: successorsys2024		&& Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
		*p: thermcaption		&& Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
		*p: thermform		&& Holds an object reference to the user feedback form.
		*p: thermformcaption		&& Holds the value used to set the title of the user feedback form.
		*p: thermformheight		&& Holds the height of the user feedback form, in pixels.
		*p: thermformwidth		&& Holds the width of the user feedback form, in pixels.
		*p: thermmargin		&& Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
		*p: thermprecision		&& The number of places (precision) to use for evaluating and (by default) showing the percentage done.
	*</DefinedPropArrayMethod>

	PROTECTED currentrecord,designateddriver,drivingaliascurrentrecno,escapereference,frxbandrecno,onescapecommand,percentdone,setescape,setnotifycursor,successorsys2024,thermform
	currentrecord = (0)		&& Holds the current record relative to the recordtotal in scope for the current report run.
	designateddriver = ("")		&& Original selected alias for the report.
	drivingaliascurrentrecno = (0)		&& Holds the RECNO() value in the cursor driving the report run, to assist in determining when to trigger a change in the user feedback.
	escapereference = ("")		&& Holds the name of a public variable used to facilitate interrupting a report run.
	frxbandrecno = (0)		&& Holds the RECNO() of the band-describing record in the FRX table this class has determined is optimal for triggering a change in user feedback during a report run.
	FRXDataSession = -1
	includeseconds = .T.		&& Indicates whether the default user feedback message should include timing data.
	initstatustext = ("")		&& Provides the user message shown when user feedback first appears.
	Name = "updatelistener"
	onescapecommand = ("")		&& Saves the user's previous ON ESCAPE command, if any, for restoration after the report run.
	percentdone = (0)		&& Calculation of the ratio between the number of records, or pages, already generated to the number of records, or pages, in the total report.
	prepassstatustext = ("")		&& User feedback message for use when the report is in a pre-generation pass to calculate _RECORDTOTAL.
	reportstartrundatetime = (DTOT({}))		&& A datetime value indicating when the last report generation run began.
	reportstoprundatetime = (DTOT({}))		&& A datetime value for use at the conclusion of a report run, empty during a report, storing when the last report generation run ended.
	runstatustext = ("")		&& Provides a user message shown during the course of a report run.
	secondstext = ("secs")		&& Provides the text message included to describe the time value in the default user feedback message during a report, when IncludeSeconds is .T.
	successorsys2024 = ("N")		&& Allows UpdateListener to "remember" if it has cancelled a report between the two report passes if it is in a two-pass process report, if it is a Successor.
	thermcaption = <fb2p_value>[m.cMessage+ " "+ TRANSFORM(THIS.PercentDone,"999"+IIF(THIS.ThermPrecision=0,"","."+REPL("9",THIS.ThermPrecision))) + "%" + IIF(NOT THIS.IncludeSeconds, "" , " "+TRANSFORM(IIF(THIS.IsRunning,DATETIME(), THIS.ReportStopRunDateTime)-THIS.ReportStartRunDateTime)+" " + THIS.SecondsText)]</fb2p_value>		&& Holds an evaluated expression for use in the user feedback message shown during a report run. If this expression includes "cMessage", the contents of the argument provided to DoStatus will be included in the result of the evaluation.
	thermform = .NULL.		&& Holds an object reference to the user feedback form.
	thermformcaption = ("")		&& Holds the value used to set the title of the user feedback form.
	thermformheight = 40		&& Holds the height of the user feedback form, in pixels.
	thermformwidth = 356		&& Holds the width of the user feedback form, in pixels.
	thermmargin = 5		&& Holds the value (in pixels) used to determine the difference between the size of the user feedback window and the thermometer bar it displays.
	thermprecision = (0)		&& The number of places (precision) to use for evaluating and (by default) showing the percentage done.
	_memberdata = <VFPData>
		<memberdata name="percentdone" type="property" display="percentDone" favorites="False" />
		<memberdata name="createtherm" type="method" display="createTherm" favorites="False" />
		<memberdata name="currentrecord" type="property" display="currentRecord" favorites="False" />
		<memberdata name="designateddriver" type="property" display="designatedDriver" favorites="False" />
		<memberdata name="drivingaliascurrentrecno" type="property" display="drivingAliasCurrentRecno" favorites="False" />
		<memberdata name="escapereference" type="property" display="escapeReference" favorites="False" />
		<memberdata name="frxbandrecno" type="property" display="frxBandRecno" favorites="False" />
		<memberdata name="getparentwindowref" type="method" display="getParentWindowRef" favorites="False" />
		<memberdata name="getreportscopedriver" type="method" display="getReportScopeDriver" favorites="False"/>
		<memberdata name="includeseconds" type="property" display="includeSeconds" favorites="True" />
		<memberdata name="initstatustext" type="property" display="initStatusText" favorites="True" />
		<memberdata name="onescapecommand" type="property" display="onEscapeCommand" favorites="False" />
		<memberdata name="prepassstatustext" type="property" display="prepassStatusText" favorites="True" />
		<memberdata name="reportstartrundatetime" type="property" display="reportStartRunDatetime" favorites="True" />
		<memberdata name="reportstoprundatetime" type="property" display="reportStopRunDatetime" favorites="True" />
		<memberdata name="resetuserfeedback" type="method" display="resetUserFeedback" favorites="False" />
		<memberdata name="runstatustext" type="property" display="runStatusText" favorites="True" />
		<memberdata name="secondstext" type="property" display="secondsText" favorites="True" />
		<memberdata name="setescape" type="property" display="setEscape" favorites="False" />
		<memberdata name="setnotifycursor" type="property" display="setNotifyCursor" favorites="False" />
		<memberdata name="setthermformcaption" type="method" display="setThermformCaption" favorites="False" />
		<memberdata name="thermcaption" type="property" display="thermCaption" favorites="True" />
		<memberdata name="thermprecision" type="property" display="thermPrecision" favorites="True" />
		<memberdata name="thermform" type="property" display="thermForm" favorites="False" />
		<memberdata name="thermformcaption" type="property" display="thermFormCaption" favorites="True" />
		<memberdata name="thermformheight" type="property" display="thermFormHeight" favorites="True" />
		<memberdata name="thermformwidth" type="property" display="thermFormWidth" favorites="True" />
		<memberdata name="thermmargin" type="property" display="thermMargin" favorites="True" />
		<memberdata name="synchstatus" type="method" display="synchStatus" favorites="False" />
		<memberdata name="successorsys2024" type="property" display="successorSys2024" favorites="False" />
		</VFPData>
	
	PROCEDURE AfterBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
		THIS.synchStatus(m.nBandObjCode,m.nFRXRecNo)
		THIS.resetDataSession()
		
	ENDPROC

	PROCEDURE AfterReport
		IF SYS(2024) # "Y" 
		   IF THIS.IsRunning OR TYPE("THIS.CommandClauses.RecordTotal") = "N"
		      THIS.CurrentRecord = THIS.CommandClauses.RecordTotal
		   ENDIF   
		   THIS.UpdateStatus() 
		ENDIF
		THIS.IsRunning = .F.
		THIS.ClearStatus() 
		THIS.designatedDriver = ""
		THIS.successorSys2024 = "N"
		THIS.ThermForm = NULL  
		THIS.ReportStopRunDateTime = DATETIME()
		THIS.PopGlobalSets()
		DODEFAULT()
		
		
		
	ENDPROC

	PROCEDURE BeforeBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
		IF THIS.successorSys2024 = "Y" AND ;
		   THIS.CurrentPass = LISTENER_FULLPASS
		   * user cancelled during the prepass,
		   * we need to re-cancel.
		   THIS.setCurrentDataSession()
		   IF USED(THIS.designatedDriver)
		      GO BOTTOM IN (THIS.designatedDriver)
		   ENDIF   
		ENDIF   
		
		THIS.synchStatus(m.nBandObjCode,m.nFRXRecNo)
		THIS.resetDataSession()
	ENDPROC

	PROCEDURE BeforeReport
		DODEFAULT()
		* THIS.ResetUserFeedback(.T.)
		THIS.DrivingAliasCurrentRecno = 0
		THIS.IsRunning = .T.
		THIS.resetDataSession()
		
		
		
	ENDPROC

	PROCEDURE CancelReport
		IF THIS.IsRunning AND ;
		   (THIS.QuietMode OR ;
		   (THIS.pageLimit > 0 AND THIS.PageNo > THIS.pageLimit) OR ;
		    (NOT THIS.AllowModalMessages) OR ;
		    THIS.DoMessage(OUTPUTCLASS_REPORT_CANCELQUERY_LOC,;
		                   MB_ICONQUESTION+MB_YESNO) =  IDYES )
		
		   IF THIS.isSuccessor AND NOT EMPTY(THIS.designatedDriver)
		      * make an exception for this Listener
		      * to the rule that Successors don't 
		      * handle cancelling the report, because
		      * this guy's job is to handle user intervention:
		      THIS.successorSys2024 = "Y"
		      LOCAL m.liSession
		      m.liSession = SET("DATASESSION")
		      THIS.setCurrentDataSession()
		      IF USED(THIS.designatedDriver)
		         GO BOTTOM IN (THIS.designatedDriver)
		      ENDIF   
		      SET DATASESSION TO (m.liSession)
		   ENDIF
		      
		   DODEFAULT() 
		   IF SYS(2024) = "Y"  OR THIS.IsSuccessor
		      THIS.ThermForm = NULL
		      IF (THIS.pageLimit = -1 OR THIS.PageNo <= THIS.pageLimit)
		         THIS.DoMessage(OUTPUTCLASS_REPORT_INCOMPLETE_LOC, ;
		                        MB_ICONEXCLAMATION)
		         THIS.lastErrorMessage = OUTPUTCLASS_REPORT_INCOMPLETE_LOC                        
		      ENDIF                        
		   ENDIF
		ELSE
		   NODEFAULT   
		ENDIF
		
	ENDPROC

	PROCEDURE ClearStatus
		NODEFAULT
		IF NOT ISNULL(THIS.ThermForm) 
		   IF THIS.ThermForm.Visible
		      THIS.ThermForm.Visible = .F.
		   ENDIF
		ENDIF
		
		IF NOT ISNULL(THIS.Successor)
		   THIS.Successor.ClearStatus()
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE createtherm		&& Creates and configures the "update" feedback window.
		#define CTLCOLOR_MSGBOX             0
		#define CTLCOLOR_EDIT               1
		#define CTLCOLOR_LISTBOX            2
		#define CTLCOLOR_BTN                3
		#define CTLCOLOR_DLG                4
		#define CTLCOLOR_SCROLLBAR          5
		#define CTLCOLOR_STATIC             6
		#define CTLCOLOR_MAX                7
		#define COLOR_SCROLLBAR             0
		#define COLOR_BACKGROUND            1
		#define COLOR_ACTIVECAPTION         2
		#define COLOR_INACTIVECAPTION       3
		#define COLOR_MENU                  4
		#define COLOR_WINDOW                5
		#define COLOR_WINDOWFRAME           6
		#define COLOR_MENUTEXT              7
		#define COLOR_WINDOWTEXT            8
		#define COLOR_CAPTIONTEXT           9
		#define COLOR_ACTIVEBORDER         10
		#define COLOR_INACTIVEBORDER       11
		#define COLOR_APPWORKSPACE         12
		#define COLOR_HIGHLIGHT            13
		#define COLOR_HIGHLIGHTTEXT        14
		#define COLOR_BTNFACE              15
		#define COLOR_BTNSHADOW            16
		#define COLOR_GRAYTEXT             17
		#define COLOR_BTNTEXT              18
		#define COLOR_INACTIVECAPTIONTEXT  19
		#define COLOR_BTNHIGHLIGHT         20
		#if("4" $ OS())
		#define COLOR_3DDKSHADOW           21
		#define COLOR_3DLIGHT              22
		#define COLOR_INFOTEXT             23
		#define COLOR_INFOBK               24
		#define COLOR_DESKTOP           COLOR_BACKGROUND
		#define COLOR_3DFACE            COLOR_BTNFACE
		#define COLOR_3DSHADOW          COLOR_BTNSHADOW
		#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
		#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
		#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
		#endif
		
		IF ISNULL(THIS.ThermForm)
		
		  DECLARE INTEGER GetSysColor IN Win32API INTEGER  
		
		  LOCAL m.liThermTop, m.liThermLeft, m.liThermWidth, m.liThermHeight, m.liSession
		  m.liSession = SET("DATASESSION")  
		  THIS.resetDataSession()
		  THIS.ThermForm = CREATEOBJECT("FORM")
		  
		  WITH THIS.ThermForm
		  
		     .ScaleMode = SCALEMODE_PIXELS   
		     .Height = THIS.ThermFormHeight
		     .HalfHeightCaption = .T.
		     .Width = THIS.ThermFormWidth
		     .AutoCenter = .T.
		     .BorderStyle = BORDER_DOUBLE  && fixed dialog
		     .ControlBox = .F.
		     .Closable = (NOT THIS.IsRunning)
		     .MaxButton = .F.
		     .MinButton = .F.
		     .Movable = (NOT THIS.IsRunning)
		     .AlwaysOnTop = .T.
		     .AllowOutput = .F.
		     .AddObject("ThermBack","shape")
		     .AddObject("ThermLabel","label")
		     .AddObject("ThermShape","shape")
		     m.liThermHeight = .Height - (THIS.ThermMargin* 2)
		     m.liThermWidth =  .Width - (THIS.ThermMargin*2)
		  ENDWITH
		  
		  THIS.setCurrentDataSession()
		  
		  THIS.SetThermFormCaption()    
		  
		  m.liThermTop = THIS.ThermMargin
		  m.liThermLeft = THIS.ThermMargin  
		
		  WITH THIS.ThermForm.ThermBack
		     .Top = m.liThermTop     
		     .Left = m.liThermLeft
		     .Height = m.liThermHeight
		     .Width = m.liThermWidth
		     .Visible = .T.
		     .BorderStyle = BORDER_SINGLE
		     .BackStyle = 0     
		  ENDWITH
		  
		  WITH THIS.ThermForm.ThermLabel
		     .Top = (.Parent.Height - .Height) /2
		     .Autosize = .T.
		     .BackStyle = FILLSTYLE_SOLID      
		     .Caption = ""
		     .Visible = .T.
		     .ForeColor = GetSysColor( COLOR_MENUTEXT )
		  ENDWITH
		  
		  WITH THIS.ThermForm.ThermShape
		     .Top = m.liThermTop +1    
		     .Left = m.liThermLeft+1
		     .Height = m.liThermHeight -2
		     .Width = 0
		     .Visible = .T.
		     .BorderStyle = BORDER_NONE
		     .BackStyle = FILLSTYLE_SOLID         
		     .FillStyle = FILLSTYLE_SOLID    
		     .BackColor = .Parent.BackColor
		     .FillColor = GetSysColor(COLOR_HIGHLIGHT)
		     .DrawMode = DRAWMODE_MERGE_PEN_NOT 
		  ENDWITH
		  
		  SET DATASESSION TO (m.liSession)
		 
		ENDIF
		
		RETURN NOT ISNULL(THIS.ThermForm)
	ENDPROC

	PROCEDURE Destroy
		STORE NULL TO THIS.thermForm 
		
		DODEFAULT()
	ENDPROC

	PROCEDURE DoStatus
		LPARAMETERS m.cMessage
		LOCAL m.loParentForm, m.lcCaption, m.lcParentFormName
		NODEFAULT
		
		IF (NOT (THIS.QuietMode or ;
		   (THIS.IsRunning AND THIS.CommandClauses.NoDialog)))
		
		   IF EMPTY(m.cMessage) OR ISNULL(m.cMessage)
		      m.cMessage = ""
		   ENDIF
		
		   m.lcCaption = EVALUATE(THIS.ThermCaption)
		   IF ((NOT ISNULL(THIS.ThermForm)) OR (THIS.CreateTherm()) )
		
		      WITH THIS.ThermForm
		      
		         IF THIS.IsRunning
		            .Closable = .F.
		            .Movable = .F.
		         ENDIF
		      
		        .ThermShape.Width = MAX( (((THIS.PercentDone/100) * .ThermBack.Width)-2) ,0)
		      
		        IF NOT .Visible
		        
		           m.loParentForm = THIS.GetParentWindowRef()
		           
		           DO CASE
		           CASE VARTYPE(m.loParentForm) # "O" AND (NOT _SCREEN.Visible)
		              m.lcParentFormName = "MACDESKTOP"
		           CASE VARTYPE(m.loParentForm) # "O"
		              m.lcParentFormName = "SCREEN"              
		           CASE (NOT m.loParentForm.Visible) AND ;
		              (m.loParentForm.DeskTop OR NOT EMPTY(m.loParentForm.MacDesktop) OR ;
		              m.loParentForm.ShowWindow = 2 OR (NOT _SCREEN.Visible))
		              * in many cases, 
		              * they've probably made a programming error,
		              * the parent should be visible according to
		              * the requirements of REPORT FORM ... IN WINDOW
		              * if it's a WINDOW clause they
		              * have no need to show it, might not be an error
		              * Either way, they should see the therm
		              * to know that the report is progressing                
		              m.lcParentFormName = "MACDESKTOP"
		           CASE (NOT m.loParentForm.Visible) 
		              * same comment as above
		              m.lcParentFormName = "SCREEN"
		           OTHERWISE
		              m.lcParentFormName = m.loParentForm.Name
		           ENDCASE
		           
		           SHOW WINDOW (.Name) IN WINDOW (m.lcParentFormName) 
		           .AlwaysOnTop = .T.
		           .AutoCenter = .T.
		           .Visible = .T.
		        
		        ENDIF
		        .ThermLabel.Visible = .F.
		        .ThermLabel.Caption = m.lcCaption     
		        .ThermLabel.Left = (.Width - .ThermLabel.Width) /2  && must be after visible        
		        .ThermLabel.Visible = .T.     
		      
		      ENDWITH
		
		   
		   ENDIF
		  
		ENDIF   
		
		
		
	ENDPROC

	PROCEDURE getfrxstartupinfo
		DODEFAULT()
		
		LOCAL m.llFRXAvailable, m.lcAlias
		
		m.llFRXAvailable = THIS.getReportScopeDriver() 
		
		IF m.llFRXAvailable
		   THIS.SetFRXDataSession()
		   THIS.FRXBandRecno = 0
		
		   SELECT FRX
		   
		   IF THIS.CommandClauses.Summary
		      * don't use groups unless
		      * we're forced to by Summary.
		      * Group usage will not work if
		      * there's a group on .T. or some
		      * other nonsensical expression that
		      * doesn't change.
		    
		      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		          Objcode = FRX_OBJCOD_GROUPHEADER AND ;
		          Platform = FRX_PLATFORM_WINDOWS AND ;
		          NOT DELETED()
		      DO WHILE NOT EOF()
		         * find the innermost group
		         THIS.FRXBandRecno = RECNO()
		         CONTINUE
		      ENDDO        
		      
		      IF THIS.frxBandRecno = 0
		         * no groups in a Summary report
		         * doesn't make a lot of sense, but
		         * can happen.
		          LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		             Objcode = FRX_OBJCOD_PAGEHEADER AND ;
		             Platform = FRX_PLATFORM_WINDOWS AND ;
		             NOT DELETED()
		          IF NOT EOF()
		             THIS.FRXBandRecno = RECNO()
		          ENDIF     
		      ENDIF
		   
		   ENDIF
		      
		   IF THIS.FRXBandRecno = 0
		      * not a Summary report.
		      * look for the appropriate detail
		      * using the report driver
		      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		                 Objcode = FRX_OBJCOD_DETAIL AND ;
		                 Platform = FRX_PLATFORM_WINDOWS AND ;
		                 TYPE(Expr) = "C" AND ;
		                 NOT (EMPTY(Expr) OR DELETED())
		       DO WHILE NOT EOF()
		          m.lcAlias = ALLTRIM(Expr)
		          THIS.SetCurrentDataSession()             
		          m.lcAlias = UPPER(EVALUATE(m.lcAlias))
		          THIS.SetFRXDataSession()                          
		          IF m.lcAlias == UPPER(THIS.DrivingAlias)             
		             THIS.FRXBandRecno = RECNO()
		          ENDIF   
		          CONTINUE && try not to use the first detail band
		       ENDDO
		   ENDIF   
		   
		   IF THIS.frxBandRecno = 0
		      * couldn't match up a band with
		      * the known driver
		      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		           Objcode = FRX_OBJCOD_DETAIL AND ;
		           Platform = FRX_PLATFORM_WINDOWS AND ;
		           EMPTY(Expr) AND NOT DELETED()
		      IF NOT EOF()
		         THIS.FRXBandRecno = RECNO()      
		      ELSE
		         IF THIS.FRXBandRecno = 0 
		            LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		                 Platform = FRX_PLATFORM_WINDOWS AND ;
		                 Objcode = FRX_OBJCOD_DETAIL AND ;
		                 NOT DELETED()
		            IF NOT EOF()
		               THIS.FRXBandRecno = RECNO()
		            ENDIF  
		         ENDIF               
		      ENDIF        
		   ENDIF   
		
		ENDIF
		
		THIS.setCurrentDataSession()
		
	ENDPROC

	PROTECTED PROCEDURE getparentwindowref		&& Provides a window reference for the top form in which the user feedback window should appear.
		LOCAL m.loForm, m.loTopForm, m.lcInWindow
		
		* first top form in the list
		* will be the current top form.
		
		ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
		       INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)
		
		m.loTopForm = NULL
		
		IF TYPE("THIS.CommandClauses.InWindow") = "C"
		   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.InWindow))
		ENDIF   
		
		IF EMPTY(lcInWindow) AND TYPE("THIS.CommandClauses.Window") = "C"
		   m.lcInWindow = UPPER(ALLTRIM(THIS.CommandClauses.Window))
		ENDIF   
		
		
		IF NOT EMPTY(m.lcInWindow) 
		
		     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
		        IF m.loForm.ShowWindow = 2  AND ;
		           UPPER(m.loForm.Name) == m.lcInWindow
		           m.loTopForm = m.loForm
		           EXIT
		        ENDIF
		     ENDFOR
		     
		ENDIF
		
		DO CASE
		
		CASE VARTYPE(m.loTopForm) = "O"
		    * already found
		CASE _SCREEN.FormCount = 0 OR ;
		     (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		     _SCREEN.ActiveForm.ShowWindow = 0 )     && ShowWindow In Screen
				     
		     m.loTopForm = _SCREEN
		
		CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		      _SCREEN.ActiveForm.ShowWindow = 2 )    && ShowWindow As Top Form
		
		     m.loTopForm = _SCREEN.ActiveForm
				     
		OTHERWISE 
				                                       
		     FOR EACH m.loForm IN _SCREEN.Forms  FOXOBJECT
		        IF m.loForm.ShowWindow = 2 
		           m.loTopForm = m.loForm
		           EXIT
		        ENDIF
		     ENDFOR
				     
		     IF VARTYPE(m.loTopForm) # "O"
		        m.loTopForm = _SCREEN
		     ENDIF
				          
		ENDCASE
		
		IF VARTYPE(m.loTopForm) # "O" OR ;
		   EMPTY(m.loTopForm.Name)
		   m.loTopForm = NULL
		ENDIF
		
		RETURN m.loTopForm     
		
	ENDPROC

	PROTECTED PROCEDURE getreportscopedriver		&& Adjusts the alias driving CommandClauses.RecordTotal at the beginning of a report  when the DrivingAlias is engaged in one-to-many relationships.
		LOCAL m.liSelect, m.lcAlias, ;
		      m.liSkips,  laSkips[1]
		
		THIS.designatedDriver = THIS.drivingAlias
		* used later if we have to cancel report as
		* a Successor
		
		THIS.setFRXDataSession()
		
		IF USED("frx")
		
		   m.liSelect = SELECT(0)
		   m.lcAlias = ""
		   
		   SELECT FRX
		   * first look for any target alias that
		   * is the same as the driver
		   
		   SCAN ALL FOR ObjType = FRX_OBJTYP_BAND AND ;
		           Objcode = FRX_OBJCOD_DETAIL AND ;
		           TYPE(Expr) = "C" AND ;
		           NOT (EMPTY(Expr)  OR DELETED())
		
		       m.lcAlias = ALLTRIM(Expr)
		       THIS.setCurrentDataSession()
		       m.lcAlias = UPPER(EVALUATE(m.lcAlias)) 
		       THIS.setFRXDataSession()
		       IF m.lcAlias == UPPER(THIS.drivingAlias)
		          EXIT
		       ENDIF
		   ENDSCAN
		
		   IF m.lcAlias == UPPER(THIS.drivingAlias)
		      SELECT (m.liSelect)
		      * if the driver is also a target alias,
		      * don't touch.
		      * otherwise:
		   ELSE 
		
		      LOCATE FOR ObjType = FRX_OBJTYP_BAND AND ;
		              Objcode = FRX_OBJCOD_DETAIL AND ;
		              Platform = FRX_PLATFORM_WINDOWS AND ;
		              NOT (EMPTY(Expr) OR DELETED())
		      IF FOUND()
		         * use the first detail band, on the theory
		         * that people are going to put pre-processing 
		         * calculations before other bands, 
		         * so an early band has the best chance to be
		         * the right driver.
		         m.lcAlias = ALLTRIM(Expr)
		         THIS.setCurrentDataSession()
		         THIS.drivingAlias = UPPER(EVALUATE(m.lcAlias))
		         THIS.setFRXDataSession()
		         SELECT (m.liSelect)
		
		      ELSE   
		   
		         * adjust the driver based on any
		         * one to many relationships we can find.
		  
		         SELECT (m.liSelect)
		   
		         THIS.setCurrentDataSession()
		
		         m.lcAlias = THIS.drivingAlias
		
		         m.liSelect = SELECT(0)
		
		         DO WHILE NOT EMPTY(m.lcAlias)
		
		            SELECT (m.lcAlias)
		            m.liSkips = ALINES(laSkips,SET("SKIP"),",")
		            IF m.liSkips = 0 OR EMPTY(laSkips[1])
		               THIS.drivingAlias = m.lcAlias
		               m.lcAlias = ""
		            ELSE
		               m.lcAlias = laSkips[1]
		               * it doesn't really matter how many lines there
		               * are in the array; this is not going to be perfect
		               * but we can't predict which child 
		               * has the most records.
		            ENDIF
		         ENDDO
		
		         SELECT (m.liSelect)
		   
		      ENDIF   
		    
		   ENDIF  
		ELSE
		   RETURN .F.    
		ENDIF
	ENDPROC

	PROCEDURE includeseconds_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.includeseconds = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT() 
		   THIS.InitStatusText = OUTPUTCLASS_INITSTATUS_LOC
		   THIS.PrepassStatusText = OUTPUTCLASS_PREPSTATUS_LOC
		   THIS.RunStatusText =  OUTPUTCLASS_RUNSTATUS_LOC
		   THIS.SecondsText = OUTPUTCLASS_TIME_SECONDS_LOC
		   THIS.thermCaption = OUTPUTCLASS_THERMCAPTION_LOC 
		   RETURN (NOT THIS.HadError)
		ELSE
		   RETURN .F.
		ENDIF
		   
	ENDPROC

	PROCEDURE initstatustext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.InitStatusText = m.vNewVal
		ENDIF   
	ENDPROC

	PROCEDURE LoadReport
		IF DODEFAULT()
		   THIS.ResetUserFeedback(.T.)
		   IF NOT (THIS.QuietMode OR ;
		           (TYPE("THIS.CommandClauses.NoDialog") = "L" AND ;
		           THIS.CommandClauses.NoDialog) )
		      THIS.DoStatus(THIS.initStatusText) 
		      * NB: a user can call LoadReport manually,
		      * hence the need for a TYPE() check here.
		   ENDIF   
		   THIS.PushGlobalSets()
		ELSE
		   THIS.ClearStatus()
		   RETURN .F.
		ENDIF
	ENDPROC

	PROCEDURE popglobalsets
		DODEFAULT()
		IF (NOT INLIST(_VFP.StartMode,2,3,5))
		   LOCAL m.lcRef
		   m.lcRef = THIS.EscapeReference
		   IF (NOT EMPTY(m.lcRef)) AND ;
		       TYPE(m.lcRef) = "O"
		      * push occurred earlier
		      STORE NULL TO (m.lcRef)
		      RELEASE &lcRef.
		      THIS.escapeReference = ""
		      m.lcRef = THIS.OnEscapeCommand
		      ON ESCAPE &lcRef
		      POP KEY
		      IF THIS.SetNotifyCursor
		         SET NOTIFY CURSOR ON
		      ENDIF   
		      IF THIS.SetEscape 
		         SET ESCAPE OFF
		      ENDIF   
		   ENDIF   
		ENDIF   
		   
		   
	ENDPROC

	PROCEDURE prepassstatustext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.PrepassStatusText = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE pushglobalsets
		DODEFAULT()
		IF (NOT INLIST(_VFP.StartMode,2,3,5))
		   PUSH KEY CLEAR
		   LOCAL m.lcRef
		   SET MESSAGE TO ""
		   THIS.SetNotifyCursor = (SET("Notify",2) = "ON")
		   IF THIS.SetNotifyCursor
		      SET NOTIFY CURSOR OFF
		   ENDIF   
		   THIS.OnEscapeCommand = ON("ESCAPE")   
		   m.lcRef = SYS(2015)   
		   PUBLIC &lcRef.   
		   STORE THIS TO (m.lcRef)
		   ON ESCAPE &lcRef..CancelReport()      
		   THIS.EscapeReference = m.lcRef   
		   THIS.SetEscape = (SET("ESCAPE")="OFF") 
		   IF THIS.SetEscape
		      SET ESCAPE ON
		   ENDIF   
		ENDIF   
		   
		   
	ENDPROC

	PROTECTED PROCEDURE resetuserfeedback		&& Sets user feedback to an initialized state.
		LPARAMETERS m.tlResetTimes
		THIS.CurrentRecord = 0
		THIS.PercentDone = 0
		IF m.tlResetTimes
		   THIS.ReportStartRunDateTime= DATETIME()
		   THIS.ReportStopRunDateTime= DTOT({})
		ENDIF   
		
	ENDPROC

	PROCEDURE runstatustext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.RunStatusText = m.vNewVal
		ENDIF   
		
		
	ENDPROC

	PROCEDURE secondstext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.SecondsText = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE setfrxrunstartupconditions
		DODEFAULT()
		IF TYPE("THIS.CommandClauses.Summary") # "L"
		   ADDPROPERTY(THIS.CommandClauses,"Summary",.F.)
		ENDIF   
		IF TYPE("THIS.CommandClauses.RecordTotal") # "N"
		   ADDPROPERTY(THIS.CommandClauses,"RecordTotal",0)
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE setthermformcaption		&& Sets the user feedback window title using the ThermFormCaption property.
		IF NOT ISNULL(THIS.ThermForm)
		   IF EMPTY(THIS.ThermFormCaption)
		      
		      IF TYPE("THIS.CommandClauses.File") = "C"
		         LOCAL m.cName
		         IF EMPTY(THIS.PrintJobName)
		            m.cName = PROPER(JUSTFNAME(THIS.CommandClauses.File))
		         ELSE
		            m.cName = THIS.PrintJobName
		         ENDIF   
		         THIS.ThermForm.Caption = ;
		            m.cName + ": " + OUTPUTCLASS_CANCEL_INSTRUCTIONS_LOC
		      ELSE
		         THIS.ThermForm.Caption = ""
		      ENDIF
		   ELSE   
		      THIS.ThermForm.Caption = THIS.ThermFormCaption
		   ENDIF
		ENDIF   
		
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE synchstatus		&& Compares driving recno with currrently-saved information to evaluate need to update user feedback.
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		IF THIS.isRunning AND (NOT THIS.hadError) AND ;
		   THIS.frxBandRecno = m.nFRXRecNo
		   THIS.setCurrentDataSession() 
		   IF THIS.drivingAliasCurrentRecno  # RECNO(THIS.drivingAlias)
		      THIS.currentRecord = THIS.CurrentRecord + 1
		      THIS.drivingAliasCurrentRecno = RECNO(THIS.drivingAlias)
		   ENDIF   
		   IF THIS.currentRecord >= THIS.CommandClauses.RecordTotal
		      IF THIS.CurrentPass = 0 AND THIS.TwoPassProcess
		         THIS.resetUserFeedback() 
		      ELSE
		         THIS.currentRecord = THIS.CommandClauses.RecordTotal
		      ENDIF
		   ENDIF
		   THIS.UpdateStatus()
		   THIS.resetDataSession()
		ENDIF  
		
		
	ENDPROC

	PROCEDURE thermcaption_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   LOCAL m.lcType, m.cMessage
		   m.cMessage = ""
		   TRY 
		    m.lcType = VARTYPE(EVALUATE(m.vNewVal))
		      IF m.lcType = "C"
		        THIS.ThermCaption = m.vNewVal
		    ENDIF
		   CATCH 
		   ENDTRY     
		ENDIF   
		
	ENDPROC

	PROCEDURE thermformcaption_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.ThermFormCaption = m.vNewVal
		   THIS.SetThermFormCaption()
		ENDIF   
		
	ENDPROC

	PROCEDURE thermformheight_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
		   BETWEEN(m.vNewVal,30,SYSMETRIC(SYSMETRIC_SCREENHEIGHT )-30)  AND ;
		   INT(m.vNewVal) # THIS.ThermFormHeight
		   THIS.thermformheight = INT(m.vNewVal)
		   IF THIS.ThermMargin > THIS.ThermFormHeight/4
		      THIS.ThermMargin = THIS.ThermFormHeight/4
		   ENDIF   
		   THIS.thermForm = NULL
		ENDIF   
		
	ENDPROC

	PROCEDURE thermformwidth_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
		   BETWEEN(m.vNewVal,100,SYSMETRIC( SYSMETRIC_SCREENWIDTH  )-100) AND ;
		   INT(m.vNewVal) # THIS.ThermFormWidth 
		   THIS.thermformwidth = INT(m.vNewVal)
		   IF THIS.ThermMargin > THIS.ThermFormWidth/4
		      THIS.ThermMargin = THIS.ThermFormWidth/4
		   ENDIF   
		   THIS.ThermForm = NULL
		ENDIF   
		
	ENDPROC

	PROCEDURE thermmargin_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND VARTYPE(m.vNewVal) = "N" AND ;
		   BETWEEN(m.vNewVal,1,MIN(THIS.ThermFormHeight/4,THIS.ThermFormWidth/4)) AND ;
		   INT(m.vNewVal) # THIS.ThermMargin
		   THIS.thermmargin = INT(m.vNewVal)
		   THIS.thermForm = NULL
		ENDIF   
		
	ENDPROC

	PROCEDURE thermprecision_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" 
		   THIS.thermPrecision  = ABS(INT(m.vNewVal))
		ENDIF 
	ENDPROC

	PROCEDURE UnloadReport
		IF THIS.IsRunning
		   THIS.IsRunning = .F.
		   THIS.PopGlobalSets()
		ENDIF   
		
		THIS.ReportStopRunDateTime = DATETIME()
		THIS.ClearStatus() 
		THIS.ThermForm = NULL  
		
		DODEFAULT()
		
		THIS.resetDataSession()
		
	ENDPROC

	PROCEDURE UpdateStatus
		NODEFAULT
		* the THIS.IsRunning check here
		* make sure that this code doesn't
		* run if the Engine calls UpdateStatus
		* after we're through
		
		IF THIS.isRunning
		   LOCAL m.liRecTotal, m.lnNewPercent, m.llShow
		   m.liRecTotal = THIS.CommandClauses.RecordTotal 
		   IF m.liRecTotal > 0 
		      m.lnNewPercent = ROUND(THIS.CurrentRecord/m.liRecTotal,(THIS.ThermPrecision + 2) ) * 100
		      IF (THIS.PercentDone # m.lnNewPercent)
		         THIS.PercentDone = m.lnNewPercent
		         m.llShow = .T.
		         #IF OUTPUTCLASS_DEBUGGING 
		             ? THIS.PercentDone, THIS.CurrentRecord, m.liRecTotal, THIS.PageTotal
		             ? REPL(OUTPUTCLASS_STATUSCHAR_PCT_DONE,INT(THIS.PercentDone/100* OUTPUTCLASS_ONE_HUNDRED_PCT_MARK))+ ;
		               REPL(OUTPUTCLASS_STATUSCHAR_PCT_NOT_DONE,MAX(FLOOR(OUTPUTCLASS_ONE_HUNDRED_PCT_MARK - ;
		                                                            (OUTPUTCLASS_ONE_HUNDRED_PCT_MARK *THIS.PercentDone/100)),0) ) 
		         #ENDIF                
		      ENDIF
		   ELSE
		      m.llShow = .T.         
		   ENDIF   
		   IF m.llShow
		      THIS.DoStatus( IIF(THIS.CurrentPass = LISTENER_PREPASS  AND THIS.TwoPassProcess,;
		                     THIS.PrepassStatusText, ;
		                     THIS.RunStatusText) )
		   ENDIF                     
		ENDIF   
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS utilityreportlistener AS fxlistener OF "_reportlistener.vcx" 		&& Adds configuration table handling and output target file handling to fxListener class
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: closetargetfile		&& Finalizes file output.
		*m: configurationobjtype_access
		*m: createconfigtable		&& Creates a configuration table on demand.
		*m: currentpageimagefilename_assign
		*m: externalfilelocation_assign
		*m: generatepageimagefilename		&& Creates a filename for a generated page image file.
		*m: getconfigtable		&& Assesses and provides the name of the current configuration table, optionally creating it on disk if it is not available.
		*m: getpageimageextension		&& Provides the appropriate file extension for the current pageImageType value.
		*m: makeexternalfilelocationreachable		&& Checks to see if the externalFileLocation (which may be relative to the current targetfilename) exists in the current environment, adjusting if necessary when the output process determines the need to create ancillary output files along with main target.
		*m: opentargetfile		&& Initializes a file for output purposes.
		*m: outputpageimage		&& Use OutputPage method to create a page image file according to current report's requirements.
		*m: pageimagetype_assign
		*m: readconfiguration_assign
		*m: setconfiguration		&& Checks the current configuration table for dynamic information in records of appropriate type, and executes these instructions if found.
		*m: supportspageimages		&& Evaluates whether the current reporting mode supports generating page images.
		*m: targetfileext_assign
		*m: targetfilename_assign
		*m: targethandle_assign
		*m: verifyconfigtable		&& Ascertains that the format and and contents of the configuration meet requirements, adjusting it if necessary.
		*m: verifytargetfile		&& Assures that the nominated filename and its network location are available at the beginning of a file-based report run.
		*p: configurationobjtype		&& Holds the reserved value used to indicate that a configuration table row provides dynamic configuration information at runtime.
		*p: configurationtable		&& Holds the name of the current configuration table.
		*p: currentpageimagefilename		&& Provides the filename for the generated page image file for the current page during a report run, including the externalFileLocation path, which may be relative.
		*p: externalfilelocation		&& Assigns a  UNC or file system path, either relative to the main output target or absolute, the file-outputting process uses for external files, such as images, it creates along with the main output target.
		*p: pageimageextension		&& Caches appropriate image file extension for current pageImageType.
		*p: pageimagetype		&& Indicates a type of image file you want generated for each output page in a report run at the conclusion of a chained report set.
		*p: readconfiguration		&& Indicates the conditions under which SetConfiguration code will run. 0=never, 1 = when the class instance Init runs, 2 = when the class instance runs BeforeReport, 3 = at both Init and BeforeReport.
		*p: targetfileext		&& Provides the default file extension for file output.
		*p: targetfilename		&& Provides the filename to which output will be written.  A unique name is generated for the class instance, which will be overwritten for successive report runs if not adjusted by the user.
		*p: targethandle		&& Provides a low-level file handle, to which output is written directly when the class provides raw data to the file, otherwise reserves the file during the report run so other applications don't write to it .
	*</DefinedPropArrayMethod>

	PROTECTED configurationtable,pageimageextension
	configurationobjtype = 1000		&& Holds the reserved value used to indicate that a configuration table row provides dynamic configuration information at runtime.
	configurationtable = ("")		&& Holds the name of the current configuration table.
	currentpageimagefilename = ("")		&& Provides the filename for the generated page image file for the current page during a report run, including the externalFileLocation path, which may be relative.
	externalfilelocation = ("")		&& Assigns a  UNC or file system path, either relative to the main output target or absolute, the file-outputting process uses for external files, such as images, it creates along with the main output target.
	FRXDataSession = -1
	Name = "utilityreportlistener"
	pageimageextension = ("")		&& Caches appropriate image file extension for current pageImageType.
	pageimagetype = 0		&& Indicates a type of image file you want generated for each output page in a report run at the conclusion of a chained report set.
	readconfiguration = (0)		&& Indicates the conditions under which SetConfiguration code will run. 0=never, 1 = when the class instance Init runs, 2 = when the class instance runs BeforeReport, 3 = at both Init and BeforeReport.
	targetfileext = ("TXT")		&& Provides the default file extension for file output.
	targetfilename = (FORCEPATH(SYS(2015),SYS(2023)))		&& Provides the filename to which output will be written.  A unique name is generated for the class instance, which will be overwritten for successive report runs if not adjusted by the user.
	targethandle = -1		&& Provides a low-level file handle, to which output is written directly when the class provides raw data to the file, otherwise reserves the file during the report run so other applications don't write to it .
	_memberdata = <VFPData>
		<memberdata name="closetargetfile" type="method" display="closeTargetFile" favorites="False" />
		<memberdata name="configurationobjtype" type="property" display="configurationObjtype" favorites="True" />
		<memberdata name="configurationtable" type="property" display="configurationTable" favorites="False" />
		<memberdata name="createconfigtable" type="method" display="createConfigTable" favorites="True" />
		<memberdata name="getconfigtable" type="method" display="getConfigTable" favorites="True" />
		<memberdata name="opentargetfile" type="method" display="openTargetFile" favorites="False" />
		<memberdata name="readconfiguration" type="property" display="readConfiguration" favorites="True" />
		<memberdata name="setconfiguration" type="method" display="setConfiguration" favorites="True" />
		<memberdata name="targetfileext" type="property" display="targetFileExt" favorites="True" />
		<memberdata name="targetfilename" type="property" display="targetFileName" favorites="True" />
		<memberdata name="targethandle" type="property" display="targetHandle" favorites="True" />
		<memberdata name="verifyconfigtable" type="property" display="verifyConfigTable" favorites="True" />
		<memberdata name="verifytargetfile" type="method" display="verifyTargetFile" favorites="True" />
		<memberdata name="externalfilelocation" type="property" display="externalFileLocation" favorites="True" />
		<memberdata name="pageimagetype" type="property" display="pageImageType" favorites="True"/>
		<memberdata name="getpageimageextension" type="method" display="getPageImageExtension"/>
		<memberdata name="pageimageextension" type="property" display="pageImageExtension"/>
		<memberdata name="generatepageimagefilename" type="method"  display="generatePageImageFileName"/>
		<memberdata name="supportspageimages" type="method" display="supportsPageImages"/>
		<memberdata name="outputpageimage" type="method" display="outputPageImage"/>
		<memberdata name="currentpageimagefilename" display="currentPageImageFilename" type="property"/>
		<memberdata name="makeexternalfilelocationreachable" display="makeExternalFileLocationReachable" type="method"/>
		</VFPData>
	
	PROCEDURE AfterReport
		DODEFAULT()
		IF (NOT THIS.CommandClauses.NOPAGEEJECT) AND ;
		   THIS.supportsPageImages("AFTERREPORT")
		   LOCAL m.lcFileLocation, m.liPage,  m.lcFile
		   m.lcFileLocation = THIS.ExternalFileLocation
		   THIS.makeExternalFileLocationReachable()
		   FOR m.liPage = 1 TO THIS.OutputPageCount 
		      IF NOT THIS.outputPageImage(m.liPage)
		         EXIT
		      ENDIF
		   NEXT   
		   THIS.externalFileLocation = m.lcFileLocation
		ENDIF
		
	ENDPROC

	PROCEDURE BeforeBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		
		IF (m.nBandObjCode = FRX_OBJCOD_PAGEHEADER OR ;
		    m.nBandObjCode = FRX_OBJCOD_TITLE) AND ;
		   THIS.supportsPageImages() 
		   * Note: this assignment does not occur in 
		   * OutputPageImage, because we don't know
		   * what listener mode (PRN vs cached) we're in.
		   * The point of this property is to make the value
		   * available either way, as it will eventually be
		   * used by OutputPageImage no matter when that occurs,
		   * during the run of the report.
		   LOCAL lcFile, liPageNo
		   m.lcFile = ""
		   DO CASE
		   CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_MTIF 
		      m.liPageNo = 1
		   CASE THIS.CommandClauses.RangeFrom < 2 
		      IF THIS.isSuccessor
		         m.liPageNo = THIS.sharedPageNo
		      ELSE
		         m.liPageNo = THIS.PageNo      
		      ENDIF   
		   OTHERWISE      
		      IF THIS.isSuccessor
		         m.liPageNo = (THIS.sharedPageNo - THIS.CommandClauses.RangeFrom) + 1       
		      ELSE
		         m.liPageNo = (THIS.PageNo - THIS.CommandClauses.RangeFrom) + 1 
		      ENDIF   
		   ENDCASE
		   m.lcFile = THIS.generatePageImageFileName(m.liPageNo)
		   THIS.currentPageImageFilename = m.lcFile
		   IF NOT ISNULL(THIS.successor)
		      THIS.successor.currentPageImageFilename = m.lcFile
		   ENDIF   
		ENDIF
		
		IF THIS.sharedPageNo  = 1 AND ;
		   m.nBandObjCode = FRX_OBJCOD_PAGEHEADER AND ;   
		   (NOT EMPTY(THIS.pageImageType)) AND ;
		   (EMPTY(THIS.currentPageImageFilename)) AND ;
		   ((NOT THIS.TwoPassProcess) OR THIS.CurrentPass = LISTENER_FULLPASS)
		   THIS.DoMessage(OUTPUTFILE_NOIMAGEFILES_LOC,MB_ICONEXCLAMATION)     
		ENDIF   
		
		DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
		
		
		
		
	ENDPROC

	PROCEDURE BeforeReport
		THIS.currentPageImageFilename =""
		
		IF (NOT EMPTY(THIS.pageImageType)) AND ;
		   (NOT THIS.supportsPageImages()) 
		   IF (NOT THIS.isSuccessor)
		     THIS.ListenerType = LISTENER_TYPE_PAGED
		   ENDIF 
		ENDIF
		
		IF THIS.supportsPageImages()
		   THIS.makeExternalFileLocationReachable()
		ENDIF   
		
		IF NOT ISNULL(THIS.successor)
		   THIS.successor.AddProperty("currentPageImageFilename","")
		ENDIF
		
		DODEFAULT()
		
		 IF INLIST(THIS.ReadConfiguration,;
		                  OUTPUTCLASS_READCONFIG_REPORT,;
		                  OUTPUTCLASS_READCONFIG_BOTH)
		     THIS.SetConfiguration()
		ENDIF   
		
		THIS.resetDataSession()
	ENDPROC

	PROTECTED PROCEDURE closetargetfile		&& Finalizes file output.
		   LOCAL laDummy[1]
		     
		   IF THIS.TargetHandle > -1    
		
		      =FCLOSE(THIS.TargetHandle)
		      THIS.TargetHandle = -1
		     
		      IF ADIR(laDummy,THIS.TargetFileName) = 1 AND ;
		         laDummy[1,2] > 0
		         * NB: have to check this as well as
		         * error because some COM errors may not
		         * end up in THIS.HadError.
		          * if continuation, update status rather than
		          * modal message
		         IF THIS.HadError
		            THIS.DoMessage(OUTPUTCLASS_CREATEERRORS_LOC,MB_ICONEXCLAMATION  )
		            THIS.lastErrorMessage = OUTPUTCLASS_CREATEERRORS_LOC
		        ELSE
		            IF THIS.DoMessage( OUTPUTCLASS_SUCCESS_LOC + ;
		                            IIF(SYS(2024)="Y",CHR(13)+OUTPUTCLASS_REPORT_INCOMPLETE_LOC,""),;
		                            MB_ICONINFORMATION + MB_YESNO ) = IDYES
		               _CLIPTEXT = THIS.TargetFileName
		            ENDIF
		         ENDIF
		      ELSE
		         THIS.DoMessage(OUTPUTCLASS_NOCREATE_LOC,MB_ICONSTOP )
		         THIS.lastErrorMessage = OUTPUTCLASS_NOCREATE_LOC
		       
		      ENDIF                 
		     
		   ENDIF
		
	ENDPROC

	PROCEDURE configurationobjtype_access
		* readonly property
		   
		RETURN OUTPUTCLASS_OBJTYPE_CONFIG
		
	ENDPROC

	PROCEDURE createconfigtable		&& Creates a configuration table on demand.
		LPARAMETERS m.tcDBF, m.tlOverWrite
		LOCAL m.liSelect, m.lcFile
		
		m.lcFile = FORCEEXT(m.tcDBF,"DBF")
		
		IF (NOT EMPTY(SYS(2000,m.lcFile))) AND m.tlOverWrite
		   ERASE (m.lcFile) RECYCLE
		   ERASE (FORCEEXT(m.lcFile,"FPT")) RECYCLE
		   ERASE (FORCEEXT(m.lcFile,"CDX")) RECYCLE   
		ENDIF   
		
		m.liSelect = SELECT(0)
		
		SELECT 0
		
		CREATE TABLE (m.lcFile) FREE ;
		   (objtype i, ;
		    objcode i, ;
		    objname v(60), ;
		    objvalue v(60), ;
		    objinfo m)
		
		IF NOT EMPTY(ALIAS()) && can happen if SAFETY ON and they decide not to overwrite    
		
		   INDEX ON Objtype TAG ObjType
		   INDEX ON ObjCode TAG ObjCode
		   INDEX ON ObjName TAG ObjName
		   INDEX ON ObjValue TAG ObjValue
		   INDEX ON DELETED() TAG OnDeleted    
		   
		   INSERT INTO (ALIAS()) VALUES ;
		      (OUTPUTCLASS_OBJTYPE_CONFIG,0,'DoMessage','"Welcome to the demo run!",64','Sample initialization/config method call')
		   DELETE NEXT 1
		
		   INSERT INTO (ALIAS()) VALUES ;
		     (OUTPUTCLASS_OBJTYPE_CONFIG,0,'TargetFileName','"xxx"','Sample initialization/config property')
		   DELETE NEXT 1
		   USE
		   
		ENDIF   
		
		SELECT (m.liSelect)   
	ENDPROC

	PROCEDURE currentpageimagefilename_assign
		LPARAMETERS m.tvNewVal
		IF VARTYPE(m.tvNewVal) # "C"
		   THIS.currentPageImageFilename = ""
		ELSE
		   THIS.currentPageImageFilename = m.tvNewVal
		ENDIF   
		   
		
	ENDPROC

	PROCEDURE Destroy
		THIS.CloseTargetFile()
		DODEFAULT()
	ENDPROC

	PROCEDURE externalfilelocation_assign
		LPARAMETERS m.vNewVal
		IF THIS.isRunning AND NOT EMPTY(THIS.externalFileLocation)
		   RETURN
		ENDIF   
		IF VARTYPE(m.vNewVal) = "C"
		   THIS.externalFileLocation = ALLTRIM(m.vNewVal)
		   IF NOT EMPTY(THIS.externalFileLocation)
		         THIS.externalFileLocation = ADDBS(THIS.externalFileLocation)
		   ENDIF 
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE generatepageimagefilename		&& Creates a filename for a generated page image file.
		LPARAMETERS m.tiPage, m.tlFullPath
		LOCAL lcFileName
		
		m.lcFileName = FORCEEXT(JUSTSTEM(THIS.targetFileName) + ;
		                        "_" + ;
		                        PADL(TRANSFORM(m.tiPage),;
		                             OUTPUTFILE_MAX_FILEPLACES ,"0"), ;
		                        THIS.pageImageExtension)
		IF m.tlFullPath
		   RETURN  FULLPATH(FORCEPATH( m.lcFileName,THIS.ExternalFileLocation),;
		                    ADDBS(JUSTPATH(THIS.TargetFileName)))
		ELSE
		   RETURN FORCEPATH(m.lcFileName,THIS.externalFileLocation)
		ENDIF          
		       
		        
	ENDPROC

	PROCEDURE getconfigtable		&& Assesses and provides the name of the current configuration table, optionally creating it on disk if it is not available.
		LPARAMETERS m.tlForceExternal
		
		LOCAL m.lcDBF, m.lcPath
		
		m.lcDBF = ""
		
		IF m.tlForceExternal OR (NOT EMPTY(SYS(2000,FULLPATH(FORCEEXT(OUTPUTCLASS_EXTERNALDBF,"DBF")))))
		   m.lcDBF = FULLPATH(FORCEEXT(OUTPUTCLASS_EXTERNALDBF,"DBF"))
		ELSE
		   m.lcDBF = FORCEEXT(OUTPUTCLASS_INTERNALDBF,"DBF")
		ENDIF
		   
		IF NOT (FILE(m.lcDBF) OR THIS.IsRunning)
		
		      m.lcPath = THIS.GetPathForExternals()
		      * this may be the internal *or* external dbf name;
		      * we could be testing and not yet built into an app,
		      * so accept either, before the next test:
		      m.lcDBF = FORCEPATH(m.lcDBF,m.lcPath) 
		      
		      IF NOT FILE(m.lcDBF)
		         * now force to the external name:
		         m.lcDBF = FORCEEXT(FORCEPATH(OUTPUTCLASS_EXTERNALDBF,m.lcPath),"DBF")
		         * now check again
		         IF NOT FILE(m.lcDBF)
		            THIS.CreateConfigTable(m.lcDBF)
		            IF FILE(m.lcDBF)
		               THIS.DoMessage(OUTPUTCLASS_CONFIGTABLECREATED_LOC)
		            ENDIF
		         ENDIF
		      ENDIF
		
		ENDIF 
		
		IF NOT FILE(m.lcDBF)
		   m.lcDBF = ""
		ENDIF  
		
		THIS.ConfigurationTable = m.lcDBF
		
		RETURN m.lcDBF
	ENDPROC

	PROTECTED PROCEDURE getpageimageextension		&& Provides the appropriate file extension for the current pageImageType value.
		LOCAL lcExt
		m.lcExt = ""
		DO CASE
		CASE INLIST(THIS.pageImageType,;
		            LISTENER_DEVICE_TYPE_TIF,;
		            LISTENER_DEVICE_TYPE_MTIF)
		   m.lcExt = "TIF"            
		CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_JPG
		   m.lcExt = "JPG"
		CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_GIF
		   m.lcExt = "GIF"
		CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_PNG
		   m.lcExt = "PNG"
		CASE THIS.pageImageType = LISTENER_DEVICE_TYPE_BMP
		   m.lcExt = "BMP"
		ENDCASE
		
		RETURN m.lcExt
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   * NB: this one doesn't necessarily need its
		   * own AppName LOC'd value, because
		   * it is basically an abstract layer 
		   * and should not be instantiated directly.
		   * Doesn't hurt, though.
		   THIS.appName = OUTPUTFILE_APPNAME_LOC
		
		   IF INLIST(THIS.ReadConfiguration,;
		                  OUTPUTCLASS_READCONFIG_INIT,;
		                  OUTPUTCLASS_READCONFIG_BOTH)
		     THIS.SetConfiguration(.T.)
		   ENDIF   
		
		ELSE
		
		   RETURN .F.   
		
		ENDIF
		
		RETURN NOT THIS.HadError
	ENDPROC

	PROTECTED PROCEDURE makeexternalfilelocationreachable		&& Checks to see if the externalFileLocation (which may be relative to the current targetfilename) exists in the current environment, adjusting if necessary when the output process determines the need to create ancillary output files along with main target.
		IF EMPTY(THIS.externalFileLocation) 
		   THIS.externalFileLocation = "."
		ENDIF
		IF NOT DIRECTORY(FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))     
		   TRY
		     MD (FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))     
		   CATCH
		     LOCAL m.llRunning 
		     m.llRunning = THIS.isRunning
		     THIS.isRunning = .F.
		     THIS.externalFileLocation = "."
		     THIS.isRunning = m.llRunning
		   ENDTRY
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE opentargetfile		&& Initializes a file for output purposes.
		   THIS.VerifyTargetFile() 
		
		   THIS.TargetHandle = FCREATE(THIS.TargetFileName)
		 
		   IF THIS.TargetHandle < 0 OR THIS.HadError
		      THIS.HadError = .T.
		      THIS.DoMessage(OUTPUTCLASS_NOFILECREATE_LOC,MB_ICONSTOP )
		      THIS.lastErrorMessage = OUTPUTCLASS_NOFILECREATE_LOC
		   ENDIF
		
		RETURN (NOT THIS.HadError)
		     
	ENDPROC

	PROCEDURE OutputPage
		LPARAMETERS nPageNo, eDevice, nDeviceType, nLeft, nTop, nWidth, nHeight, nClipLeft, nClipTop, nClipWidth, nClipHeight
		
		IF THIS.supportsPageImages("OUTPUTPAGE")
		   IF m.nDeviceType < 100
		      * ascertain that this is the native call; have to make
		      * sure it's not recursive... 
		      THIS.OutputPageImage(m.nPageNo)
		   ENDIF
		ELSE
		   IF m.nDeviceType > 99
		      DODEFAULT(nPageNo, eDevice, nDeviceType)   
		   ENDIF
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE outputpageimage		&& Use OutputPage method to create a page image file according to current report's requirements.
		LPARAMETERS m.tiPage
		
		LOCAL m.lcFile, m.llError
		
		TRY
		   IF THIS.pageImageType = LISTENER_DEVICE_TYPE_MTIF 
		      m.lcFile = THIS.generatePageImageFilename(1, .T.) 
		      IF m.tiPage = 1 
		         IF NOT EMPTY(SYS(2000,m.lcFile))
		            ERASE (m.lcFile) NORECYCLE
		         ENDIF
		         THIS.OutputPage(m.tiPage,m.lcFile,LISTENER_DEVICE_TYPE_TIF )
		      ELSE
		         THIS.OutputPage(m.tiPage,m.lcFile,LISTENER_DEVICE_TYPE_MTIF )
		      ENDIF   
		   ELSE
		      m.lcFile = THIS.generatePageImageFilename(m.tiPage, .T.)   
		      IF NOT EMPTY(SYS(2000,m.lcFile))
		         ERASE (m.lcFile) NORECYCLE
		      ENDIF
		      THIS.OutputPage(m.tiPage,m.lcFile,THIS.pageImageType)
		   ENDIF   
		CATCH WHEN .T.
		   m.llError = .T.
		ENDTRY
		
		RETURN (NOT m.llError)
		
	ENDPROC

	PROCEDURE pageimagetype_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" AND ;
		   (m.vNewVal = 0 OR ;
		   INLIST(m.vNewVal,;
		          LISTENER_DEVICE_TYPE_EMF,;
		          LISTENER_DEVICE_TYPE_TIF,;
		          LISTENER_DEVICE_TYPE_JPG,;
		          LISTENER_DEVICE_TYPE_GIF,;
		          LISTENER_DEVICE_TYPE_PNG,;
		          LISTENER_DEVICE_TYPE_BMP,;
		          LISTENER_DEVICE_TYPE_MTIF))
		   THIS.pageImageType = m.vNewVal
		   THIS.pageImageExtension = THIS.getPageImageExtension() 
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE readconfiguration_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
		   THIS.ReadConfiguration = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE setconfiguration		&& Checks the current configuration table for dynamic information in records of appropriate type, and executes these instructions if found.
		LPARAMETERS m.tlCalledFromInit
		
		IF NOT THIS.IsRunning 
		   * do some config work, don't change sessions --
		   * at this point we don't have our private session
		   * if we're being called in the Init
		
		   LOCAL m.liSelect, m.lcPEM, m.llOpened, m.lcOrder, m.liType, m.llQuiet
		  
		   m.liSelect = SELECT(0)
		
		   IF NOT USED("OutputConfig")
		      * if called from Init, 
		      * do this in quietmode
		      * because the caller has no
		      * opportunity to 
		      * turn off the message
		      m.llQuiet = (m.tlCalledFromInit AND NOT THIS.QuietMode)
		      IF m.llQuiet
		         THIS.QuietMode = .T.
		      ENDIF
		      THIS.GetConfigTable()
		      IF m.llQuiet
		         THIS.QuietMode = .F.
		      ENDIF
		      USE (THIS.ConfigurationTable) ALIAS "OutputConfig" IN 0 AGAIN NOUPDATE SHARED
		      m.llOpened = .T.
		   ELSE 
		      m.lcOrder = ORDER("OutputConfig")
		      SET ORDER TO ObjCode
		   ENDIF
		
		   IF (NOT THIS.HadError) AND THIS.VerifyConfigTable("OutputConfig")
		
		      SELECT OutputConfig
		      m.liType = THIS.ConfigurationObjtype
		
		      SCAN FOR ObjType = m.liType AND ;
		            NOT(DELETED() OR ;
		                ObjName == "" OR ;
		                ObjValue =="" )
		          
		         IF PEMSTATUS(THIS,ObjName,5) 
		            m.lcPEM = UPPER(PEMSTATUS(THIS,ObjName,3))
		            DO CASE
		            CASE lcPEM == "PROPERTY"
		               STORE EVAL(ObjValue) TO ("THIS."+ObjName)
		            CASE INLIST("|"+lcPEM+"|","|METHOD|","|EVENT|")
		               EVAL("THIS."+ObjName+"("+ObjValue+")")
		            OTHERWISE
		            ENDCASE
		          ENDIF
		
		      ENDSCAN
		
		      IF m.llOpened
		         USE IN OutputConfig
		      ELSE
		         SET ORDER TO (m.lcOrder) IN OutputConfig   
		      ENDIF   
		
		   ENDIF   
		
		   SELECT (m.liSelect)
		
		ENDIF   
		
	ENDPROC

	PROCEDURE setfrxdatasessionenvironment
		DODEFAULT()
		SET DELETED ON
		SET EXCLUSIVE OFF
		SET TALK OFF
		
	ENDPROC

	PROTECTED PROCEDURE supportspageimages		&& Evaluates whether the current reporting mode supports generating page images.
		LPARAMETERS tcMethodToken
		
		DO CASE
		CASE THIS.isSuccessor OR EMPTY(THIS.pageImageType)
		   RETURN .F.    
		CASE EMPTY(m.tcMethodToken)
		   RETURN THIS.ListenerType # LISTENER_TYPE_DEF
		        * this indicates the set we are supporting in total
		CASE m.tcMethodToken = "OUTPUTPAGE"
		   RETURN INLIST(THIS.ListenerType,LISTENER_TYPE_PRN,LISTENER_TYPE_PAGED)
		CASE INLIST(m.tcMethodToken,"AFTERREPORT","UNLOADREPORT")
		   RETURN INLIST(THIS.ListenerType,LISTENER_TYPE_PRV,LISTENER_TYPE_ALLPGS)
		ENDCASE  
	ENDPROC

	PROCEDURE targetfileext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT THIS.IsRunning
		   THIS.targetfileext = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE targetfilename_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND NOT THIS.IsRunning
		   THIS.targetfilename = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE targethandle_assign
		LPARAMETERS m.vNewVal
		* Readonly during report run
		IF VARTYPE(m.vNewVal) = "N" AND NOT THIS.IsRunning
		   THIS.targethandle = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE verifyconfigtable		&& Ascertains that the format and and contents of the configuration meet requirements, adjusting it if necessary.
		LPARAMETERS m.tcAlias, m.tcFailureMsgTable, m.tcFailureMsgIndexes
		
		IF EMPTY(m.tcAlias) OR VARTYPE(m.tcAlias) # "C"
		   RETURN .F.
		ENDIF
		LOCAL m.lcTable, m.lcMessage, m.lcAlias, m.liSelect, ;
		      m.llReturn, m.liTagCount, laRequired[1], laKeys[1], ;
		      m.liFound, m.llExactOff, m.llSafetyOn
		
		m.llReturn = ;
		       TYPE(m.tcAlias+".OBJTYPE") = "N" AND ;
		       TYPE(m.tcAlias+".OBJCODE") = "N" AND ;  
		       TYPE(m.tcAlias+".OBJNAME") = "C" AND ;
		       TYPE(m.tcAlias+".OBJVALUE") = "C" AND ;
		       TYPE(m.tcAlias+".OBJINFO") = "M" 
		       
		* additional fields may be included and order
		* is not significant
		       
		IF NOT m.llReturn
		   
		   m.lcMessage = IIF(EMPTY(m.tcFailureMsgTable),;
		                         OUTPUTCLASS_CONFIGTABLEWRONG_LOC, ;
		                         m.tcFailureMsgTable)  + ;
		               CHR(13)+CHR(13)+ ;
		               DBF(m.tcAlias)
		ENDIF   
		
		
		IF m.llReturn
		
		   IF (SET("EXACT") = "OFF")
		      SET EXACT ON
		      m.llExactOff = .T.
		   ENDIF
		   
		   m.liSelect = SELECT(0)
		   SELECT (m.tcAlias)
		
		   * check for required keys...
		
		   DIME laRequired[5]
		   laRequired[1] = "OBJTYPE"
		   laRequired[2] = "OBJCODE"
		   laRequired[3] = "OBJNAME"
		   laRequired[4] = "OBJVALUE"
		   laRequired[5] = "DELETED()"   
		
		   IF TAGCOUNT() > 0
		      DIME laKeys[TAGCOUNT()]
		
		      FOR m.liTagCount = 1 TO TAGCOUNT()
		          laKeys[m.liTagCount] = UPPER(KEY(m.liTagCount))
		      ENDFOR
		   
		      FOR m.liTagCount = 1 TO ALEN(laRequired)
		         m.liFound = ASCAN(laKeys,UPPER(laRequired[m.liTagCount]))
		         IF m.liFound = 0
		            m.llReturn = .F.
		            EXIT
		         ENDIF
		      ENDFOR
		   ELSE
		      m.llReturn = .F.
		   ENDIF      
		   
		   IF NOT m.llReturn
		   
		     m.llSafetyOn = (SET("SAFETY") = "ON")
		     SET SAFETY OFF
		   
		     TRY
		         USE (DBF(m.tcAlias)) EXCLU ALIAS (m.tcAlias)
		         INDEX ON Objtype TAG ObjType
		         INDEX ON ObjCode TAG ObjCode
		         INDEX ON ObjName TAG ObjName
		         INDEX ON ObjValue TAG ObjValue
		         INDEX ON DELETED() TAG OnDeleted    
		         m.llReturn = .T.
		      CATCH
		      ENDTRY   
		      
		      IF m.llSafetyOn
		         SET SAFETY ON
		      ENDIF
		      
		      IF m.llReturn
		         DIME laKeys[TAGCOUNT()]
		
		         FOR m.liTagCount = 1 TO TAGCOUNT()
		             laKeys[m.liTagCount] = UPPER(KEY(m.liTagCount))
		         ENDFOR
		   
		         FOR m.liTagCount = 1 TO ALEN(laRequired)
		            m.liFound = ASCAN(laKeys,UPPER(laRequired[m.liTagCount]))
		            IF m.liFound = 0
		               m.llReturn = .F.
		               EXIT
		            ENDIF
		         ENDFOR
		      ENDIF
		
		      USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
		   
		   ENDIF
		   
		   IF NOT m.llReturn
		      m.lcMessage =  IIF(EMPTY(m.tcFailureMsgIndexes),;
		                         OUTPUTCLASS_CONFIGINDEXMISSING_LOC, ;
		                         m.tcFailureMsgTable) + CHR(13) 
		      FOR m.liTagCount = 1 TO ALEN(laRequired)
		          m.lcMessage = m.lcMessage +  CHR(13) + ;
		                      laRequired[m.liTagCount] 
		      ENDFOR
		   ENDIF
		   
		   IF m.llExactOff
		      SET EXACT OFF
		   ENDIF
		   SELECT (m.liSelect) 
		
		ENDIF
		
		IF NOT(m.llReturn)
		   THIS.DoMessage(m.lcMessage,MB_ICONSTOP )
		   THIS.lastErrorMessage = m.lcMessage
		ENDIF   
		
		RETURN m.llReturn       
		
		   
	ENDPROC

	PROCEDURE verifytargetfile		&& Assures that the nominated filename and its network location are available at the beginning of a file-based report run.
		LOCAL m.lcFile
		
		m.lcFile =  ALLTR(CHRTRAN(CHRTRAN(THIS.TargetFileName,;
		                       OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_"),"/","\"))
		* embracing chrtran for slashes is necessary because of FULLPATH behavior.
		
		IF NOT DIRECTORY(JUSTPATH(m.lcFile))
		   m.lcFile = FULLPATH(ALLTR(m.lcFile))
		ENDIF   
		
		IF DIRECTORY(m.lcFile)
		   * we have to generate a filename
		   m.lcFile = FORCEPATH(SYS(2015), m.lcFile)
		ENDIF
		
		THIS.TargetFileName = m.lcFile   
		
		IF JUSTEXT(THIS.TargetFileName) == "" AND ;
		   RIGHT(THIS.TargetFileName,1) # "."      
		
		   THIS.TargetFileExt = CHRTRAN(THIS.TargetFileExt,;
		                        OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_")
		
		   THIS.TargetFileName = FORCEEXT(THIS.TargetFileName, ;
		                                    THIS.TargetFileExt)
		ENDIF                                 
		 
		IF NOT EMPTY(SYS(2000,THIS.TargetFileName))
		   ERASE (THIS.TargetFileName) NORECYCLE
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS xmldisplaylistener AS xmllistener OF "_reportlistener.vcx" 		&& Tunes XML settings suitably for presentation output needs, and adds image-file-publishing capabilities.
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: adjustshapeaspectratio		&& Adjust the height and width for the rendered contents of a Picture layout control to give accurate aspect ratio for the current file.
		*m: checkreportforgeneralfields		&& Performs startup chores necessary to save out copies of general fields on disk when a report is rendered.
		*m: copyimagefilestoexternalfilelocation_assign
		*m: fillalphaattr_assign
		*m: fillblueattr_assign
		*m: fillgreenattr_assign
		*m: fillredattr_assign
		*m: fontnameattr_assign
		*m: fontsizeattr_assign
		*m: fontstyleattr_assign
		*m: imagefilebasename_assign
		*m: imagesrcattr_assign
		*m: initializefilecopysettings		&& Provides required environment settings for non-filebased images to be copied to files at runtime.
		*m: penalphaattr_assign
		*m: penblueattr_assign
		*m: pengreenattr_assign
		*m: penredattr_assign
		*p: copyimagefilestoexternalfilelocation		&& Indicates whether file-based images should be copied to a  common location from their original locations on your disk, for reference  as image sources in the XML output.
		*p: fillalphaattr		&& Supplies the name of the XML attribute used to show the Fill-Alpha  value provided to a field control layout object by EvaluateContents processing.
		*p: fillblueattr		&& Supplies the name of the XML attribute used to show the Fill-Blue value provided to a field control layout object by EvaluateContents processing.
		*p: fillgreenattr		&& Supplies the name of the XML attribute used to show the Fill-Green value provided to a field control layout object by EvaluateContents processing.
		*p: fillredattr		&& Supplies the name of the XML attribute used to show the Fill-Red value provided to a field control layout object by EvaluateContents processing.
		*p: fontnameattr		&& Supplies the name of the XML attribute used to show the Font-Name value provided to a field control layout object by EvaluateContents processing.
		*p: fontsizeattr		&& Supplies the name of the XML attribute used to show the Font-Size value provided to a field control layout object by EvaluateContents processing.
		*p: fontstyleattr		&& Supplies the name of the XML attribute used to show the Font-Style value provided to a field control layout object by EvaluateContents processing.
		*p: imagefieldinstance		&& Keeps count of image instances for use in generating unique filenames for disk versions of non-filebased images in the report.
		*p: imagefieldtofile		&& Holds generated filename for image being rendered to disk from a non-filebased image.
		*p: imagefilebasename		&& Assigns an optional  prefix to be added to generated image file names when image files are saved to disk during the rendering of general fields in a report run
		*p: imagesrcattr		&& Supplies the name of the XML attribute used to show filename copied, or generated for non-filebased images, at runtime.
		*p: jpgclsid		&& Provides the GUID used when accessing GDI+ to request a file to be saved as JPG type.
		*p: oldexternalfilelocation		&& Saves the user's old externalFileLocation information during a report run, if the Listener has to temporarily change it to generate  image files from non-filebased images.
		*p: oldsendgdiplusimage		&& Saves the user's preference for GDIPlus image handle receipt if the Listener has to temporary change this setting to generate image files from non-filebased images.
		*p: penalphaattr		&& Supplies the name of the XML attribute used to show the Pen-Alpha value provided to a field control layout object by EvaluateContents processing.
		*p: penblueattr		&& Supplies the name of the XML attribute used to show the Pen-Blue value provided to a field control layout object by EvaluateContents processing.
		*p: pengreenattr		&& Supplies the name of the XML attribute used to show the Pen-Green value provided to a field control layout object by EvaluateContents processing.
		*p: penredattr		&& Supplies the name of the XML attribute used to show the Pen-Red value provided to a field control layout object by EvaluateContents processing.
		*p: utilityimage		&& Utility image object for handling aspect ratio of scale-and-retain filebased images.
	*</DefinedPropArrayMethod>

	PROTECTED imagefieldinstance,imagefieldtofile,jpgclsid,oldexternalfilelocation,oldsendgdiplusimage,utilityimage
	externalfilelocation = ("")
	fillalphaattr = ("FA")		&& Supplies the name of the XML attribute used to show the Fill-Alpha  value provided to a field control layout object by EvaluateContents processing.
	fillblueattr = ("FB")		&& Supplies the name of the XML attribute used to show the Fill-Blue value provided to a field control layout object by EvaluateContents processing.
	fillgreenattr = ("FG")		&& Supplies the name of the XML attribute used to show the Fill-Green value provided to a field control layout object by EvaluateContents processing.
	fillredattr = ("FR")		&& Supplies the name of the XML attribute used to show the Fill-Red value provided to a field control layout object by EvaluateContents processing.
	fontnameattr = ("FNAME")		&& Supplies the name of the XML attribute used to show the Font-Name value provided to a field control layout object by EvaluateContents processing.
	fontsizeattr = ("FSIZE")		&& Supplies the name of the XML attribute used to show the Font-Size value provided to a field control layout object by EvaluateContents processing.
	fontstyleattr = ("FSTYLE")		&& Supplies the name of the XML attribute used to show the Font-Style value provided to a field control layout object by EvaluateContents processing.
	FRXDataSession = -1
	imagefieldinstance = 0		&& Keeps count of image instances for use in generating unique filenames for disk versions of non-filebased images in the report.
	imagefieldtofile = ("")		&& Holds generated filename for image being rendered to disk from a non-filebased image.
	imagefilebasename = ("")		&& Assigns an optional  prefix to be added to generated image file names when image files are saved to disk during the rendering of general fields in a report run
	imagesrcattr = ("img")		&& Supplies the name of the XML attribute used to show filename copied, or generated for non-filebased images, at runtime.
	includebandswithnoobjects = .T.
	includeformattinginlayoutobjects = .T.
	jpgclsid = (.NULL.)		&& Provides the GUID used when accessing GDI+ to request a file to be saved as JPG type.
	Name = "xmldisplaylistener"
	oldexternalfilelocation = ("")		&& Saves the user's old externalFileLocation information during a report run, if the Listener has to temporarily change it to generate  image files from non-filebased images.
	oldsendgdiplusimage = 0		&& Saves the user's preference for GDIPlus image handle receipt if the Listener has to temporary change this setting to generate image files from non-filebased images.
	penalphaattr = ("PA")		&& Supplies the name of the XML attribute used to show the Pen-Alpha value provided to a field control layout object by EvaluateContents processing.
	penblueattr = ("PB")		&& Supplies the name of the XML attribute used to show the Pen-Blue value provided to a field control layout object by EvaluateContents processing.
	pengreenattr = ("PG")		&& Supplies the name of the XML attribute used to show the Pen-Green value provided to a field control layout object by EvaluateContents processing.
	penredattr = ("PR")		&& Supplies the name of the XML attribute used to show the Pen-Red value provided to a field control layout object by EvaluateContents processing.
	utilityimage = .NULL.		&& Utility image object for handling aspect ratio of scale-and-retain filebased images.
	_memberdata = <VFPData>
		<memberdata name="copyimagefilestoexternalfilelocation" type="property" display="copyImageFilesToExternalFileLocation" favorites="True" />
		<memberdata name="imagefieldinstance" type="property" display="imageFieldInstance"  />
		<memberdata name="imagefieldtofile" type="property" display="imageFieldToFile"  />
		<memberdata name="imagefilebasename" type="property" display="imageFileBaseName" favorites="True" />
		<memberdata name="imagesrcattr" type="property" display="imageSrcAttr" favorites="True" />
		<memberdata name="jpgclsid" type="property" display="JPGclsid" />
		<memberdata name="oldexternalfilelocation" type="property" display="oldExternalFileLocation"  />
		<memberdata name="oldsendgdiplusimage" type="property" display="oldSendGDIPlusImage"/>
		<memberdata name="checkreportforgeneralfields" type="method" display="checkReportForGeneralFields" />
		<memberdata name="initializefilecopysettings" type="method" display="initializeFileCopySettings" />
		<memberdata name="utilityimage" type="property" display="utilityImage" />
		<memberdata name="adjustshapeaspectratio" type="method" display="adjustShapeAspectRatio" />
		<memberdata name="fillalphaattr" display="fillAlphaAttr" type="property"/>
		<memberdata name="fillredattr" display="fillRedAttr" type="property"/>
		<memberdata name="fillgreenattr" display="fillGreenAttr" type="property"/>
		<memberdata name="fillblueattr" display="fillBlueAttr" type="property"/>
		<memberdata name="penalphaattr" display="penAlphaAttr" type="property"/>
		<memberdata name="penredattr" display="penRedAttr" type="property"/>
		<memberdata name="pengreenattr" display="penGreenAttr" type="property"/>
		<memberdata name="penblueattr" display="penBlueAttr" type="property"/>
		<memberdata name="fontnameattr" display="fontNameAttr" type="property"/>
		<memberdata name="fontstyleattr" display="fontStyleAttr" type="property"/>
		<memberdata name="fontsizeattr" display="fontSizeAttr" type="property"/>
		</VFPData>
	
	PROTECTED PROCEDURE adjustshapeaspectratio		&& Adjust the height and width for the rendered contents of a Picture layout control to give accurate aspect ratio for the current file.
		LPARAMETERS m.tnWidth, m.tnHeight
		IF VARTYPE(THIS.utilityImage) = "O"
		   * the image is coming from a file of some sort
		   * and we need to scale-and-retain
		   LOCAL m.llAdjustHeight, m.llAdjustWidth
		   DO CASE
		   CASE (tnWidth < tnHeight) 
		        * use 100% of the width of the space and scale the height        
		        m.llAdjustHeight = .T.
		   CASE (tnWidth > tnHeight) 
		        * use 100% of the height of the space and scale the width
		        m.llAdjustWidth = .T.
		   CASE (m.tnWidth = m.tnHeight) 
		       DO CASE
		       CASE THIS.utilityImage.Height > THIS.utilityImage.Width
		           m.llAdjustWidth = .T.
		       CASE THIS.utilityImage.Height < THIS.utilityImage.Width
		           m.llAdjustHeight = .T.
		       OTHERWISE
		           * both square, don't do adjustment
		       ENDCASE           
		   ENDCASE        
		   If m.llAdjustWidth
		      m.tnWidth = m.tnHeight *  ;
		         (THIS.utilityImage.Width / THIS.utilityImage.Height)
		   ENDIF
		   If m.llAdjustHeight
		      m.tnHeight = m.tnWidth * ;
		         (THIS.utilityImage.Height / THIS.utilityImage.Width)
		   ENDIF
		ENDIF
	ENDPROC

	PROCEDURE AfterReport
		LPARAMETERS tlCalledEarly
		DODEFAULT(tlCalledEarly)
		THIS.resetDataSession() 
	ENDPROC

	PROCEDURE BeforeReport
		IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
		   THIS.oldSendGDIPlusImage = THIS.SendGDIPlusImage     
		   THIS.oldExternalFileLocation =  THIS.ExternalFileLocation    
		   THIS.JPGclsid = NULL && force reinitialization for each report
		                        && on possible discovery of an image control mid-way
		   IF THIS.checkReportForGeneralFields() 
		      THIS.initializeFileCopySettings()
		   ENDIF    
		ENDIF   
		DODEFAULT()
		THIS.resetDataSession()
		
	ENDPROC

	PROTECTED PROCEDURE checkreportforgeneralfields		&& Performs startup chores necessary to save out copies of general fields on disk when a report is rendered.
		LOCAL m.liGeneralFields, m.lcID, m.llOpened
		
		m.liGeneralFields = 0
		
		IF TYPE("THIS.CommandClauses.File") = "C" AND ;
		   (NOT EMPTY(THIS.CommandClauses.File)) AND ;
		   (FILE(THIS.CommandClauses.File)) && NB this is done before setting up dummy CommandClauses
		   
		   THIS.SetFRXDataSession()
		
		   IF USED("FRX") 
		      * this will be true
		      * if we call in BeforeReport,
		      * but that seems to cause a problem,
		      * when we re-assign SendGDIPlusImage
		      * so we're likely to call earlier,
		      * in the LoadReport method
		      SELECT FRX
		   ELSE
		      USE (THIS.CommandClauses.File) SHARED NOUPDATE ALIAS FRX IN 0
		      SELECT FRX
		      m.llOpened = .T.
		   ENDIF   
		
		   COUNT FOR ObjType = FRX_OBJTYP_PICTURE  AND  ;
		           Offset =  FRX_PICTURE_SOURCE_GENERAL TO ;
		             m.liGeneralFields
		
		   IF m.llOpened
		      USE IN FRX         
		   ENDIF
		
		   THIS.ResetDataSession()
		ENDIF  
		
		RETURN ( m.liGeneralFields > 0 )
		
		
		
	ENDPROC

	PROCEDURE contattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.ContAttr
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.ContAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE copyimagefilestoexternalfilelocation_assign
		LPARAMETERS m.vNewVal
		IF NOT THIS.IsRunning and VARTYPE(m.vNewVal) = "L"
		   IF NOT (m.vNewVal = THIS.CopyImageFilesToExternalFileLocation)
		      THIS.CopyImageFilesToExternalFileLocation = m.vNewVal
		      THIS.adjustXSLTParameter(IIF(m.vNewVal,"1","0"),"copyImageFiles")
		      IF THIS.CopyImageFilesToExternalFileLocation 
		         THIS.makeExternalFileLocationReachable()
		      ENDIF
		   ENDIF   
		ENDIF   
		
	ENDPROC

	PROCEDURE datatextattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.dataTextAttr 
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.dataTextAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE datatypeattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.dataTypeAttr 
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.dataTypeAttr )
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE Destroy
		STORE NULL TO ;
		   THIS.JPGclsid, ;
		   THIS.FormattingChanges, ;
		   THIS.UtilityImage
		
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE EvaluateContents
		LPARAMETERS m.nFRXRecno, m.oObjProperties
		IF DODEFAULT(m.nFRXRecno,m.oObjProperties)
		   THIS.setFRXDataSession()
		   IF USED(THIS.formattingChanges) AND NOT(EOF(THIS.formattingChanges))
		      SELECT (THIS.formattingChanges) 
		      WITH m.oObjProperties
		         IF .Reload       
		              REPLACE Reload WITH .T., ;
		                   FR WITH .FillRed, ;
		                   FG WITH .FillGreen, ;
		                   FB WITH .FillBlue, ;
		                   FA WITH .FillAlpha, ;
		                   PR WITH .PenRed, ;
		                   PG WITH .PenGreen, ;
		                   PB WITH .PenBlue, ;
		                   PA WITH .PenAlpha, ;
		                   FNAME WITH .FontName, ;
		                   FSTYLE WITH .FontStyle, ;
		                   FSIZE WITH .FontSize
		         ENDIF
		      ENDWITH         
		      SELECT FRX
		   ENDIF
		   THIS.resetDataSession() 
		ENDIF   
		           
	ENDPROC

	PROCEDURE fillalphaattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) ;
		   AND NOT (m.vNewVal == THIS.fillAlphaAttr)
		   THIS.fillAlphaAttr = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
		
		
		
		
		
	ENDPROC

	PROCEDURE fillblueattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.fillBlueAttr)
		   THIS.fillBlueAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE fillgreenattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.fillGreenAttr)
		   THIS.fillGreenAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE fillredattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.fillRedAttr)
		   THIS.fillRedAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE fontnameattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.fontNameAttr)
		   THIS.fontNameAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE fontsizeattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.fontSizeAttr)
		   THIS.fontSizeAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE fontstyleattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.fontStyleAttr)
		   THIS.fontStyleAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE getrawformattinginfo
		LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
		LOCAL m.lcInfo
		
		THIS.adjustShapeAspectRatio (@tnWidth, @tnHeight)
		
		m.lcInfo = DODEFAULT(m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType)
		IF NOT EMPTY(THIS.ImageFieldtoFile) 
		   m.lcInfo = m.lcInfo + " "+THIS.ImageSrcAttr+"='"+THIS.ImageFieldtoFile+"'"
		ENDIF   
		
		THIS.setFRXDataSession()
		IF USED(THIS.formattingChanges) AND ;
		   SEEK(RECNO("FRX"),THIS.formattingChanges,"FRXRecno")          
		   SELECT (THIS.formattingChanges)
		   IF Reload
		      m.lcInfo = m.lcInfo + " "+THIS.penAlphaAttr+"='"+TRANSFORM(PA)+"'"      
		      m.lcInfo = m.lcInfo + " "+THIS.penRedAttr+"='"+TRANSFORM(PR)+"'"      
		      m.lcInfo = m.lcInfo + " "+THIS.penGreenAttr+"='"+TRANSFORM(PG)+"'"      
		      m.lcInfo = m.lcInfo + " "+THIS.penBlueAttr+"='"+TRANSFORM(PB)+"'"                                       
		      m.lcInfo = m.lcInfo + " "+THIS.fillAlphaAttr+"='"+TRANSFORM(FA)+"'"      
		      m.lcInfo = m.lcInfo + " "+THIS.fillRedAttr+"='"+TRANSFORM(FR)+"'"      
		      m.lcInfo = m.lcInfo + " "+THIS.fillGreenAttr+"='"+TRANSFORM(FG)+"'"      
		      m.lcInfo = m.lcInfo + " "+THIS.fillBlueAttr+"='"+TRANSFORM(FB)+"'"                                       
		      m.lcInfo = m.lcInfo + " "+THIS.fontNameAttr+"='"+TRANSFORM(FNAME)+"'"   
		      m.lcInfo = m.lcInfo + " "+THIS.fontSizeAttr+"='"+TRANSFORM(FSIZE)+"'"   
		      m.lcInfo = m.lcInfo + " "+THIS.fontStyleAttr+"='"+TRANSFORM(FSTYLE)+"'"                         
		   ENDIF
		   SELECT FRX
		ENDIF
		
		RETURN m.lcInfo
	ENDPROC

	PROCEDURE getvfprdlcontents
		LPARAMETERS m.tcNodeName, m.tlAsString
		
		IF VARTYPE(THIS.CommandClauses) = "O"
		
		   ADDPROPERTY(THIS.CommandClauses,;
		             "externalFileLocation", ;
		             THIS.externalFileLocation)
		             
		   ADDPROPERTY(THIS.CommandClauses, ;
		            "copyImageFilesToExternalFileLocation", ;
		            THIS.copyImageFilesToExternalFileLocation) 
		            
		   ADDPROPERTY(THIS.CommandClauses, ;
		            "imageFileBaseName", ;
		            THIS.imageFileBaseName)             
		ENDIF            
		            
		RETURN DODEFAULT(m.tcNodeName, m.tlAsString)                         
	ENDPROC

	PROCEDURE heightattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.HeightAttr
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.HeightAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE idattribute_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.IdAttribute
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.IdAttribute)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE idrefattribute_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.IdRefAttribute
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.IdRefAttribute)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE imagefilebasename_assign
		LPARAMETERS m.vNewVal
		THIS.ImageFileBaseName = ALLTR(CHRTRAN(JUSTSTEM(TRANSFORM(m.vNewVal)),;
		                         OUTPUTCLASS_FILENAME_CHARS_DISALLOWED,"_"))
	ENDPROC

	PROCEDURE imagesrcattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal) AND ;
		   (NOT m.vNewVal == THIS.imageSrcAttr)
		   THIS.imageSrcAttr = m.vNewVal
		   THIS.SynchXSLTProcessorUser()
		ENDIF      
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   THIS.AppName = OUTPUTXMLDISPLAY_APPNAME_LOC
		ELSE
		   RETURN .F.   
		ENDIF
		
		RETURN NOT THIS.HadError
	ENDPROC

	PROTECTED PROCEDURE initializefilecopysettings		&& Provides required environment settings for non-filebased images to be copied to files at runtime.
		#define CLSID_JPG 	"{557CF401-1A04-11D3-9A73-0000F81EF32E}"
		
		
		DECLARE INTEGER GdipSaveImageToFile in GDIPLUS.DLL  ;
		       integer image,string filename,string @ CLSID_clsidEncoder,integer encoderParams        
		
		LOCAL m.lcID
		
		IF ISNULL(THIS.Jpgclsid) OR EMPTY(THIS.Jpgclsid)
		   DECLARE integer CLSIDFromString IN ole32 string,string @
		   m.lcID = SPACE(20)
		   CLSIDFromString(STRCONV(CLSID_JPG ,STRCONV_DBCS_UNICODE),@m.lcID)      
		   THIS.Jpgclsid = m.lcID
		   m.lcID = ""
		ENDIF
		
		IF THIS.SendGDIPlusImage < LISTENER_SEND_GDI_IMAGE_HANDLE 
		   THIS.SendGDIPlusImage =   LISTENER_SEND_GDI_IMAGE_HANDLE
		ENDIF   
		
		THIS.makeExternalFileLocationReachable()
		
	ENDPROC

	PROCEDURE initializeformattingchangescursor
		DODEFAULT()
		IF THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		   IF USED(THIS.formattingChanges)
		      USE IN (THIS.formattingChanges) && override, faster to re-create
		      CREATE CURSOR (THIS.FormattingChanges) ;
		             (FRXRecno i, ;
		              Reload l, ;
		              DText M, ;
		              DType c(1), ;
		              FA i, ;              
		              FR i, ;
		              FG i, ;              
		              FB i, ;
		              PA i, ;              
		              PR i, ;
		              PG i, ;              
		              PB i, ;
		              FName v(50), ;
		              FStyle i, ;
		              FSize i ; 
		              )
		    ELSE
		       CREATE CURSOR (THIS.FormattingChanges) ;
		             (FRXRecno i, ;
		              Reload l, ;
		              FA i, ;              
		              FR i, ;
		              FG i, ;              
		              FB i, ;
		              PA i, ;              
		              PR i, ;
		              PG i, ;              
		              PB i, ;
		              FName v(50), ;
		              FStyle i, ;
		              FSize i ; 
		              )
		    ENDIF              
		
		ENDIF
		
	ENDPROC

	PROCEDURE leftattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.LeftAttr
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.LeftAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE pageimageattr_assign
		LPARAMETERS vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.pageImageAttr
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.pageImageAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF  
	ENDPROC

	PROCEDURE penalphaattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.penAlphaAttr)
		   THIS.penAlphaAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE penblueattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.penBlueAttr)
		   THIS.penBlueAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE pengreenattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.penGreenAttr)
		   THIS.penGreenAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE penredattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal);
		   AND NOT (m.vNewVal == THIS.penRedAttr)
		   THIS.penRedAttr = m.vNewVal
		   THIS.synchXsltProcessorUser()
		ENDIF   
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS m.nFRXRecNo,m.nLeft,m.nTop,m.nWidth,m.nHeight, ;
		            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage
		
		LOCAL m.llCopyImage, m.lcFile, m.liDefaultBehavior
		
		IF m.GDIPlusImage > 0 AND ;
		  (ISNULL(THIS.Jpgclsid) OR EMPTY(THIS.Jpgclsid))
		   * we didn't have any general fields but we do have
		   * an image control, referenced as an expression,
		   * they have explicitly turned on SendGDIPlusImage, and
		   * this is the first time we're hitting an image control:
		   THIS.initializeFileCopySettings()
		ENDIF    
		
		THIS.SetFRXDataSession()
		GO m.nFRXRecNo IN FRX
		
		IF THIS.CopyImageFilesToExternalFileLocation 
		    IF (FRX.ObjType = FRX_OBJTYP_PICTURE) AND ;
		       FRX.Offset # FRX_PICTURE_SOURCE_GENERAL AND ;
		       FILE(m.cContentsToBeRendered)
		       * use FILE() function here,
		       * need to find if it is
		       * built into an app
		       m.llCopyImage = .T.
		    ENDIF
		ENDIF   
		
		IF (FRX.ObjType = FRX_OBJTYP_PICTURE) AND ;
		    FRX.General = FRX_PICTUREMODE_SCALE_KEEP_SHAPE AND ;
		    FRX.Offset # FRX_PICTURE_SOURCE_GENERAL AND ;
		    FILE(m.cContentsToBeRendered)
		    * NB: doing this *only* when necessary for re-scaling.
		    * see above for why FILE() function -- this will work
		    * with the image object.
		    THIS.utilityImage = LOADPICTURE(m.cContentsToBeRendered)
		ENDIF    
		
		THIS.SetCurrentDataSession()   
		
		DO CASE
		
		CASE m.llCopyImage
		
		   m.lcFile = FORCEPATH(m.cContentsToBeRendered, ;
		            FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))
		            
		   IF EMPTY(SYS(2000,m.lcFile))
		   
		      * used to be:
		      * COPY FILE (cContentsToBeRendered) TO (lcFile)
		      * to handle files built into an app
		      
		      STRTOFILE(FILETOSTR(m.cContentsToBeRendered),m.lcFile)
		    
		   ENDIF   
		   
		   IF EMPTY(SYS(2000,m.lcFile))
		      THIS.ImageFieldToFile = ""
		   ELSE
		      THIS.ImageFieldToFile = JUSTFNAME(m.lcFile)
		   ENDIF
		   
		CASE THIS.SendGDIPlusImage > LISTENER_SEND_GDI_IMAGE_NONE  AND ;
		   m.GDIPlusImage > 0  AND ;
		   GdipSaveImageToFile(m.GDIPlusImage,;
		       STRCONV(FORCEPATH(THIS.ImageFileBaseName + "_"+ ;
		                         TRANSFORM(THIS.ImageFieldInstance+1)+".jpg",;
		                         FULLPATH(THIS.ExternalFileLocation,ADDBS(JUSTPATH(THIS.TargetFileName))))+CHR(0), ;
		               STRCONV_DBCS_UNICODE) ,THIS.JPGCLSID,0) = 0
		
		   THIS.ImageFieldInstance = THIS.ImageFieldInstance + 1       
		
		   THIS.ImageFieldToFile = THIS.ImageFileBaseName +"_"+ ;
		                           TRANSFORM(THIS.ImageFieldInstance)+".jpg"
		
		OTHERWISE
		
		   THIS.ImageFieldToFile = ""
		
		ENDCASE
		
		m.liDefaultBehavior = DODEFAULT(m.nFRXRecNo, @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight, ;
		          @m.nObjectContinuationType, @m.cContentsToBeRendered, @m.GDIPlusImage)
		            
		THIS.ImageFieldToFile = ""
		THIS.UtilityImage = NULL
		
		THIS.resetDataSession()
		
		RETURN m.liDefaultBehavior
	ENDPROC

	PROCEDURE resetdocument
		THIS.ResetToDefault("ImageFieldInstance")
		THIS.ResetToDefault("ImageFieldToFile")
		THIS.ResetToDefault("UtilityImage")
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE setdomformattinginfo
		LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType
		
		THIS.adjustShapeAspectRatio (@m.tnWidth, @m.tnHeight)
		
		DODEFAULT( m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType)
		
		IF NOT EMPTY(THIS.ImageFieldtoFile) 
		   m.toNode.SetAttribute(THIS.ImageSrcAttr,THIS.ImageFieldtoFile )                  
		ENDIF   
		
		THIS.setFRXDataSession()
		IF USED(THIS.formattingChanges) AND ;
		   SEEK(RECNO("FRX"),THIS.formattingChanges,"FRXRecno")          
		   SELECT (THIS.formattingChanges)
		   IF Reload
		      WITH m.toNode
		          .setAttribute(THIS.penAlphaAttr,PA)
		          .setAttribute(THIS.penRedAttr,PR)
		          .setAttribute(THIS.penGreenAttr,PG)
		          .setAttribute(THIS.penBlueAttr,PB)
		          .setAttribute(THIS.fillAlphaAttr,FA)
		          .setAttribute(THIS.fillRedAttr,FR)
		          .setAttribute(THIS.fillGreenAttr,FG)
		          .setAttribute(THIS.fillBlueAttr,FB)
		          .setAttribute(THIS.fontNameAttr,FNAME)          
		          .setAttribute(THIS.fontSizeAttr,FSIZE)          
		          .setAttribute(THIS.fontStyleAttr,FSTYLE)                              
		      ENDWITH
		   ENDIF
		   SELECT FRX
		ENDIF
		
	ENDPROC

	PROCEDURE topattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.TopAttr
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.TopAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

	PROCEDURE UnloadReport
		DODEFAULT()
		IF NOT (THIS.noPageEject OR ;
		 ((TYPE("THIS.CommandClauses.NoPageEject") = "L") AND ;
		   THIS.CommandClauses.NoPageEject))
		   IF NOT ISNULL(THIS.OldExternalFileLocation)
		      * even if empty
		      THIS.ExternalFileLocation = THIS.OldExternalFileLocation
		      THIS.OldExternalFileLocation = NULL    
		   ENDIF      
		   IF NOT (THIS.OldSendGDIPlusImage = THIS.SendGDIPlusImage)
		      THIS.SendGDIPlusImage = THIS.OldSendGDIPlusImage
		   ENDIF   
		ENDIF   
		THIS.resetDataSession()
		
		
	ENDPROC

	PROCEDURE widthattr_assign
		LPARAMETERS m.vNewVal
		LOCAL m.lcVal
		m.lcVal = THIS.WidthAttr
		DODEFAULT(m.vNewVal)
		IF NOT (m.lcVal == THIS.WidthAttr)
		   THIS.SynchXSLTProcessorUser()
		ENDIF   
	ENDPROC

ENDDEFINE

DEFINE CLASS xmllistener AS utilityreportlistener OF "_reportlistener.vcx" 		&& Provides XML output from a report run.
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "reportlisteners.h"
	*<DefinedPropArrayMethod>
		*m: addrunnode		&& Adds a node to the Run portion of the XML document, looking for value results in both FRX and Report Run (Current) Data sessions.
		*m: adjustxsltparameter		&& Adds, changes, or removes a parameter in the XSLT Parameter Collection, creating the collection if necessary. Params: tvValue, tsKey, tlRemoveOnly.
		*m: applyrdltransform_access
		*m: applyusertransformtooutput		&& Applies a user-specified XSLT to XML output at the conclusion of a report run.
		*m: applyusertransform_assign
		*m: applyxslt		&& Provides generic facilities for applying XSLT to XML.
		*m: contattr_assign
		*m: currentdocument_assign
		*m: datatextattr_assign
		*m: datatypeattr_assign
		*m: evaluatestringtoboolean		&& Casts a string to .T. or .F..
		*m: fixmsxmlobjectfordtds		&& Adjust MSXML document objects to load XML with embedded DTDs properly.
		*m: formatdatavalue		&& Provides opportunity to re-format data value delivered in EvaluateContents appropriately for text/TRANSFORM'd version.
		*m: frxcharsetsinuse		&& Determine whether the FRX for a report run has layout elements with explicit charset instructions.
		*m: getdefaultuserxslt		&& Provides a hook for subclasses to supply their preferred XSLT document for use when XMLListener automatically applies XSLT at the end of a report run.
		*m: getfrxlayoutobjectfieldlist		&& Provides fields list to the getVFPRdlContents method, in a suitable comma-delimited format for inclusion as a macro in SQL SELECT statement from FRX cursor and related Bands and Objects cursors.
		*m: getpathedimageinfo		&& Supplies a fully-pathed filename for an image file included in the report, using the original relative-path information stored in the FRX.
		*m: getrawformattinginfo		&& Formulates the appropriate formatting attributes for an element when XMLListener is streaming XML to a file.
		*m: getrunnodecontents		&& Translates information dynamically generated and provided in the runCollector member into an XML format useful to other applications.
		*m: getvfprdlcontents		&& Translates report definition layout metadata, from the FRX and the current report run, into an XML format useful to other applications.
		*m: heightattr_assign
		*m: idattribute_assign
		*m: idrefattribute_assign
		*m: includebandswithnoobjects_assign
		*m: includebreaksindata_assign
		*m: includedatasourcesinvfprdl_assign
		*m: includedatatypeattributes_assign
		*m: includeformattinginlayoutobjects_assign
		*m: initializeformattingchangescursor		&& Evaluates requirements for a cursor to hold information gathered for Field layout controls during this report run and creates it if necessary.
		*m: insertxmlconfigrecords		&& Adds a record to the configuration table describing a default XML node when XML Listener is creating or editing a shared configuration table.
		*m: leftattr_assign
		*m: loadprocessorobject		&& Provides a generic means to load an XSLT processor object from a string representing an XSLT document or a filename.
		*m: nopageeject_assign
		*m: pageimageattr_assign
		*m: preparefrxcopy		&& Prepares FRX alias or copy for use in creating VFP-RDL contents.
		*m: removefrxcopy		&& Removes FRX copy used in preparing VFP-RDL.
		*m: resetdocument		&& Resets the XML document after a report run.
		*m: resetreport		&& Resets information for a report-level node during the production of an XML document that may span multiple reports.
		*m: setdomformattinginfo		&& Formulates the appropriate formatting attributes for an element when XMLListener is using the DOM to create XML.
		*m: synchxsltprocessoruser		&& Can be called in the assign of any Attribute-setting property to synchronize the XSLT associated with the class witht he new attribute values.
		*m: topattr_assign
		*m: verifyattributenames		&& Hook method called during XML Listener's augmented version of VerifyConfigTable, allowing subclasses to verify attribute names should they decide to store them in the configuration table similar to node names.
		*m: verifyncname		&& Generic method to validate strings as XML-standard NCNames.
		*m: verifynodenames		&& Method called during XML Listener's augmented version of VerifyConfigTable to check all node values in the configuration table for XML validity.
		*m: widthattr_assign
		*m: writeraw		&& Used to write raw XML data to a file.
		*m: xmlmode_assign
		*m: xmlrawconv		&& Used to convert any control characters to entity references when XML Listener is writing raw XML data to a file.
		*m: xmlrawnode		&& Used to formulate the contents of an XML element  node when XML Listener is writing the XML document as raw data to a file.
		*m: xmlrawtag		&& Used to formulate the contents of an XML tag when XML Listener is writing the XML document as raw data to a file.
		*m: xsltparameters_assign
		*m: xsltprocessorrdl_assign
		*m: xsltprocessoruser_assign
		*p: applyrdltransform		&& Indicates whether an RDL-Only transformation is available and should be applied to XML output after an RDL-Only report run.
		*p: applyusertransform		&& Indicates whether XMLListener should automatically apply an XSLT transform at the conclusion of a report run.
		*p: columnnodes		&& Holds column-level output during a report run.
		*p: contattr		&& Supplies the name of the attribute used to show continuation type for a layout object that can span bands or pages.
		*p: currentband		&& Holds information about the band for which output is currently being generated during a report run.
		*p: currentcolumn		&& Holds information about the column for which output is currently being generated during a report run.
		*p: currentdocument		&& Holds information about the XML document for which output is currently being generated during a report run.
		*p: currentpage		&& Holds information about the page for which output is currently being generated during a report run.
		*p: datanodes		&& Holds non-formatting output (title, detail, group, and summary band objects) during a report run.
		*p: datatextattr		&& Supplies the name of the XML attribute used to show the TRANSFORM'd value of the evaluated expression for a field control layout object.
		*p: datatypeattr		&& Supplies the name of the XML attribute used to show the datatype of the evaluated expression for a field control layout object.
		*p: evaluatecontentsvalues		&& An EMPTY object reference to hold changed formatting values during Rendering.
		*p: formattingchanges		&& Reference in which classes can store information about actions taken to apply dynamic changes to layout controls' formatting attributes, for later use during Render event.
		*p: heightattr		&& Supplies the name of the XML attribute used to show height for a layout object.
		*p: idattribute		&& Supplies the name of the XML attribute used to provide the FRX record number for a layout object or page number of a formatting band (column or page) object.
		*p: idrefattribute		&& Supplies the name of the XML attribute used to provide the current page for a layout object or FRX record number of a formatting band (column or page) object.
		*p: includebandswithnoobjects		&& Indicates whether band-level information for bands with no contents should be included in the XML.
		*p: includebreaksindata		&& 0 = provide page band nodes positioned along with other bands in the datastream, wherever they happen to occur, 1 = no pagebreak info, no page header and footer info, 2 = collection of pages with page headers and footers data
		*p: includedatasourcesinvfprdl		&& Indicates whether information about the source tables, relations, indexes, etc should be included in the VFPRDL metadata section of the report XML.
		*p: includedatatypeattributes		&& Indicates whether Data Type and Text information available in EvaluateContents should be included in the XML nodes generated for Field controls.
		*p: includeformattinginlayoutobjects		&& Indicates whether formatting information such as positioning attributes should be included in the report XML.
		*p: includepage		&& Evaluates whether the current page is part of the output page set and should be included in the XML document result.
		*p: leftattr		&& Supplies the name of the XML attribute used to show leftmost position for a layout object.
		*p: nopageeject		&& Indicates whether the XML Listener should consider the current report run to be continued.  Can be used without NOPAGEEJECT on the REPORT FORM command.
		*p: pageimageattr		&& Supplies the name of the XML attribute used to show the filename for an associated generated page image file.
		*p: pagenodes		&& Holds page-level output during a report run.
		*p: successorgfxnorender		&& Private gfxNoRender object instance used for rendering checks specific to this output target when this reportListener is a Successor.
		*p: topattr		&& Supplies the name of the XML attribute used to show topmost position for a layout object.
		*p: widthattr		&& Supplies the name of the XML attribute used to show width for a layout object.
		*p: xmlmode		&& 0 = data only, 1 = RDL only, 2 = data and RDL
		*p: xsltparameters		&& Holds an optional parameter collection passed to the ApplyXSLT method when XMLListener automatically  applies a user XSLT transformation at the conclusion of a report run.
		*p: xsltprocessorrdl		&& Holds an RDL-specific processor object, reserved for future use.
		*p: xsltprocessoruser		&& Holds a user-definable processor object which, if filled and available at the end of a run, can be used automatically by XML Listener to transform the raw XML document to requirements.
	*</DefinedPropArrayMethod>

	PROTECTED applyrdltransform,columnnodes,currentband,currentcolumn,currentpage,datanodes,evaluatecontentsvalues,includepage,pagenodes,successorgfxnorender,verifytargetfile
	applyrdltransform = .F.		&& Indicates whether an RDL-Only transformation is available and should be applied to XML output after an RDL-Only report run.
	columnnodes = (NULL)		&& Holds column-level output during a report run.
	contattr = ("c")		&& Supplies the name of the attribute used to show continuation type for a layout object that can span bands or pages.
	currentband = (NULL)		&& Holds information about the band for which output is currently being generated during a report run.
	currentcolumn = (NULL)		&& Holds information about the column for which output is currently being generated during a report run.
	currentdocument = (NULL)		&& Holds information about the XML document for which output is currently being generated during a report run.
	currentpage = (NULL)		&& Holds information about the page for which output is currently being generated during a report run.
	datanodes = (NULL)		&& Holds non-formatting output (title, detail, group, and summary band objects) during a report run.
	datatextattr = ("DTEXT")		&& Supplies the name of the XML attribute used to show the TRANSFORM'd value of the evaluated expression for a field control layout object.
	datatypeattr = ("DTYPE")		&& Supplies the name of the XML attribute used to show the datatype of the evaluated expression for a field control layout object.
	evaluatecontentsvalues = (.NULL.)		&& An EMPTY object reference to hold changed formatting values during Rendering.
	formattingchanges = (.NULL.)		&& Reference in which classes can store information about actions taken to apply dynamic changes to layout controls' formatting attributes, for later use during Render event.
	FRXDataSession = -1
	Height = 23
	heightattr = ("h")		&& Supplies the name of the XML attribute used to show height for a layout object.
	idattribute = ("id")		&& Supplies the name of the XML attribute used to provide the FRX record number for a layout object or page number of a formatting band (column or page) object.
	idrefattribute = ("idref")		&& Supplies the name of the XML attribute used to provide the current page for a layout object or FRX record number of a formatting band (column or page) object.
	includebreaksindata = 0		&& 0 = provide page band nodes positioned along with other bands in the datastream, wherever they happen to occur, 1 = no pagebreak info, no page header and footer info, 2 = collection of pages with page headers and footers data
	includedatatypeattributes = .F.		&& Indicates whether Data Type and Text information available in EvaluateContents should be included in the XML nodes generated for Field controls.
	includepage = .T.		&& Evaluates whether the current page is part of the output page set and should be included in the XML document result.
	leftattr = ("l")		&& Supplies the name of the XML attribute used to show leftmost position for a layout object.
	Name = "xmllistener"
	nopageeject = .F.		&& Indicates whether the XML Listener should consider the current report run to be continued.  Can be used without NOPAGEEJECT on the REPORT FORM command.
	pageimageattr = ("PLINK")		&& Supplies the name of the XML attribute used to show the filename for an associated generated page image file.
	pagenodes = (NULL)		&& Holds page-level output during a report run.
	runcollectorresetlevel = 1
	successorgfxnorender = (.NULL.)		&& Private gfxNoRender object instance used for rendering checks specific to this output target when this reportListener is a Successor.
	targetfileext = ("XML")
	topattr = ("t")		&& Supplies the name of the XML attribute used to show topmost position for a layout object.
	Width = 23
	widthattr = ("w")		&& Supplies the name of the XML attribute used to show width for a layout object.
	xmlmode = 2		&& 0 = data only, 1 = RDL only, 2 = data and RDL
	xsltparameters = (NULL)		&& Holds an optional parameter collection passed to the ApplyXSLT method when XMLListener automatically  applies a user XSLT transformation at the conclusion of a report run.
	xsltprocessorrdl = (NULL)		&& Holds an RDL-specific processor object, reserved for future use.
	xsltprocessoruser = (NULL)		&& Holds a user-definable processor object which, if filled and available at the end of a run, can be used automatically by XML Listener to transform the raw XML document to requirements.
	_memberdata = <VFPData>
		<memberdata name="applyusertransform" type="property" display="applyUserTransform" favorites="True"/>
		<memberdata name="applyusertransformtooutput" type="method" display="applyUserTransformToOutput"/>
		<memberdata name="applyxslt" type="method" display="applyXslt" favorites="True"/>
		<memberdata name="columnnodes" type="property" display="columnNodes"/>
		<memberdata name="contattr" type="property" display="contAttr" favorites="True"/>
		<memberdata name="currentband" type="property" display="currentBand"/>
		<memberdata name="currentcolumn" type="property" display="currentColumn"/>
		<memberdata name="includepage" type="property" display="includePage"/>
		<memberdata name="currentdocument" type="property" display="currentDocument" favorites="True"/>
		<memberdata name="currentpage" type="property" display="currentPage"/>
		<memberdata name="datanodes" type="property" display="dataNodes"/>
		<memberdata name="getdefaultuserxslt" type="method" display="getDefaultUserXslt"/>
		<memberdata name="preparefrxcopy" type="method" display="prepareFrxCopy"/>
		<memberdata name="removefrxcopy" type="method" display="removeFrxCopy"/>
		<memberdata name="getpathedimageinfo" type="method" display="getPathedImageInfo"/>
		<memberdata name="getrawformattinginfo" type="method" display="getRawFormattingInfo"/>
		<memberdata name="getvfprdlcontents" type="method" display="getVFPRdlContents"/>
		<memberdata name="getfrxlayoutobjectfieldlist" type="method" display="getFrxLayoutObjectFieldlist"/>
		<memberdata name="heightattr" type="property" display="heightAttr" favorites="True"/>
		<memberdata name="idattribute" type="property" display="idAttribute" favorites="True"/>
		<memberdata name="idrefattribute" type="property" display="idrefAttribute" favorites="True"/>
		<memberdata name="includebandswithnoobjects" type="property" display="includeBandsWithNoObjects" favorites="True"/>
		<memberdata name="includebreaksindata" type="property" display="includeBreaksInData" favorites="True"/>
		<memberdata name="includedatasourcesinvfprdl" type="property" display="includeDataSourcesInVfpRdl" favorites="True"/>
		<memberdata name="includeformattinginlayoutobjects" type="property" display="includeFormattingInLayoutObjects" favorites="True"/>
		<memberdata name="insertxmlconfigrecords" type="method" display="insertXmlConfigRecords"/>
		<memberdata name="leftattr" type="property" display="leftAttr" favorites="True"/>
		<memberdata name="loadprocessorobject" type="method" display="loadProcessorObject"/>
		<memberdata name="nopageeject" type="property" display="noPageEject" favorites="True"/>
		<memberdata name="pagenodes" type="property" display="pageNodes"/>
		<memberdata name="resetdocument" type="method" display="resetDocument" favorites="True"/>
		<memberdata name="resetreport" display="resetReport" type="method"/>
		<memberdata name="setdomformattinginfo" type="method" display="setDOMFormattingInfo"/>
		<memberdata name="setfrxdatasession" type="method" display="setFRXDataSession"/>
		<memberdata name="synchxsltprocessoruser" type="method" display="synchXsltProcessorUser"/>
		<memberdata name="topattr" type="property" display="topAttr" favorites="True"/>
		<memberdata name="verifyattributenames" type="method" display="verifyAttributeNames"/>
		<memberdata name="verifyncname" type="method" display="verifyNCName" favorites="True"/>
		<memberdata name="verifynodenames" type="method" display="verifyNodeNames"/>
		<memberdata name="widthattr" type="property" display="widthAttr" favorites="True"/>
		<memberdata name="writeraw" type="method" display="writeRaw"/>
		<memberdata name="xmlmode" type="property" display="xmlMode" favorites="True"/>
		<memberdata name="xmlrawconv" type="method" display="xmlRawConv"/>
		<memberdata name="xmlrawnode" type="method" display="xmlRawNode"/>
		<memberdata name="xmlrawtag" type="method" display="xmlRawTag"/>
		<memberdata name="xsltparameters" type="property" display="xsltParameters" favorites="True"/>
		<memberdata name="xsltprocessorrdl" type="property" display="xsltProcessorRdl" favorites="True"/>
		<memberdata name="xsltprocessoruser" type="property" display="xsltProcessorUser" favorites="True"/>
		<memberdata name="adjustxsltparameter" type="method" display="adjustXSLTParameter" favorites="True"/>
		<memberdata name="getrunnodecontents" display="getRunNodeContents" type="method"/>
		<memberdata name="addrunnode" display="addRunNode" type="method"/>
		<memberdata name="includedatatypeattributes" display="includeDataTypeAttributes" type="property" favorites="True"/>
		<memberdata name="datatypeattr" type="property" display="dataTypeAttr" favorites="True"/>
		<memberdata name="datatextattr" type="property" display="dataTextAttr" favorites="True"/>
		<memberdata  name="formattingchanges" type="property" display="formattingChanges" />
		<memberdata name="initializeformattingchangescursor" type="method" display="initializeFormattingChangesCursor"/>
		<memberdata name="evaluatecontentsvalues" display="evaluateContentsValues" type="property"/>
		<memberdata name="formatdatavalue" display="formatDataValue" type="method"/>
		<memberdata name="pageimageattr" type="property" display="pageImageAttr" favorites="True"/>
		<memberdata name="evaluatestringtoboolean" display="evaluateStringToBoolean" type="property"/>
		<memberdata name="applyrdltransform" display="applyRDLTransform" type="property"/>
		<memberdata name="successorgfxnorender" display="successorGFXNoRender" type="property"/>
		<memberdata name="fixmsxmlobjectfordtds" display="fixMSXMLObjectForDTDs" type="method"/>
		<memberdata name="frxcharsetsinuse" display="frxCharsetsInUse" type="method"/>
		</VFPData>
	
	PROTECTED PROCEDURE addrunnode		&& Adds a node to the Run portion of the XML document, looking for value results in both FRX and Report Run (Current) Data sessions.
		LPARAMETERS m.oXML, m.tvValueExpr, m.tcPropertyName
		
		LOCAL m.oNode, m.vValue
		m.oNode = m.oXML.createElement("property")
		m.oNode.setAttribute("id",m.tcPropertyName)
		m.vValue = THIS.evaluateUserExpression(m.tvValueExpr)
		IF TYPE("m.vValue.XML") = "C" && xmlnode
		   m.oNode.appendChild(m.vValue)
		ELSE
		   m.oNode.Text = TRANSFORM(m.vValue)
		ENDIF
		m.vValue = NULL
		m.oXML.DocumentElement.appendChild(m.oNode)
		m.oNode = NULL
		
		
	ENDPROC

	PROCEDURE adjustxsltparameter		&& Adds, changes, or removes a parameter in the XSLT Parameter Collection, creating the collection if necessary. Params: tvValue, tsKey, tlRemoveOnly.
		LPARAMETERS m.tvValue, m.tsKey, m.tlRemoveOnly
		
		LOCAL m.liIndex, m.liSession
		
		IF ISNULL(THIS.XSLTParameters) AND NOT m.tlRemoveOnly
		   m.liSession = SET("DATASESSION")
		   THIS.resetDataSession()
		   THIS.XSLTParameters = CREATEOBJECT("Collection")
		   SET DATASESSION TO (m.liSession)
		ENDIF
		
		IF NOT ISNULL(THIS.XSLTParameters)
		   WITH THIS.XSLTParameters
		      FOR m.liIndex = 1 TO .COUNT
		          IF .GETKEY(m.liIndex) == m.tsKey
		             .REMOVE(m.liIndex)
		             EXIT
		          ENDIF
		      NEXT
		      IF NOT (m.tlRemoveOnly)
		         .ADD(m.tvValue,m.tsKey)
		      ENDIF
		   ENDWITH   
		ENDIF
		
	ENDPROC

	PROCEDURE AfterBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo
		
		DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
		
		
		IF THIS.InvokeOnCurrentPass() AND ;
		   THIS.Targethandle > -1 
		  
		   LOCAL m.lcBand, m.loNode, m.lcID, m.lcIDRef, ;
		         m.llFormatBreakBand, m.loObjects, m.llOmitBand
		
		
		   THIS.SetFRXDataSession()   
		   m.lcBand =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+FRX_OBJTYP_BAND+ ;
		                    OUTPUTXML_OBJTYPE_BANDOFFSET+nBandObjCode,;
		                    "Nodes","FrxNodes"),;
		                    Nodes.ObjValue, ;
		                    OUTPUTXML_GOOFTAG)
		                    
		   GO m.nFRXRecNo IN FRX
		   IF NOT THIS.IncludeBandsWithNoObjects 
		      m.loObjects = THIS.FRXCursor.GetObjectsInBand(FRX.UniqueID,.F.,THIS.FRXDataSession)
		      IF loObjects.Count = 0
		          m.llOmitBand = .T.
		      ENDIF
		      m.loObjects = NULL
		   ENDIF   
		   
		   THIS.SetCurrentDataSession()
		      
		   m.llFormatBreakBand = INLIST(m.nBandObjCode,;
		                    FRX_OBJCOD_PAGEHEADER, ;
		                    FRX_OBJCOD_PAGEFOOTER, ;
		                    FRX_OBJCOD_COLHEADER, ;
		                    FRX_OBJCOD_COLFOOTER)                 
		                    
		   * first evaluate THIS.IncludeBreaksInData 
		   DO CASE
		   CASE m.llOmitBand = .T.
		      * nothing
		   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_INDATA OR ;
		        NOT m.llFormatBreakBand   
		
		      #IF OUTPUTXML = OUTPUTXML_RAW
		         
		         IF EMPTY(NVL(THIS.CurrentBand,"")) 
		           * see continuation discussion in Render.
		           * our fix there may have left us with
		           * no band here
		           * do nothing
		         ELSE
		         
		            THIS.CurrentBand = NVL(THIS.CurrentBand,"") + ;
		               THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef ) 
		  
		            IF NOT (ISNULL(THIS.CurrentBand) OR EMPTY(THIS.CurrentBand))
		               THIS.WriteRaw(THIS.CurrentBand)
		               THIS.CurrentBand = ""
		            ENDIF
		
		         ENDIF    
		               
		      #ELIF OUTPUTXML = OUTPUTXML_DOTNET                       
		  
		      #ELSE
		         * nothing to do here when using the DOM
		         THIS.CurrentBand = NULL
		      #ENDIF
		
		   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
		      * build the collection which will be inserted into the
		      * data before finishing.
		      * but the band output at this point is .F.
		      #IF OUTPUTXML = OUTPUTXML_RAW
		          IF INLIST( m.nBandObjCode, ;
		                 FRX_OBJCOD_PAGEHEADER, ;
		                 FRX_OBJCOD_PAGEFOOTER) 
		             THIS.CurrentPage = NVL(THIS.CurrentPage,"")
		             THIS.CurrentPage = THIS.CurrentPage +  ;
		                               THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef ) 
		             THIS.PageNodes = THIS.PageNodes + THIS.CurrentPage
		             THIS.CurrentPage = NULL
		          ELSE
		             THIS.CurrentColumn = NVL(THIS.CurrentColumn,"")
		             THIS.CurrentColumn = THIS.CurrentColumn + ;
		                                THIS.XMLRawTag( m.lcBand, .F., m.lcID, m.lcIDRef ) 
		             THIS.ColumnNodes = THIS.ColumnNodes + THIS.CurrentColumn
		             THIS.CurrentColumn = NULL
		          ENDIF
		          
		      #ELIF OUTPUTXML = OUTPUTXML_DOTNET 
		      
		      #ELSE
		      
		          * we leave THIS.CurrentBand alone in this case,
		          * to use after the band has finished.
		          IF INLIST( nBandObjCode, ;
		                 FRX_OBJCOD_PAGEHEADER, ;
		                 FRX_OBJCOD_PAGEFOOTER) 
		             THIS.CurrentPage = NULL
		          ELSE
		             THIS.CurrentColumn = NULL
		          ENDIF
		          
		      #ENDIF
		   CASE INLIST( m.nBandObjCode, ;
		                 FRX_OBJCOD_COLHEADER, ;
		                 FRX_OBJCOD_COLFOOTER)   && XMLBREAKS_NONE and column band
		   
		       THIS.CurrentColumn = NULL
		   OTHERWISE  && XMLBREAKS_NONE and page band
		
		       THIS.CurrentPage = NULL
		   
		   ENDCASE
		   
		   THIS.resetDataSession()
		   
		ENDIF
		
		
		IF INLIST(m.nBandObjCode,FRX_OBJCOD_PAGEFOOTER, FRX_OBJCOD_TITLE) 
		   THIS.includePage = .F.
		ENDIF
		
	ENDPROC

	PROCEDURE AfterReport
		LPARAMETERS tlCalledEarly
		
		THIS.SetFRXDataSession()
		
		IF THIS.TargetHandle > -1 AND NOT (THIS.HadError )
		
		    THIS.fillRunCollector()
		   
		   #IF OUTPUTXML = OUTPUTXML_RAW
		   
		       LOCAL m.lcNode
		       IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY 
		        
		          IF  NOT EMPTY(NVL(THIS.CurrentBand,""))
		             m.lcNode = SUBSTR(THIS.CurrentBand,2,AT(" ", THIS.CurrentBand)-2)
		             THIS.CurrentBand = THIS.CurrentBand + THIS.XMLRawTag(m.lcNode)
		             * write a closing tag
		             THIS.WriteRaw(THIS.CurrentBand)
		          ENDIF
		
		          IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION 
		             IF NOT ISNULL(THIS.PageNodes)
		                 lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_PAGES,;
		                             "Nodes","FrxNodes"), ;
		                           Nodes.ObjValue, ;
		                           OUTPUTXML_GOOFTAG)
		                 THIS.WriteRaw(THIS.PageNodes) 
		                 THIS.WriteRaw(THIS.XMLRawTag(m.lcNode))                  
		             ENDIF
		             IF NOT ISNULL(THIS.ColumnNodes)
		                m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_COLS,;
		                             "Nodes","FrxNodes"), ;
		                           Nodes.ObjValue, ;
		                           OUTPUTXML_GOOFTAG)
		                 THIS.WriteRaw(THIS.ColumnNodes) 
		                 THIS.WriteRaw(THIS.XMLRawTag(m.lcNode))                                   
		             ENDIF
		          ENDIF          
		        
		          m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+OUTPUTXML_OBJCODE_DATA,;
		                        "Nodes","FrxNodes"), ;
		                      Nodes.ObjValue, ;
		                      OUTPUTXML_GOOFTAG)
		       
		          THIS.WriteRaw( THIS.XMLRawTag(m.lcNode))
		       ENDIF
		        
		       m.lcNode = THIS.getRunNodeContents(.T.)
		       
		       IF NOT (ISNULL(lcNode) OR EMPTY(lcNode))
		          THIS.WriteRaw(lcNode)
		       ENDIF             
		
		       m.lcNode =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
		                           "Nodes","ObjType"), ;
		                            Nodes.ObjValue, ;
		                            OUTPUTXML_GOOFTAG)               
		       THIS.WriteRaw( THIS.XMLRawTag(m.lcNode))    
		
		       * check to see if continuation... 
		       IF NOT OUTPUTXML_CONTINUATION
		          THIS.WriteRaw( THIS.XMLRawTag(THIS.CurrentDocument))          
		       ENDIF
		  
		   #ELIF OUTPUTXML = OUTPUTXML_DOTNET     
		      * XMLTextWriter work
		   #ELSE
		       LOCAL m.loNode
		       * domwork here        
		       IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
		          * currently all this is done on entry, but
		          * if not:
		          * append the pages collection
		          * into the report data node --
		          * that's where we should be right now
		          * THIS.DataNodes.AppendChild(THIS.PageNodes)
		          ** IF NOT ISNULL(THIS.ColumnNodes)
		          * THIS.DataNodes.AppendChild(THIS.ColumnNodes)             
		          ** ENDIF
		       ENDIF
		       
		       m.loNode = THIS.getRunNodeContents()
		       
		       IF NOT ISNULL(m.loNode)
		          THIS.DataNodes.ParentNode.AppendChild(m.loNode)
		       ENDIF             
		
		       IF NOT OUTPUTXML_CONTINUATION
		          THIS.CurrentDocument.Save(THIS.TargetFileName)
		       ENDIF
		
		       m.loNode = NULL
		
		    #ENDIF
		
		ENDIF
		   
		IF OUTPUTXML_CONTINUATION
		   IF THIS.runCollectorResetLevel = OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT 
		      THIS.resetRunCollector()       
		   ENDIF
		   THIS.ResetReport()   
		ELSE
		   IF THIS.runCollectorResetLevel > OUTPUTFX_RUNCOLLECTOR_RESET_NEVER 
		      THIS.resetRunCollector()       
		   ENDIF
		   THIS.ResetDocument()     
		   IF (NOT tlCalledEarly) AND ;
		      (THIS.applyUserTransform OR ;
		       THIS.applyRDLTransform)
		      THIS.ApplyUserTransformToOutput()
		      IF (NOT THIS.HadError)
		         * we suppressed this message earlier when closing the target file,
		         * which is just an intermediary format in this case:
		         IF THIS.DoMessage( OUTPUTCLASS_SUCCESS_LOC + ;
		                        IIF(SYS(2024)="Y",CHR(13)+OUTPUTCLASS_REPORT_INCOMPLETE_LOC,""),;
		                        MB_ICONINFORMATION + MB_YESNO ) = IDYES
		            _CLIPTEXT = THIS.TargetFileName
		         ENDIF
		      ENDIF   
		   ENDIF   
		ENDIF
		
		THIS.resetDataSession()   
		
		IF (NOT tlCalledEarly)
		   DODEFAULT()
		ENDIF   
		
		
	ENDPROC

	PROCEDURE applyrdltransform_access
		RETURN (THIS.XMLMode = OUTPUTXML_RDL_ONLY AND ;
		       (NOT ISNULL(THIS.xsltProcessorRdl )))
		
	ENDPROC

	PROTECTED PROCEDURE applyusertransformtooutput		&& Applies a user-specified XSLT to XML output at the conclusion of a report run.
		DO CASE
		CASE (THIS.applyUserTransform AND NOT ;
		   (ISNULL(THIS.XSLTProcessorUser))) OR ;
		   THIS.applyRDLTransform 
		
		   LOCAL m.lvProcessor
		
		   * THIS.SaveTargetFileName is real
		   * THIS.TargetFileName is TMP
		   IF THIS.xmlMode = OUTPUTXML_RDL_ONLY
		      m.lvProcessor = THIS.XSLTProcessorRDL
		   ELSE
		      m.lvProcessor = THIS.XSLTProcessorUser
		   ENDIF   
		   IF NOT EMPTY(SYS(2000,THIS.SaveTargetFileName))
		      ERASE (THIS.SaveTargetFileName) NORECYCLE
		   ENDIF
		   *&* Sedna change to ensure better encoding behavior
		   *&* See notes in .ApplyXSLT method
		   STRTOFILE(THIS.ApplyXSLT(THIS.TargetFileName,m.lvProcessor, THIS.XSLTParameters), ;
		             THIS.SaveTargetFileName)
		   ERASE (THIS.TargetFileName) NORECYCLE
		   THIS.TargetFileName = THIS.SaveTargetFileName
		   RETURN .T.
		CASE THIS.applyUserTransform && no processor but public property is still set
		   IF NOT EMPTY(SYS(2000,THIS.SaveTargetFileName))
		      ERASE (THIS.SaveTargetFileName) NORECYCLE
		   ENDIF
		   COPY FILE (THIS.TargetFileName) TO (THIS.SaveTargetFileName)
		   ERASE (THIS.TargetFileName) NORECYCLE
		   THIS.TargetFileName = THIS.SaveTargetFileName
		   RETURN .F.  
		OTHERWISE
		   RETURN .F. 
		ENDCASE
		
		
		
	ENDPROC

	PROCEDURE applyusertransform_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
		   THIS.applyUserTransform = m.vNewVal
		   IF THIS.applyUserTransform AND ;
		      (ISNULL(THIS.XSLTProcessorUser))
		      THIS.GetDefaultUserXSLT()
		   ENDIF   
		ENDIF   
		
	ENDPROC

	PROCEDURE applyxslt		&& Provides generic facilities for applying XSLT to XML.
		LPARAMETERS m.tvSource, m.tvProcessor, m.tvParamCollection, m.tvFRXAlias
		
		LOCAL m.loSource, m.loProcessor, m.lcReturn, m.llSuccess, m.liParam, m.liSession, m.llCharsetsInUse
		
		m.lcReturn = ""
		
		STORE NULL TO m.loSource, m.loProcessor
		
		IF VARTYPE(m.tvSource) = "C" 
		
		   * first param can be filename, string, or object
		   * if filename or string, test existance
		   * and try to load as a dom object
		*   m.liSession = SET("DATASESSION")
		*   THIS.resetDataSession()
		   m.llCharsetsInUse = THIS.frxCharsetsInUse(m.tvFRXAlias)
		   m.loSource = CREATEOBJECT(OUTPUTXML_DOMDOCUMENTOBJECT)
		   THIS.fixMSXMLObjectForDTDs(m.loSource)
		   DO CASE
		   CASE FILE(m.tvSource) AND NOT m.llCharsetsInUse
		      m.loSource.Load(m.tvSource)
		   CASE FILE(m.tvSource) 
		      *&* m.loSource.Load(m.tvSource) 
		      *&* would introduce problems with the (multi) charset-handling
		      *&* in FRX by engine
		      *&* see notes below
		      m.loSource.LoadXML(FILETOSTR(m.tvSource))
		   OTHERWISE
		      m.loSource.LoadXML(m.tvSource)
		   ENDCASE
		*   SET DATASESSION TO (m.liSession)
		  
		   IF NOT ISNULL(m.loSource) AND ;
		      LEN(m.loSource.XML) > 0 AND ;
		      EMPTY(m.loSource.parseError.reason)
		      m.llSuccess = .T.
		   ELSE
		      m.loSource = NULL
		*      IF NOT ISNULL(m.loSource)
		*         THIS.LastErrorMessage = loSource.parseError.reason
		*      ENDIF   
		   ENDIF
		ELSE
		   * if object, test nodetypestring availability
		   * and then for document/tree shape.
		   IF VARTYPE(m.tvSource) = "O"
		      TRY 
		         IF INLIST("|"+UPPER(m.tvSource.nodeTypeString)+"|", ;
		                       "|DOCUMENT|","|ELEMENT|") && quick and dirty test for tree shape
		            m.loSource = m.tvSource           
		            m.llSuccess = .T.
		         ENDIF
		      ENDTRY
		   ENDIF   
		
		ENDIF
		
		IF m.llSuccess 
		
		   * for failed transformations, return source XML
		   m.lcReturn = m.loSource.XML
		   
		   * as above
		   * second param can be filename or object
		 
		   * if filename, as above
		   *  if object, test for appropriate interface
		   * figure out if it's a processor factory
		   * or an instance (either dom or stylesheet)
		   *  and error out if we can't figure it out
		   m.llSuccess = .F.
		   IF VARTYPE(m.tvProcessor) = "C"    
		      m.loProcessor = THIS.LoadProcessorObject(m.tvProcessor)
		      IF NOT ISNULL(m.loProcessor)
		         m.loProcessor = m.loProcessor.createProcessor()      
		      ENDIF
		   ELSE
		      IF VARTYPE(m.tvProcessor) = "O" 
		         TRY
		            IF VARTYPE(m.tvProcessor.styleSheet) = "O"
		               m.loProcessor = m.tvProcessor
		               * if the object was a processor object
		               * get a stylesheet instance
		               m.loProcessor = m.loProcessor.createProcessor()
		            ENDIF   
		         CATCH
		            * just want to swallow the errors here because
		            * of the primitive tests being used
		         ENDTRY
		      ENDIF
		   ENDIF
		  
		   IF NOT ISNULL(m.loProcessor) 
		      m.llSuccess = .T.
		   ENDIF
		ENDIF
		
		IF m.llSuccess
		            
		   
		   WITH m.loProcessor
		      IF VARTYPE(m.tvParamCollection) = "O" AND ;
		         UPPER(m.tvParamCollection.BaseClass) == "COLLECTION" AND ;
		         m.tvParamCollection.Count > 0
		
		         FOR m.liParam = 1 TO m.tvParamCollection.Count
		            .AddParameter(m.tvParamCollection.GetKey(m.liParam), ;
		                         m.tvParamCollection.Item(m.liParam))
		         ENDFOR
		      ENDIF   
		      * always override for current external file location info, if we have one:
		       IF NOT EMPTY(THIS.externalFileLocation)
		          .AddParameter("externalFileLocation", THIS.externalFileLocation)
		       ENDIF          
		      .input = m.loSource
		      .transform()
		      m.lcReturn = .output
		   ENDWITH
		
		ENDIF
		
		STORE NULL TO m.loSource, m.loProcessor
		
		*&* Sedna change to 
		*&* ensure UTF-8 File contents per documented
		*&* behavior of this class.  xsl:output encoding is ignored
		*&* by the msxml processor transform anyway when outputting
		*&* to a string (see http://msdn2.microsoft.com/en-us/library/ms753765.aspx) 
		*&* and as a result we are outputting a file with no encoding
		*&* specified after the transform.  So we should ensure that it
		*&* is in the default XML encoding when none is specified,
		*&* which is UTF-8. But Fox has changed the UTF-16 return value 
		*&* from the MSXML processor objects to DBCS.  We need to fix 
		*&* that at the time we send to disk for other applications to 
		*&* read, can't do it before this point.  We can't do it
		*&* in cases where the user has marked explicit fontcharsets in
		*&* the FRX, since this information is passed along in VFP-RDL XML
		*&* and could be treated differently by different output mechanisms/XSLT.
		*&* We will preserve original behavior in that case.
		
		IF m.llCharsetsInUse
		   RETURN m.lcReturn
		ELSE
		   RETURN (STRCONV(m.lcReturn,STRCONV_DBCS_UTF8))
		ENDIF   
	ENDPROC

	PROCEDURE BeforeBand
		LPARAMETERS m.nBandObjCode, m.nFRXRecNo, m.tlContinuedBand
		
		DODEFAULT(m.nBandObjCode, m.nFRXRecNo)
		
		IF INLIST(m.nBandObjCode,FRX_OBJCOD_PAGEHEADER, FRX_OBJCOD_TITLE,FRX_OBJCOD_SUMMARY) 
		   THIS.includePage =  THIS.IncludePageInOutput(_PAGENO)
		   *(THIS.PageNo >= THIS.CommandClauses.RangeFrom) AND ;
		   *    ((THIS.CommandClauses.RangeTo = -1) OR (THIS.PageNo <= THIS.CommandClauses.RangeTo))
		   * possibly to be adapted later:
		   * regardless of whether IncludePageInOutput() is used
		   * or the manual evaluation above (commented) is used,
		   * _PAGENO will work for continued reports only if NORESET is not used.
		   * THIS.PageNo/THIS.SharedPageNo will not work whether NORESET is used or not,
		   * for continued reports, 
		   * unless you maintain a private offset.  RANGE is
		   * sensitive to the current REPORT FORM command, not the full
		   * NOPAGEEJECT (chained) run
		   
		ENDIF
		
		
		IF THIS.InvokeOnCurrentPass() AND ;
		  THIS.Targethandle > -1 
		  
		   LOCAL m.lcBand, m.loNode, m.lcID, m.lcIDRef, ;
		         m.llFormatBreakBand, m.lcInterruptedBand,;
		         m.llOmitBand, m.loObjects
		
		   THIS.SetFRXDataSession()   
		
		   GO m.nFRXRecNo IN FRX   
		
		   IF NOT THIS.IncludeBandsWithNoObjects 
		      m.loObjects = THIS.FRXCursor.GetObjectsInBand(FRX.UniqueID,.F.,THIS.FRXDataSession)
		      IF m.loObjects.Count = 0
		          m.llOmitBand = .T.
		      ENDIF
		      m.loObjects = NULL
		   ENDIF   
		      
		   m.lcBand =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND+ ;
		                    OUTPUTXML_OBJTYPE_BANDOFFSET+nBandObjCode,;
		                    "Nodes","FrxNodes"),;
		                    Nodes.ObjValue, ;
		                    OUTPUTXML_GOOFTAG)
		   THIS.SetCurrentDataSession()
		                    
		   m.llFormatBreakBand = INLIST(nBandObjCode,;
		                    FRX_OBJCOD_PAGEHEADER, ;
		                    FRX_OBJCOD_PAGEFOOTER, ;
		                    FRX_OBJCOD_COLHEADER, ;
		                    FRX_OBJCOD_COLFOOTER)                 
		                    
		   
		   IF m.llFormatBreakBand
		
		      m.lcIDRef =  TRANSFORM(m.nFRXRecNo) && TRANSFORM(IIF(EMPTY(FRX.UniqueID),"",FRX.UniqueID))
		      m.lcID = TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo))
		         
		   ELSE
		
		      m.lcID =  TRANSFORM(m.nFRXRecNo) && TRANSFORM(IIF(EMPTY(FRX.UniqueID),"",FRX.UniqueID) )
		      IF m.tlContinuedBand
		         m.lcID = m.lcID + "+"
		      ENDIF
		      m.lcIDRef = TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo))
		      
		   ENDIF
		
		   * first evaluate THIS.IncludeBreaksInData 
		   DO CASE
		   CASE m.llOmitBand
		      * do nothing -- TBD checked later.
		   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_INDATA OR ;
		        NOT m.llFormatBreakBand   
		
		      #IF OUTPUTXML = OUTPUTXML_RAW
		         IF NOT (ISNULL(THIS.CurrentBand) OR EMPTY(THIS.CurrentBand))
		             * a data band has spanned
		             * formatting breaks (pages or columns)
		             * and we haven't otherwise caught it.
		             * This should not happen.
		             m.lcInterruptedBand = SUBSTR(ALLTR(THIS.CurrentBand),2,AT(" ", THIS.CurrentBand)-2)
		             * write a closing tag
		             THIS.WriteRaw(THIS.CurrentBand + THIS.XMLRawTag(m.lcInterruptedBand))
		         ENDIF
		         
		      
		        THIS.CurrentBand =  THIS.XMLRawTag( m.lcBand,.T., m.lcID, m.lcIDRef ) 
		               
		      
		      #ELIF OUTPUTXML = OUTPUTXML_DOTNET                       
		  
		      #ELSE
		
		          m.loNode = THIS.CurrentDocument.CreateElement(m.lcBand)
		          m.loNode.SetAttribute(THIS.idAttribute,m.lcID)
		          m.loNode.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
		          THIS.DataNodes.AppendChild(m.loNode)
		          THIS.CurrentBand = m.loNode                                    
		          m.loNull = NULL
		      #ENDIF
		
		   CASE THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION
		      * build the collection which will be inserted into the
		      * data before finishing.
		      * but the band output at this point is .F.
		      #IF OUTPUTXML = OUTPUTXML_RAW
		          IF INLIST( m.nBandObjCode, ;
		                 FRX_OBJCOD_PAGEHEADER, ;
		                 FRX_OBJCOD_PAGEFOOTER) 
		             THIS.CurrentPage = NVL(THIS.CurrentPage,"")
		             THIS.CurrentPage = THIS.CurrentPage + ;
		                                THIS.XMLRawTag( m.lcBand, .T.,m.lcID, m.lcIDRef ) 
		          ELSE
		             THIS.CurrentColumn = NVL(THIS.CurrentColumn,"")
		             THIS.CurrentColumn = THIS.CurrentColumn + ;
		                                  THIS.XMLRawTag( m.lcBand, .T., m.lcID, m.lcIDRef ) 
		          ENDIF
		          
		         
		      #ELIF OUTPUTXML = OUTPUTXML_DOTNET 
		      
		      #ELSE
		      
		          * we leave THIS.CurrentBand alone in this case,
		          * to use after the band has finished.
		          IF INLIST( m.nBandObjCode, ;
		                 FRX_OBJCOD_PAGEHEADER, ;
		                 FRX_OBJCOD_PAGEFOOTER) 
		             THIS.CurrentPage = THIS.CurrentDocument.CreateElement(m.lcBand)
		             THIS.CurrentPage.SetAttribute(THIS.idAttribute,m.lcID)
		             THIS.CurrentPage.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
		             THIS.PageNodes.AppendChild(THIS.CurrentPage)
		          ELSE
		             THIS.CurrentColumn = THIS.CurrentDocument.CreateElement(m.lcBand)
		             THIS.CurrentColumn.SetAttribute(THIS.idAttribute,m.lcID)
		             THIS.CurrentColumn.SetAttribute(THIS.idrefAttribute,m.lcIDRef)
		             THIS.ColumnNodes.AppendChild(THIS.CurrentColumn)
		          ENDIF
		          
		      #ENDIF
		   CASE INLIST( m.nBandObjCode, ;
		                 FRX_OBJCOD_COLHEADER, ;
		                 FRX_OBJCOD_COLFOOTER)   && XMLBREAKS_NONE and column band
		   
		      THIS.CurrentColumn = "X"
		
		   OTHERWISE  && XMLBREAKS_NONE and page band
		
		      THIS.CurrentPage = "X"
		   
		   ENDCASE
		   
		   THIS.resetDataSession()
		   
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE BeforeReport
		DODEFAULT()
		
		IF (NOT THIS.HadError) 
		   THIS.SetFRXDataSession()
		   IF THIS.isSuccessor 
		      * need a private norender object
		      * to handle potential rendering tests
		      * specific to this output type     
		      THIS.successorGFXNoRender = ;
		           THIS.checkCollectionForSpecifiedMember(;
		           THIS.gfxNoRenderClass,;
		           THIS.gfxNoRenderClassLib,.T.,.T.)           
		   ENDIF
		   IF USED("FRX")
		      LOCAL m.liSelect, m.lcDocument, m.lcReport, ;
		            m.lcRDL, m.lcPage, m.lcCol, m.lcData, m.loNode, m.loParent
		      m.liSelect = SELECT(0)
		      SELECT FRX
		
		      IF THIS.TargetHandle = -1 AND ;
		         (THIS.applyUserTransform OR ;
		          THIS.applyRDLTransform)
		         THIS.verifyTargetFile()      
		         IF EMPTY(JUSTEXT(THIS.TargetFileName))
		            THIS.TargetFileName = FORCEEXT(THIS.TargetFileName,THIS.TargetFileExt)
		         ENDIF   
		         THIS.AddProperty("SaveTargetFileName",THIS.TargetFileName)
		         THIS.TargetFileName = FORCEEXT(THIS.TargetFileName,"TMP")
		      ENDIF
		         
		      IF (THIS.TargetHandle > -1 OR THIS.OpenTargetFile())  
		         IF NOT USED("Nodes")
		            IF  UPPER(FULLPATH(THIS.ConfigurationTable)) == ;
		                UPPER(FULLPATH(FORCEEXT(OUTPUTCLASS_INTERNALDBF,"DBF")))
		                USE (THIS.ConfigurationTable) AGAIN IN 0  ;
		                   NOUPDATE ALIAS Nodes SHARED
		            ELSE       
		                USE (THIS.ConfigurationTable) AGAIN IN 0  ;
		                   ALIAS Nodes SHARED
		                THIS.VerifyNodeNames()
		                THIs.VerifyAttributeNames()
		            ENDIF
		         ENDIF
		            
		         * create helper object
		         * create band and object cursors   
		         * we may want to evaluate raw mode
		         * as well as THIS.XMLMode to see if these are needed:
		         IF (NOT (THIS.IncludeBandsWithNoObjects AND  ;
		            THIS.XMLMode = OUTPUTXML_DATA_ONLY) ) && OR OUTPUTXML_PERFORMLOCALECONVERSION 
		            THIS.LoadFRXCursor = .T.               
		            IF ISNULL(THIS.FRXCursor) OR ;
		               (NOT THIS.FRXCursor.CreateObjectCursor("FRX", "OBJECTS", .F., .T. ,THIS.FRXDataSession)) && force the load and make sure
		                                                         && we have access to runtime
		                                                         && version of the cursor
		               THIS.IncludeBandsWithNoObjects = .T.
		            ELSE
		               SELECT Bands                  
		               IF TAGNO("UniqueID") = 0
		                  INDEX ON UniqueID TAG UniqueID
		               ENDIF
		               SET ORDER TO 0                  
		               SELECT Objects
		               IF TAGNO("UniqueID") = 0
		                  INDEX ON UniqueID TAG UniqueID
		               ENDIF
		               SET ORDER TO 0
		            ENDIF   
		         ENDIF   
		         
		         THIS.IsRunning = .T.               
		         SET ORDER TO 0 IN FRX            
		         m.lcDocument =  IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+ ;
		                              OUTPUTXML_OBJCODE_DOC,;
		                              "Nodes","FrxNodes"), ;
		                              Nodes.ObjValue, ;
		                            OUTPUTXML_GOOFTAG)
		         m.lcReport =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
		                            "Nodes","ObjType"), ;
		                             Nodes.ObjValue, ;
		                             OUTPUTXML_GOOFTAG)               
		  
		         IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY 
		            m.lcData =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
		                                 OUTPUTXML_OBJCODE_DATA, ;
		                                "Nodes","FrxNodes"), ;
		                                 Nodes.ObjValue, ;
		                                 OUTPUTXML_GOOFTAG)
		         ENDIF
		         IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY 
		            m.lcRDL = IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
		                             OUTPUTXML_OBJCODE_RDL, ;
		                             "Nodes","FrxNodes"), ;
		                             Nodes.ObjValue, ;
		                             OUTPUTXML_GOOFTAG)
		         ENDIF
		         IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION   
		            m.lcPage =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ ;
		                                OUTPUTXML_OBJCODE_PAGES, ;
		                                "Nodes","FrxNodes"), ;
		                                Nodes.ObjValue, ;
		                                OUTPUTXML_GOOFTAG)
		   *        GO (THIS.frxHeaderRecno) IN FRX
		   *        IF FRX.VPos > 1
		            m.lcCol = IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+;
		                              OUTPUTXML_OBJCODE_COLS,;
		                              "Nodes","FrxNodes"), ;
		                               Nodes.ObjValue, ;
		                              OUTPUTXML_GOOFTAG)
		   
		    *       ENDIF
		         ENDIF                    
		         #IF OUTPUTXML = OUTPUTXML_RAW
		             IF EMPTY(THIS.CurrentDocument) OR ISNULL(THIS.CurrentDocument)
		                THIS.CurrentDocument = m.lcDocument
		                THIS.WriteRaw( ;
		                     THIS.XMLRawTag( THIS.CurrentDocument,.T.) )   
		             ENDIF
		             THIS.WriteRaw( ;
		                  THIS.XMLRawTag( m.lcReport,.T.) )   
		             * could add FRXname as ID here                
		             IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY    
		                * write RDL here
		                THIS.WriteRaw( ;
		                     THIS.XMLRawTag( m.lcRDL,.T.,THIS.xmlRawConv( THIS.CommandClauses.FILE)) )  
		                THIS.WriteRaw( STRCONV(THIS.GetVFPRDLContents(m.lcRDL, .T.),STRCONV_DBCS_UTF8)  )
		                THIS.WriteRaw( ;
		                     THIS.XMLRawTag( m.lcRDL) )   
		             ENDIF
		             IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY           
		                THIS.WriteRaw( ;
		                 THIS.XMLRawTag( m.lcData,.T.) )   
		                      
		                IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION   
		                   THIS.PageNodes =  THIS.XMLRawTag( m.lcPage,.T.)  
		 *                 IF NOT EMPTY(lcCol)
		                      THIS.ColumnNodes = THIS.XMLRawTag(m.lcCol,.T.)
		 *                 ENDIF
		                ENDIF
		              ENDIF
		                     
		         #ELIF OUTPUTXML = OUTPUTXML_DOTNET
		             * XMLTextWriter work  
		         #ELSE
		             IF VARTYPE(THIS.CurrentDocument) # "O"
		                LOCAL m.liSession
		                m.liSession = SET("DATASESSION")
		                THIS.resetDataSession()
		                THIS.CurrentDocument = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		                SET DATASESSION TO (m.liSession)
		                * COMPROP(THIS.CurrentDocument,"UTF8",1)                                
		                THIS.CurrentDocument.DocumentElement = THIS.CurrentDocument.CreateElement(m.lcDocument)
		             ENDIF
		             loNode = THIS.CurrentDocument.CreateElement(m.lcReport)                  
		             * setattribute id using FRXName here                
		             * idref?
		             THIS.CurrentDocument.DocumentElement.AppendChild(m.loNode)
		             m.loParent = loNode             
		             IF NOT THIS.XMLMode = OUTPUTXML_DATA_ONLY    
		                m.loNode = THIS.CurrentDocument.CreateElement(m.lcRDL)
		                m.loNode.SetAttribute(THIS.idAttribute,THIS.CommandClauses.FILE)
		                m.loNode.AppendChild(THIS.GetVFPRDLContents(m.lcRDL))
		                m.loParent.AppendChild(m.loNode)
		             ENDIF
		             IF NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY                        
		                m.loNode = THIS.CurrentDocument.CreateElement(m.lcData)
		                * possibly add DE stuff here                
		                m.loParent.AppendChild(m.loNode)
		                THIS.DataNodes = m.loNode
		                IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION   
		                   THIS.PageNodes = THIS.CurrentDocument.CreateElement(m.lcPage)
		                   THIS.DataNodes.AppendChild(THIS.PageNodes)
		                   THIS.ColumnNodes = THIS.CurrentDocument.CreateElement(m.lcCol)
		                   THIS.DataNodes.AppendChild(THIS.ColumnNodes)                   
		                ENDIF
		             ENDIF
		         #ENDIF
		         IF THIS.XMLMode = OUTPUTXML_RDL_ONLY
		            THIS.AfterReport(.T.)
		         ENDIF
		      ENDIF
		      *&* Sedna
		      IF THIS.XMLMode # OUTPUTXML_RDL_ONLY
		         THIS.initializeFormattingChangesCursor()    
		         SELECT FRX
		         IF USED(THIS.formattingChanges)
		            SELECT FRX
		            SCAN FOR Platform = FRX_PLATFORM_WINDOWS AND ;
		                 ObjType = FRX_OBJTYP_FIELD AND NOT DELETED() && fields only
		                INSERT INTO (THIS.FormattingChanges) ;
		                  (FRXRecno) VALUES (RECNO("FRX"))
		            ENDSCAN
		            SELECT (THIS.FormattingChanges)
		            INDEX ON FRXRecno TAG FRXRecno
		            SELECT FRX
		         ENDIF
		      ENDIF
		      STORE NULL TO m.loNode, m.loParent
		      SELECT (m.liSelect)
		   ELSE
		      THIS.DoMessage(OUTPUTXML_FRXMISSING_LOC,MB_ICONSTOP )
		      THIS.lastErrorMessage = OUTPUTXML_FRXMISSING_LOC
		   ENDIF   
		   THIS.resetDataSession()
		ENDIF
		
		RETURN 
	ENDPROC

	PROCEDURE closetargetfile
		LOCAL m.llResetQuietMode
		m.llResetQuietMode =  ;
		 ((NOT THIS.HadError) AND (NOT THIS.QuietMode) AND  ;
		  (THIS.applyUserTransform OR THIS.applyRDLTransform ))
		IF m.llResetQuietMode
		   THIS.QuietMode = .T.
		ENDIF
		DODEFAULT()
		IF m.llResetQuietMode
		   THIS.QuietMode = .F.
		ENDIF      
	ENDPROC

	PROCEDURE contattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.contAttr = m.vNewVal
		ENDIF   
		
		
		
	ENDPROC

	PROCEDURE createconfigtable
		LPARAMETERS m.tcDBF, m.tlOverWrite
		* table is being created from scratch,
		* may be in a VCX in an unknown environment
		* (definitely not in REPORTOUTPUT.APP!)
		
		DODEFAULT(m.tcDBF, m.tlOverWrite)
		
		IF NOT THIS.HadError
		   LOCAL m.liSelect, m.llSafetyOn
		   m.llSafetyOn = (SET("SAFETY") = "ON")
		   SET SAFETY OFF
		   m.liSelect = SELECT(0)
		   SELECT 0
		   USE (m.tcDBF) EXCLU  
		   INDEX ON ObjType+ObjCode+ ;
		      IIF(ObjType=FRX_OBJTYP_BAND+OUTPUTXML_OBJTYPE_NODES, ;
		          OUTPUTXML_OBJTYPE_BANDOFFSET,0) ;
		      TAG FRXNodes  
		   IF m.llSafetyOn
		      SET SAFETY ON
		   ENDIF   
		   THIS.InsertXMLConfigRecords()   
		   USE
		   SELECT (m.liSelect)
		ENDIF   
		
	ENDPROC

	PROCEDURE currentdocument_assign
		LPARAMETERS m.vNewVal
		* TBD: evaluate for readonly status during the life of the report run
		THIS.currentdocument = m.vNewVal
		
	ENDPROC

	PROCEDURE datatextattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.dataTextAttr = m.vNewVal
		ENDIF   
		
		
		
	ENDPROC

	PROCEDURE datatypeattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.dataTypeAttr = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE Destroy
		   
		DODEFAULT()
		THIS.ResetDocument()
		STORE NULL TO ;
		   THIS.ColumnNodes, ;
		   THIS.CurrentBand, ;
		   THIS.CurrentColumn, ;
		   THIS.CurrentDocument, ;
		   THIS.CurrentPage, ;
		   THIS.DataNodes, ;
		   THIS.pageNodes, ;
		   THIS.XSLTProcessorRDL, ;
		   THIS.XSLTProcessorUser, ;
		   THIS.xsltParameters 
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS m.nError, m.cMethod, m.nLine
		
		   DODEFAULT(m.nError,m.cMethod,m.nLine)
		   * we could evaluate errors first, but generally,
		   THIS.CloseTargetFile()
		   IF THIS.isRunning
		      THIS.QuietMode = .T.
		   ENDIF   
		   THIS.CancelReport()
		
		
	ENDPROC

	PROCEDURE EvaluateContents
		LPARAMETERS m.nFRXRecno, m.oObjProperties
		DODEFAULT(m.nFRXRecno,m.oObjProperties)
		* do some work even though we may not be
		* adding DTYPE and DTEXT, so that
		* subclasses can rely on the right record
		* being made available in the formattingChanges alias
		* and the "empty values" object always being there
		IF THIS.InvokeOnCurrentPass() AND ;
		   THIS.targetHandle <> -1
		   THIS.setFRXDataSession() 
		   IF USED(THIS.formattingChanges)
		      IF ISNULL(THIS.evaluateContentsValues) 
		         * first time
		         SELECT (THIS.formattingChanges)
		         SCATTER MEMO BLANK NAME THIS.evaluateContentsValues ;
		              FIELDS EXCEPT FRXRecno
		      ENDIF
		      =SEEK(m.nFRXRecno,THIS.FormattingChanges, "FRXRecno") 
		      IF NOT EOF(THIS.formattingChanges)
		         SELECT (THIS.formattingChanges) 
		         GATHER NAME THIS.evaluateContentsValues  && always start off empty
		         IF THIS.includeDataTypeAttributes 
		            WITH m.oObjProperties
		               IF EMPTY(.Value)
		                 REPLACE DType WITH "C"
		               ELSE
		                 REPLACE DType WITH VARTYPE(.Value), ;
		                         DText WITH THIS.formatDataValue(.Value)
		               ENDIF  
		            ENDWITH         
		         ENDIF
		         SELECT FRX
		      ENDIF   
		   ENDIF   
		   THIS.resetDataSession() 
		ELSE
		   RETURN .F.   
		ENDIF      
		           
	ENDPROC

	PROTECTED PROCEDURE evaluatestringtoboolean		&& Casts a string to .T. or .F..
		LPARAMETERS tcVal
		RETURN INLIST(UPPER(m.tcVal),"YES",".T.","TRUE","1")         
	ENDPROC

	PROCEDURE fillruncollector
		* getRunNodeContents will allow a Collection, 
		* a table/alias, or an empty-type object.
		* Table/Alias is easiest, and allows you to use
		* reset levels of OUTPUTFX_RUNCOLLECTOR_RESET_NEVER or
		* OUTPUTFX_RUNCOLLECTOR_RESET_ONCHAIN, because the entry
		* keys do not have to be unique.
		* However, a Collection or EMPTY object
		* allows you to add serialized XML documents as the values
		* of a single property if you like. (This is done
		* in addRunNode method.) You also don't have to 
		* place a cursor in the user's data session.
		* (The getRunNodeContents method will find the cursor in the FRX data session 
		* as well, but that wouldn't work very well for 
		* chained reports; in fact, even CurrentDataSession is
		* dicey with chained reports unless you're sure none
		* of them has a private data session.)
		* For these reasons, although its known document 
		* properties are all simple values, xmlListener 
		* chooses to implement
		* fillRunCollector using a Collection object, and   
		* a CASE exists below to load the XML contents properly
		* for any consumers that wish to read it as true XML.
		* runCollectorResetLevel is readonly at OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
		* to ensure uniqueness of the keys for each report run.
		
		* If you override this method to use an alias, you can
		* gather data cumulatively for chained runs however you
		* choose, and getRunNodeContents should cope.
		
		* If you augment this method to add to the collection,
		* you can add serialized objects
		* in the form of XML nodes that have nothing to do with the 
		* original memberdata contents, and may be completely different
		* in schema.  HTMLListener does this for HTTP-EQUIV handling.
		
		IF ISNULL(THIS.runCollector) OR VARTYPE(THIS.runCollector) # "O"
		   * because we are using OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT,
		   * this should always be true, and the session issue is
		   * probably not relevant.  But we will adjust the session
		   * in case somebody changes this #DEFINEd life-period of
		   * the runCollector object
		   LOCAL m.liSession
		   m.liSession = SET("DATASESSION")
		   THIS.resetDataSession()
		   THIS.runCollector = CREATEOBJECT("Collection")
		   SET DATASESSION TO (m.liSession)
		ENDIF
		
		THIS.setFRXDataSession()
		IF USED(THIS.memberDataAlias) 
		   LOCAL m.lvValue, m.lcExpr, m.liSelect, m.loXML, m.loXMLTemp
		   IF USED("FRX") 
		      GO (THIS.frxHeaderRecno) IN FRX
		      #IF OUTPUTXML = OUTPUTXML_DOM
		         m.loXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		         m.loXMLTemp = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		      #ELSE
		         m.loXML = CREATEOBJECT("Microsoft.XMLDOM")
		         m.loXMLTemp = CREATEOBJECT("Microsoft.XMLDOM")
		      #ENDIF      
		      IF NOT m.loXML.LoadXML(FRX.Style)
		         m.loXML = NULL
		      ENDIF
		   ENDIF      
		   m.liSelect = SELECT(0)
		
		   SELECT (THIS.memberDataAlias)
		   SCAN ALL FOR FRXRecno = THIS.frxHeaderRecno AND ;
		        Type = FRX_BLDR_MEMBERDATATYPE  ;
		        AND (NOT (EMPTY(Execute) OR EMPTY(Name) OR EMPTY(ExecWhen) OR DELETED()))
		        * do not check
		        * for Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS   
		        * because you can add your own in. 
		        * But it must have *some* namespace.
		        * IOW, the original metadata record with 
		        * blank namespace is not included in this treatment,
		        * because its Execute and ExecWhen fields 
		        * are specified to have different scripting behavior.       
		        m.lvValue = ""
		        m.lcExpr = Execute
		        DO CASE
		        CASE VAL(DeClass) = ADVPROP_EDITMODE_GETEXPR 
		           m.lvValue = THIS.evaluateUserExpression(m.lcExpr)
		        CASE VAL(DeClass) = ADVPROP_EDITMODE_TEXT AND ;
		           NOT ISNULL(m.loXML) 
		           m.lvValue = ;
		              m.loXML.SelectSingleNode("/VFPData/reportdata" + ;
		                      "[@name='" + Name + "' and @execwhen='" + ExecWhen + "']/@execute")
		           IF (NOT ISNULL(m.lvValue)) AND ;
		              m.loXMLTemp.LoadXML(m.lvValue.Text)
		              m.lvValue = m.loXMLTemp.DocumentElement
		           ELSE
		              m.lvValue = m.lcExpr
		               * may not really be XML, we still want the information
		           ENDIF                      
		        OTHERWISE
		           m.lvValue = m.lcExpr
		        ENDCASE
		
		        * The following help ensures uniqueness of key values
		        * in case people use the same property names in ExecWhen.
		        
		        IF Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS 
		           m.lcExpr = ExecWhen
		        ELSE
		           m.lcExpr = Name+"."+ExecWhen
		        ENDIF
		        IF THIS.runCollector.getKey(m.lcExpr) = 0  
		           THIS.runCollector.add(m.lvValue,m.lcExpr)
		        ENDIF
		   ENDSCAN        
		   SELECT (liSelect)
		   STORE NULL  TO m.loXML, m.loXMLTemp
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE fixmsxmlobjectfordtds		&& Adjust MSXML document objects to load XML with embedded DTDs properly.
		LPARAMETERS m.toXML
		
		IF VARTYPE(m.toXML) = "O"
		  TRY
		     WITH m.toXML
		        .validateOnParse = .F.
		        .resolveExternals = .F.
		        .setProperty("ProhibitDTD",.F.)
		     ENDWITH
		   CATCH WHEN .T. && Swallow any errors.
		     *&* This fix primarily benefits
		     *&* external usees of the ApplyXSLT public method;
		     *&* it does not affect standard/automatic
		     *&* usage of ApplyXSLT to VFP-RDL XML files.
		     *&* It allows people to use the ApplyXSLT method
		     *&* more flexibly when transforming XML data
		     *&* between two schemas (standard B2B requirement).
		     *&* However, the "ProhibitDTD" property
		     *&* is not supported by the original 2003 msxml4.dll
		     *&* distribution file.
		     *&* The property will exist, and 
		     *&* the behavior will be supported, if the user has
		     *&* applied fixes and updates to MSXML as is usually
		     *&* the case.
		     *&* If the msxml4.dll file has been deployed using
		     *&* an MSM supplied with VFP as part of a distribution
		     *&* setup to a Vista machine, rather than as part of 
		     *&* normal OS files in pre-Vista environments, this
		     *&* may *not* be the case.
		     *&* For information about updates and patches 
		     *&* to msxml4.dll, 
		     *&* see http://www.microsoft.com/downloads/details.aspx?FamilyID=24b7d141-6cdf-4fc4-a91b-6f18fe6921d4&DisplayLang=en#Instructions
		     *&* Vulnerabilities in Microsoft XML Core Services 4.0 Could Allow Remote Code Execution (927978)
		     *&* Note that msxml4.dll is a side-by-side installation file and 
		     *&* the update will fail to occur properly if the DLL is currently locked
		     *&* because an application is, or has been, using it.  This would including
		     *&* loading VFP.
		     *&* For instructions regarding "locked" file that may cause installation to fail
		     *&* and how to get around it, see http://support.microsoft.com/?kbid=927978
		     *&* To ensure that the updates have been applied, check the current date
		     *&* of the msxml4.dll file in %windir%/system32 directory.
		     *&* At this writing (Sedna development timeframe), the date of msxml4.dll is 11/2006.
		   ENDTRY
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE formatdatavalue		&& Provides opportunity to re-format data value delivered in EvaluateContents appropriately for text/TRANSFORM'd version.
		LPARAMETERS m.tVal
		IF INLIST(VARTYPE(m.tVal),"D","T")
		   RETURN TTOC(m.tVal,3) 
		ELSE
		   * a subclass could do more here
		   RETURN TRANSFORM(m.tVal)
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE frxcharsetsinuse		&& Determine whether the FRX for a report run has layout elements with explicit charset instructions.
		LPARAMETERS tcAlias
		LOCAL m.liSession, m.liSelect, m.liTally, m.liRec, m.lcAlias, m.llSwitchSessions
		
		IF VARTYPE(tcAlias) # "C" OR EMPTY(tcAlias) OR UPPER(ALLTRIM(tcAlias)) == "FRX"
		   m.lcAlias = "FRX"
		   m.llSwitchSessions = .T.
		ELSE
		   m.lcAlias = ALLTRIM(tcAlias)
		ENDIF   
		
		m.liTally = 0
		
		IF THIS.FRXDataSession > -1 AND m.llSwitchSessions
		   m.liSession = SET("DATASESSION")
		   THIS.setFRXDataSession()
		ELSE
		   m.liSession = -1   
		ENDIF   
		
		IF USED(m.lcAlias)
		   m.liSelect = SELECT(0)
		   m.liRec = RECNO(m.lcAlias)
		   SELECT (m.lcAlias)
		   COUNT ALL FOR INLIST(ObjType,;
		                        FRX_OBJTYP_LABEL,;
		                        FRX_OBJTYP_FIELD) AND ;
		                  Double AND Resoid # 1 ;
		         TO m.liTally            
		         *&* RESOID=1 indicates use of default locale, treat this like no charset indication
		         *&* do not pay attention to header value, just text labels and expressions,
		         *&* because the header value doesn't propagate to existing controls (even at designtime)
		         *&* -- it just indicates the default for new objects.        
		         *&* If you adjusted the FRX contents at runtime with new 
		         *&* text controls, you might want to pay attention to the contents
		         *&* of the header RESOID and DOUBLE values, though -- just as the design-time
		         *&* components do.
		  IF m.liRec > RECCOUNT()
		     GO BOTTOM
		     SKIP
		  ELSE
		     GO m.liRec
		  ENDIF                   
		  SELECT (m.liSelect)
		ENDIF
		
		IF m.liSession > -1
		   SET DATASESSION TO (m.liSession)
		ENDIF
		
		RETURN (m.liTally > 0)
	ENDPROC

	PROTECTED PROCEDURE getdefaultuserxslt		&& Provides a hook for subclasses to supply their preferred XSLT document for use when XMLListener automatically applies XSLT at the end of a report run.
		** this is an abstract method for use by subclasses
	ENDPROC

	PROTECTED PROCEDURE getfrxlayoutobjectfieldlist		&& Provides fields list to the getVFPRdlContents method, in a suitable comma-delimited format for inclusion as a macro in SQL SELECT statement from FRX cursor and related Bands and Objects cursors.
		LPARAMETERS m.tcAlias
		* frx
		* PLATFORM,UNIQUEID,TIMESTAMP,OBJTYPE,OBJCODE,NAME,EXPR,VPOS,HPOS,HEIGHT,WIDTH,STYLE,
		* PICTURE,ORDER,UNIQUE,COMMENT,ENVIRON,BOXCHAR,FILLCHAR,TAG,TAG2,PENRED,PENGREEN,PENBLUE,
		* FILLRED,FILLGREEN,FILLBLUE,PENSIZE,PENPAT,FILLPAT,FONTFACE,FONTSTYLE,FONTSIZE,MODE,RULER,
		* RULERLINES,GRID,GRIDV,GRIDH,FLOAT,STRETCH,STRETCHTOP,TOP,BOTTOM,SUPTYPE,SUPREST,NOREPEAT,RESETRPT,PAGEBREAK,COLBREAK,RESETPAGE,GENERAL,SPACING,DOUBLE,SWAPHEADER,SWAPFOOTER,EJECTBEFOR,EJECTAFTER,PLAIN,SUMMARY,ADDALIAS,OFFSET,TOPMARGIN,BOTMARGIN,TOTALTYPE,RESETTOTAL,RESOID,CURPOS,SUPALWAYS,SUPOVFLOW,SUPRPCOL,SUPGROUP,SUPVALCHNG,SUPEXPR,USER
		* objects
		* UNIQUEID,OBJTYPE,OBJCODE,EXPR,VPOS,HPOS,HEIGHT,WIDTH,OBJNAME,LOCALE_ID,START_BAND_ID,BAND_OFFSET,END_BAND_ID,BANDLABEL,SELECTED,OBJ_PICT,BAND_SEQ
		* bands
		* UNIQUEID,OBJTYPE,OBJCODE,EXPR,BANDLABEL,START,STOP,HEIGHT,P_START,P_STOP,P_HEIGHT,RESETTOTAL,BAND_SEQ,REL_BAND_ID
		
		
		
		RETURN ;
		       "RECNO() AS FrxRecno, "+m.tcAlias+".PLATFORM, "+m.tcAlias+".NAME,"+m.tcAlias+".EXPR,"+m.tcAlias+".OFFSET,"+m.tcAlias+".VPOS,"+m.tcAlias+".HPOS,"+m.tcAlias+".HEIGHT,"+;
		       ""+m.tcAlias+".OBJTYPE, "+m.tcAlias+".TAG, "+m.tcAlias+".TAG2,"+m.tcAlias+".PENSIZE,"+m.tcAlias+".PENPAT,"+m.tcAlias+".FILLPAT,"+;
		       ""+m.tcAlias+".WIDTH,"+m.tcAlias+".STYLE,"+m.tcAlias+".PICTURE,"+m.tcAlias+".ORDER,"+m.tcAlias+".COMMENT,"+m.tcAlias+".FILLCHAR,"+;       
		       ""+m.tcAlias+".PENRED,"+m.tcAlias+".PENGREEN,"+m.tcAlias+".PENBLUE,"+m.tcAlias+".FILLRED,"+m.tcAlias+".FILLGREEN,"+m.tcAlias+".FILLBLUE,"+;
		       ""+m.tcAlias+".FONTFACE, "+m.tcAlias+".FONTSTYLE,"+m.tcAlias+".FONTSIZE,"+m.tcAlias+".MODE,"+m.tcAlias+".FLOAT,"+m.tcAlias+".STRETCH,"+m.tcAlias+".STRETCHTOP,"+; 
		       "BITTEST( "+m.tcAlias+".FONTSTYLE, 0 ) AS FontBold,"+ ;
		       "BITTEST( "+m.tcAlias+".FONTSTYLE, 1 ) AS FontItalic,"+ ;
		       "BITTEST( "+m.tcAlias+".FONTSTYLE, 3 ) AS FontUnderline,"+ ;
		       "BITTEST( "+m.tcAlias+".FONTSTYLE, 7 ) AS FontStrikeThrough,"+ ;
		       "THIS.GetPathedImageInfo("+m.tcAlias+".ObjType, "+m.tcAlias+".Name, "+m.tcAlias+".Picture, "+m.tcAlias+".Offset) AS UnpathedImg,"+ ;       
		       "THIS.GetPathedImageInfo("+m.tcAlias+".ObjType, "+m.tcAlias+".Name, "+m.tcAlias+".Picture, "+m.tcAlias+".Offset, .T.) AS PathedImg,"+ ;
		       ""+m.tcAlias+".TOP,"+m.tcAlias+".BOTTOM,"+m.tcAlias+".NOREPEAT,"+m.tcAlias+".PAGEBREAK,"+m.tcAlias+".COLBREAK,"+m.tcAlias+".RESETPAGE,"+m.tcAlias+".GENERAL,"+m.tcAlias+".SPACING,"+ ;
		       ""+m.tcAlias+".SWAPHEADER,"+m.tcAlias+".SWAPFOOTER,"+m.tcAlias+".EJECTBEFOR,"+m.tcAlias+".EJECTAFTER,"+m.tcAlias+".TOTALTYPE,"+m.tcAlias+".RESETTOTAL,"+ ;
		       "IIF("+m.tcAlias+".DOUBLE,"+m.tcAlias+".RESOID,1) AS FONTCHARSET,"+m.tcAlias+".SUPALWAYS,"+m.tcAlias+".SUPOVFLOW,"+m.tcAlias+".SUPRPCOL,"+m.tcAlias+".SUPGROUP,"+m.tcAlias+".SUPVALCHNG,"+m.tcAlias+".SUPEXPR,"+m.tcAlias+".USER,"+ ;
		       "OBJECTS.UniqueID AS ObjID, OBJECTS.ObjName, Objects.Locale_ID,"+ ;
		       "OBJECTS.START_BAND_ID,OBJECTS.BAND_OFFSET,OBJECTS.END_BAND_ID,"+ ;
		       "BANDS.UNIQUEID AS BandID,BANDS.OBJCODE AS BandType,Bands.BANDLABEL,Bands.START,"+;
		       "Bands.STOP,Bands.BAND_SEQ,Bands.REL_BAND_ID, ("+m.tcAlias+".ObjType=9 AND (NOT "+m.tcAlias+".Plain)) AS BandStretch"
	ENDPROC

	PROTECTED PROCEDURE getpathedimageinfo		&& Supplies a fully-pathed filename for an image file included in the report, using the original relative-path information stored in the FRX.
		LPARAMETERS m.tObjType, m.tName, m.tPicture, m.tOffset, m.tPathed
		LOCAL m.lcReturn, m.lcFile
		m.lcReturn = ""
		IF m.tObjType =  FRX_OBJTYP_PICTURE  
		   DO CASE
		   CASE m.tOffset = 0 && literal filename
		      m.lcReturn = STRTRAN(m.tPicture,["],[])
		      IF m.tPathed
		         m.lcReturn = FULLPATH(m.tPicture,THIS.CommandClauses.File)      
		      ELSE
		         m.lcReturn = JUSTFNAME(m.tPicture)
		      ENDIF
		   CASE m.tOffset = 1 && general field
		      m.lcReturn = "["+m.tName+"]"
		   CASE m.tOffset = 2 AND TYPE(m.tName)= "O" && imagecontrol
		      m.lcReturn = "["+m.tName+"]"   
		   CASE m.tOffset = 2 AND TYPE(m.tName) = "C" && expression
		      m.lcFile = EVALUATE(m.tName)
		      IF NOT FILE(m.lcFile)
		         m.lcFile = EVALUATE(STRTRAN(m.tName,"()","")) && indirect
		      ENDIF
		      IF FILE(m.lcFile)
		         IF m.tPathed
		            m.lcReturn = FULLPATH(EVALUATE(m.tName))
		         ELSE
		            m.lcReturn = JUSTFNAME(EVALUATE(m.tName))
		         ENDIF
		      ELSE
		         m.lcReturn =  "["+m.tName+"]" 
		      ENDIF
		   OTHERWISE
		      m.lcReturn = "["+m.tName+"]"
		   ENDCASE
		ENDIF
		m.lcReturn = PADR(CHRTRAN(m.lcReturn,"\","/"), OUTPUTXML_CHARFIELD_LIMIT)
		
		RETURN m.lcReturn
		
		
	ENDPROC

	PROTECTED PROCEDURE getrawformattinginfo		&& Formulates the appropriate formatting attributes for an element when XMLListener is streaming XML to a file.
		LPARAMETERS m.tnLeft, m.tnTop, m.tnWidth, m.tnHeight, m.tnObjectContinuationType
		LOCAL m.lcInfo
		
		m.lcInfo = ""
		
		m.lcInfo = m.lcInfo + " "+THIS.contAttr+"='"+TRANSFORM(m.tnObjectContinuationType)+"'"
		
		IF THIS.IncludeFormattingInLayoutObjects
		   m.lcInfo = m.lcInfo + " "+THIS.leftAttr+"='"+ TRANSFORM(m.tnLeft)+"'"
		   m.lcInfo = m.lcInfo + " "+THIS.topAttr+"='"+TRANSFORM(m.tnTop)+"'"
		   m.lcInfo = m.lcInfo + " "+THIS.widthAttr+"='"+TRANSFORM(m.tnWidth)+"'"      
		   m.lcInfo = m.lcInfo + " "+THIS.heightAttr+"='"+TRANSFORM(m.tnHeight)+"'"     
		ENDIF
		
		THIS.setFRXDataSession()
		
		m.llPageImages = (NOT EMPTY(THIS.currentPageImageFilename)) ;
		                  AND USED(THIS.memberDataAlias)
		
		IF THIS.includeDataTypeAttributes  OR m.llPageImages
		   IF USED(THIS.FormattingChanges) AND ;
		      SEEK(RECNO("FRX"),THIS.FormattingChanges,"FRXRecno") 
		      SELECT (THIS.FormattingChanges)                  
		      IF THIS.includeDataTypeAttributes
		         IF EMPTY(DText)
		            m.lcInfo = m.lcInfo + " "+THIS.dataTypeAttr+"='"+DType+"'"            
		         ELSE
		            m.lcInfo = m.lcInfo + " "+THIS.dataTypeAttr+"='"+DType+"'"      
		            m.lcInfo = m.lcInfo + " "+THIS.dataTextAttr+"='"+THIS.xmlRawConv(DText)+"'"     
		         ENDIF      
		      ENDIF
		   ENDIF      
		   IF m.llPageImages AND SEEK(RECNO("FRX"),THIS.memberDataAlias,"FRXRecno")
		      SELECT (THIS.memberDataAlias)
		      LOCATE FOR FRXRecno = RECNO("FRX") AND ;
		                 Type == FRX_BLDR_MEMBERDATATYPE AND ;
		                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                 ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
		                 THIS.evaluateStringToBoolean(Execute) 
		      IF FOUND()
		         m.lcInfo = m.lcInfo + " " + THIS.pageImageAttr+"='"+ ;
		                    THIS.currentPageImageFilename +"'"
		      ENDIF
		   ENDIF   
		   SELECT FRX            
		ENDIF   
		
		
		RETURN m.lcInfo
	ENDPROC

	PROTECTED PROCEDURE getrunnodecontents		&& Translates information dynamically generated and provided in the runCollector member into an XML format useful to other applications.
		LPARAMETERS m.tlAsString
		
		LOCAL m.lcItem, m.oXML, m.lvValue, m.liSession
		
		THIS.setFRXDataSession()
		m.lcItem =  IIF(SEEK( OUTPUTXML_OBJTYPE_NODES+ OUTPUTXML_OBJCODE_RUN , ;
		                      "Nodes","FrxNodes"), ;
		                       Nodes.ObjValue, ;
		                      OUTPUTXML_GOOFTAG)               
		               
		* Handles Cursor, Empty object, Collection
		* Raw or dom method.
		
		m.lcItem = "<"  + m.lcItem + "/>"
		
		m.liSession = SET("DATASESSION")
		THIS.resetDataSession()
		#IF OUTPUTXML = OUTPUTXML_DOM
		   m.oXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		#ELSE
		   m.oXML = CREATEOBJECT("Microsoft.XMLDOM")
		#ENDIF      
		SET DATASESSION TO (m.liSession)
		
		IF m.oXML.LoadXML(m.lcItem)
		   THIS.setCurrentDataSession()
		   DO CASE 
		   CASE ISNULL(THIS.runCollector)
		      m.oXML = NULL
		   CASE VARTYPE(THIS.runCollector) = "C" 
		      IF NOT (USED(THIS.runCollector) AND ;
		              RECCOUNT(THIS.runCollector) > 0)
		         * try FRX datasession
		         THIS.setFRXDataSession()
		      ENDIF        
		      IF (USED(THIS.runCollector) AND ;
		              RECCOUNT(THIS.runCollector) > 0)
		         * two fields significant, first evaluates to property value, 
		         * second is property name
		         LOCAL m.lcField1, m.lcField2, m.liIndex, m.liSelect
		         m.liSelect = SELECT(0)
		         SELECT (THIS.runCollector)
		         FOR m.liIndex = 1 TO FCOUNT()
		             IF INLIST(TYPE(FIELD(m.liIndex)),"M","C")
		                IF EMPTY(m.lcField1)
		                   m.lcField1 = FIELD(m.liIndex)
		                ELSE
		                   m.lcField2 = FIELD(m.liIndex)
		                   EXIT
		                ENDIF
		             ENDIF
		         ENDFOR
		         IF (EMPTY(m.lcField1))
		            m.oXML = NULL
		         ELSE
		            SCAN ALL FOR NOT DELETED()
		               THIS.addRunNode(m.oXML,EVAL(m.lcField1),;
		                            IIF(EMPTY(m.lcField2) OR EMPTY(EVAL(m.lcField2)), ;
		                     "P" + TRANSFORM(RECNO()), EVAL(m.lcField2)))
		            ENDSCAN
		         ENDIF
		      ENDIF         
		      SELECT (m.liSelect)      
		   CASE VARTYPE(THIS.runCollector) = "O" AND ;
		       TYPE("THIS.runCollector.Baseclass") = "U"
		         * empty object
		       LOCAL m.liIndex, m.laMembers[1]
		       IF AMEMBERS(m.laMembers,THIS.runCollector) = 0
		          m.oXML = NULL
		       ELSE
		          FOR m.liIndex = 1 TO ALEN(m.laMembers)
		             THIS.addRunNode(m.oXML,;
		                             "THIS.runCollector." + m.laMembers[m.liIndex], ;
		                             m.laMembers[m.liIndex])
		          ENDFOR
		       ENDIF          
		   CASE VARTYPE(THIS.runCollector) = "O" AND ;
		      UPPER(THIS.runCollector.BaseClass) == "COLLECTION"
		      LOCAL m.liIndex
		      IF THIS.runCollector.Count = 0
		         m.oXML = NULL
		      ELSE
		         FOR m.liIndex = 1 TO THIS.runCollector.Count
		            THIS.addRunNode(m.oXML,"THIS.runCollector[" + TRANSFORM(m.liIndex) + "]",;
		                            IIF(EMPTY(THIS.runCollector.getKey[m.liIndex]), ;
		                                "P" + TRANSFORM(m.liIndex), ;
		                                THIS.runCollector.getKey[m.liIndex] ))
		         ENDFOR
		         
		      ENDIF         
		   OTHERWISE
		      m.oXML = NULL
		   ENDCASE      
		   
		   THIS.setFRXDataSession()
		
		   DO CASE
		   CASE ISNULL(m.oXML)
		      RETURN NULL
		   CASE m.tlAsString
		      RETURN m.oXML.DocumentElement.XML   
		   OTHERWISE
		      RETURN m.oXML.DocumentElement
		   ENDCASE
		ELSE
		   RETURN NULL
		ENDIF      
		   
	ENDPROC

	PROTECTED PROCEDURE getvfprdlcontents		&& Translates report definition layout metadata, from the FRX and the current report run, into an XML format useful to other applications.
		LPARAMETERS m.tcNodeName, m.tlAsString
		* NB: no push/pop session here, don't bother
		* because we're switching back and forth
		* rapidly and not changing anything important
		LOCAL m.liSelectCurrent, m.liSelectFRX, m.liSession, ;
		      m.liFlds, m.liDBFS, m.liIndex1, m.liIndex2, laFlds[1], ;
		      laDBFS[1], laRels[1], m.lcAlias, m.lcKey, m.llDesc, ;
		      m.lcFilter, m.lcRel, m.liRels, m.lcSkip, m.lcResult, m.llWholePage
		LOCAL m.oXA, m.oXT1, m.oXT2, m.oXT3, m.oXT4, m.oXT5,m.oXT6, ;
		      m.oXML, m.oNode, m.oCommand
		m.liSession = SET("DATASESSION")
		THIS.setFRXDataSession()
		m.liSelectFRX = SELECT(0)
		IF THIS.IncludeDataSourcesInVFPRDL
		   CREATE CURSOR VFPDataSource (the_alias c(200), rpt_driver l, the_dbf m, the_order m, order_desc l, the_filter m, the_skip m )
		   CREATE CURSOR flds (the_alias c(200), the_field m, the_type c(1))
		   CREATE CURSOR rels (the_parent c(200), the_target c(200), the_expr m)
		   SELECT flds
		   INDEX ON the_alias TAG the_alias
		   SELECT rels
		   INDEX ON the_parent TAG the_alias
		   SELECT VFPDataSource
		   SET RELATION TO the_alias INTO flds, the_alias INTO rels
		   THIS.setCurrentDataSession() 
		   m.liSelectCurrent = SELECT(0)
		   m.liDBFS = AUSED(laDBFS) 
		   FOR m.liIndex = 1 TO m.liDBFS
		      THIS.setCurrentDataSession()
		      m.lcAlias = laDBFs[m.liIndex,1]
		      SELECT (m.lcAlias)
		      m.lcDBF = DBF()
		      m.liFlds = AFIELDS(laFlds)
		      m.lcKey = SET("ORDER")
		      m.llDesc =  (" DESC" $ UPPER(m.lcKey))   
		      m.lcFilter = SET("FILTER")
		      m.lcSkip = SET("SKIP")
		      IF NOT EMPTY(m.lcKey)
		         m.lcKey = STRTRAN(UPPER(m.lcKey),"TAG","")
		         m.liIndex2 = ATC(" OF",m.lcKey)
		         IF m.liIndex2 > 0
		            m.lcKey = LEFT(m.lcKey,m.liIndex2)
		         ENDIF
		         m.lcKey = ALLTR(m.lcKey)
		         m.liTag = TAGNO(m.lcKey)
		         IF m.liTag > 0
		            m.lcKey = KEY(m.liTag)
		         ELSE
		            m.lcKey = ""
		         ENDIF
		      ENDIF    
		      m.liRels = 0
		      STORE "" TO laRels
		      DO WHILE .T.
		         m.lcRel = RELATION(m.liRels + 1)
		         IF EMPTY(m.lcRel)
		            EXIT
		         ELSE
		            m.liRels = m.liRels + 1
		            DIME laRels[m.liRels,3]
		            laRels[m.liRels,1] = TARGET(m.liRels)
		            laRels[m.liRels,2] = m.lcRel
		         ENDIF
		      ENDDO
		      THIS.setFRXDataSession()
		      INSERT INTO VFPDataSource VALUES (m.lcAlias, (UPPER(m.lcAlias)==UPPER(THIS.Drivingalias)), m.lcDBF, m.lcKey, m.llDesc, m.lcFilter, m.lcSkip)
		      FOR m.liIndex2 = 1 TO m.liFlds
		         INSERT INTO flds VALUES (m.lcAlias, laFlds[m.liIndex2,1], laFlds[m.liIndex2,2])
		      ENDFOR
		      FOR m.liIndex2 = 1 TO m.liRels
		         INSERT INTO rels VALUES (m.lcAlias, laRels[m.liIndex2,1], laRels[m.liIndex2,2])   
		      ENDFOR
		   ENDFOR
		   THIS.setCurrentDataSession()
		   SELECT (m.liSelectCurrent)
		ENDIF
		THIS.setFRXDataSession()
		m.lcAlias = THIS.prepareFrxCopy()
		m.lcResult = THIS.getFRXLayoutObjectFieldList(m.lcAlias)
		SELECT &lcResult ;
		   FROM (m.lcAlias) ;
		   LEFT JOIN Bands ON &lcAlias..UniqueID = Bands.UniqueID ;
		   LEFT JOIN Objects ON &lcAlias..UniqueID = Objects.UniqueID ;
		   WHERE Platform = FRX_PLATFORM_WINDOWS AND NOT DELETED() ;
		   INTO CURSOR VFPFRXLayoutObject READWRITE
		THIS.removeFRXCopy(m.lcAlias)   
		SELECT VFPFRXLayoutObject
		* get rid of compiled data:
		IF TYPE("VFPFRXLayoutObject.Tag") # "U"
		   REPLACE Tag WITH "" ALL FOR NOT INLIST(ObjType,FRX_OBJTYP_VARIABLE,FRX_OBJTYP_BAND,FRX_OBJTYP_DATAENV ,FRX_OBJTYP_DATAOBJ)
		ENDIF
		IF TYPE("VFPFRXLayoutObject.Tag2") # "U"
		   REPLACE Tag2 WITH "" ALL FOR INLIST(ObjType,FRX_OBJTYP_REPORTHEADER,FRX_OBJTYP_DATAENV,FRX_OBJTYP_DATAOBJ)
		ENDIF
		IF TYPE("VFPFRXLayoutObject.Fontface") # "U"
		   REPLACE Fontface WITH ""  ALL FOR INLIST(ObjType,FRX_OBJTYP_DATAENV,FRX_OBJTYP_DATAOBJ)
		ENDIF   
		GO TOP IN VFPFRXLayoutObject
		m.llWholePage = VFPFRXLayoutObject.Top 
		SELECT Nodes.ObjValue AS Name, ;
		       Nodes.ObjType-OUTPUTXML_OBJTYPE_NODES AS Type, ;
		       Nodes.ObjCode AS Code, ;
		       Nodes.ObjInfo AS Info ;
		    FROM Nodes ;   
		    WHERE BETWEEN(ObjType,OUTPUTXML_OBJTYPE_NODES, OUTPUTXML_OBJTYPE_NODES+100) ;
		    AND NOT DELETED() ;
		    INTO CURSOR VFPFRXLayoutNode READWRITE
		m.liFlds = AMEMBERS(laFlds, THIS,0)
		FOR m.liIndex1 = 1 TO m.liFlds
		   IF ATC("attr",laFlds[m.liIndex1]) > 1
		      INSERT INTO VFPFRXLayoutNode VALUES ;
		        (TRANSFORM(EVALUATE("THIS."+laFlds[m.liIndex1])),;
		         0, ;
		         OUTPUTXML_OBJCODE_ATTRIBMEMBER,;
		         laFlds[m.liIndex1]+ " attribute nodename")
		   ENDIF
		ENDFOR   
		m.oXA=CREATEOBJECT("XMLAdapter")
		m.oXA.RespectCursorCP = .T.
		m.oXT4 = m.oXA.AddTableSchema("VFPFRXLayoutObject")
		m.oXT5 = m.oXA.AddTableSchema("VFPFRXLayoutNode")
		
		IF USED(THIS.memberDataAlias) AND ;
		   RECCOUNT(THIS.memberDataAlias) > 0
		   m.oXT6 = m.oXA.AddTableSchema(THIS.memberDataAlias,.F.,;
		                                 STRCONV("VFPFRXMemberData",STRCONV_DBCS_UNICODE))
		ENDIF
		m.oXA.RespectNesting=.T.
		IF THIS.IncludeDataSourcesInVFPRDL
		   m.oXT1=oXA.AddTableSchema("VFPDataSource")
		   m.oXT2=oXA.AddTableSchema("flds")
		   m.oXT3=oXA.AddTableSchema("rels")
		   m.oXT1.Nest(m.oXT2)
		   m.oXT1.Nest(m.oXT3)
		ENDIF
		
		m.oXA.XMLSchemaLocation = ""
		m.oXA.ToXML("lcResult")
		THIS.resetDataSession()
		#IF OUTPUTXML = OUTPUTXML_DOM
		   m.oXML = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		#ELSE
		   m.oXML = CREATEOBJECT("Microsoft.XMLDOM")
		#ENDIF      
		THIS.setFRXDataSession()
		m.oXML.LoadXML(m.lcResult)
		m.oNode = m.oXML.SelectSingleNode("/./*")
		IF NOT ISNULL(THIS.CommandClauses)
		   m.oCommand = m.oXML.createElement("VFPFRXCommand")
		   m.liFlds = AMEMBERS(laFlds, THIS.CommandClauses)   
		   FOR m.liIndex1 = 1 TO m.liFlds
		       m.lcKey = EVAL("THIS.CommandClauses."+laFlds[m.liIndex1]) 
		       IF VARTYPE(m.lcKey) = "L"
		          IF m.lcKey
		             m.lcKey = "true"
		          ELSE
		             m.lcKey = "false"
		          ENDIF
		       ENDIF
		       m.oCommand.SetAttribute(laFlds[m.liIndex1], TRANSFORM(m.lcKey))
		   ENDFOR
		   m.oCommand.SetAttribute("OutputType",TRANSFORM(THIS.OutputType))
		   m.oCommand.SetAttribute("appName",THIS.appName)
		   m.oCommand.SetAttribute("targetFileName",THIS.targetFileName)
		   m.oNode.appendChild(m.oCommand)
		ENDIF   
		m.oCommand =  oXML.createElement("VFPFRXPrintJob")
		m.oCommand.SetAttribute("pagewidth", THIS.SharedPageWidth)
		m.oCommand.SetAttribute("pageheight", THIS.SharedPageHeight)
		m.oCommand.SetAttribute("name",THIS.PrintJobName)
		m.oCommand.SetAttribute("pagedesign",IIF(llWholePage,"whole","printable"))
		TRY
		   * if PROMPT was used this will probably work
		   m.oCommand.SetAttribute("printresolution",TRANSFORM(PRTINFO(PRT_YRESOLUTION ,SET("PRINTER",3))))
		   #IF .F. 
		      * OUTPUTXML_RESOLUTIONFIX
		      * try to reset based on current printer FRX information
		      GO (THIS.frxHeaderRecno) IN FRX
		      SELECT FRX
		      m.liIndex = IIF(ALINES(laFlds,Picture,.T.) > 0, ASCAN(laFlds,"YRESOLUTION"),0) 
		      IF m.liIndex = 0
		         m.liIndex = IIF(ALINES(laFlds,Expr,.T.) > 0, ASCAN(laFlds,"YRESOLUTION"),0) 
		      ENDIF
		      IF m.liIndex > 0
		         m.liIndex = VAL(ALLTRIM(SUBSTR(laFlds[liIndex],AT("=",laFlds[m.liIndex])+1)))
		         IF m.liIndex > 0
		            m.oCommand.SetAttribute("printresolution",TRANSFORM(m.liIndex))         
		         ELSE
		            m.oCommand.SetAttribute("printresolution","-1")                  
		         ENDIF
		      ENDIF
		      IF USED("SetPrinter")
		         USE IN SetPrinter
		      ENDIF
		   #ENDIF    
		CATCH WHEN .T.
		   * this can happen when there is no printer
		   m.oCommand.SetAttribute("printresolution","-1") 
		ENDTRY   
		m.oNode.appendChild(m.oCommand)
		IF THIS.IncludeDataSourcesInVFPRDL
		   USE IN VFPDataSource
		   USE IN flds
		   USE IN rels
		ENDIF   
		USE IN VFPFRXLayoutObject
		USE IN VFPFRXLayoutNode
		STORE NULL TO ;
		   m.oXA, m.oXT1, m.oXT2, m.oXT3, m.oXT4, m.oXT5, m.oXT6, m.oXML, m.oCommand
		SELECT (m.liSelectFRX)
		SET DATASESSION TO (m.liSession)
		IF tlAsString
		   RETURN m.oNode.XML
		ELSE
		   RETURN m.oNode
		ENDIF
	ENDPROC

	PROCEDURE heightattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.heightAttr = m.vNewVal
		ENDIF   
		
		
		
	ENDPROC

	PROCEDURE idattribute_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.idattribute = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE idrefattribute_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.idrefattribute = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE includebandswithnoobjects_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning 
		   THIS.IncludeBandsWithNoObjects = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE includebreaksindata_assign
		LPARAMETERS m.vNewVal
		* Readonly during report run
		
		IF VARTYPE(m.vNewVal) = "N" AND ;
		   INLIST(m.vNewVal, ;
		          OUTPUTXML_BREAKS_INDATA,;
		          OUTPUTXML_BREAKS_NONE, ;
		          OUTPUTXML_BREAKS_COLLECTION) AND ;
		   NOT THIS.IsRunning 
		   THIS.IncludeBreaksInData = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE includedatasourcesinvfprdl_assign
		LPARAMETERS m.vNewVal
		
		IF VARTYPE(m.vNewVal) = "L" 
		   THIS.IncludeDataSourcesinVFPRDL = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE includedatatypeattributes_assign
		LPARAMETERS m.tvNewVal
		IF VARTYPE(m.tvNewVal) = "L"
		   THIS.includeDataTypeAttributes = m.tvNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE includeformattinginlayoutobjects_assign
		LPARAMETERS m.vNewVal
		*TBD: evaluate whether
		* it's okay to do this during a run?
		
		IF VARTYPE(m.vNewVal) = "L"
		   THIS.IncludeFormattingInLayoutObjects = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE Init
		THIS.ReadConfiguration = OUTPUTCLASS_READCONFIG_INIT
		
		IF DODEFAULT()
		   THIS.AppName = OUTPUTXML_APPNAME_LOC
		   THIS.ResetDocument()
		ELSE
		   RETURN .F.   
		ENDIF
		
		IF THIS.applyUserTransform
		   THIS.GetDefaultUserXSLT()
		ENDIF   
		RETURN NOT THIS.HadError
	ENDPROC

	PROTECTED PROCEDURE initializeformattingchangescursor		&& Evaluates requirements for a cursor to hold information gathered for Field layout controls during this report run and creates it if necessary.
		THIS.formattingChanges= "F"+SYS(2015)
		IF THIS.includeDataTypeAttributes 
		   CREATE CURSOR (THIS.formattingChanges) ;
		             (FRXRecno i, ;
		              DText M, ;
		              DType C(1))
		ENDIF 
	ENDPROC

	PROTECTED PROCEDURE insertxmlconfigrecords		&& Adds a record to the configuration table describing a default XML node when XML Listener is creating or editing a shared configuration table.
		* protected,
		* assumes it is being called with config
		* table already SELECTed.
		
		   DELETE FOR ;
		      BETWEEN(OBJTYPE,OUTPUTXML_OBJTYPE_NODES, OUTPUTXML_OBJTYPE_NODES + 100)
		
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_TITLE,'','Title','Title Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
		      FRX_OBJCOD_PAGEHEADER,'','PH','Page Header Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
		      FRX_OBJCOD_COLHEADER,'','CH','Column Header Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND,;
		      FRX_OBJCOD_GROUPHEADER,'','GH','Group Header Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_DETAIL,'','D','Detail Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_GROUPFOOTER,'','GF','Group Footer Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_COLFOOTER,'','CF','Column Footer Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_PAGEFOOTER,'','PF','Page Footer Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_SUMMARY,'','Summary','Summary Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_DETAILHEADER,'','DH','Detail Header Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_BAND, ;
		      FRX_OBJCOD_DETAILFOOTER,'','DF','Detail Footer Band nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER,;
		      FRX_OBJCOD_REPORTHEADER ,'','VFP-Report','Report root nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_LABEL, ;
		      FRX_OBJCOD_OTHER,'','T','Text object nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_FIELD, ;
		      FRX_OBJCOD_OTHER,'','E','Expression object nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_PICTURE,;
		      FRX_OBJCOD_OTHER,'','P','Picture object nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_RECTANGLE,;
		      FRX_OBJCOD_RECTANGLE,'','S','Shape object nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_LINE, ;
		      FRX_OBJCOD_OTHER,'','L','Line object nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_VARIABLE,;
		      FRX_OBJCOD_OTHER,'','V','Variable nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_FONTRES,;
		      FRX_OBJCOD_OTHER,'','FontRes','FontResource nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAENV,;
		      FRX_OBJCOD_OTHER,'','DataEnv','DataEnvironment nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAOBJ,;
		      FRX_OBJCOD_OTHER,'','DE-Cursor','DE-Cursor nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_DATAOBJ, ;
		      FRX_OBJCOD_OTHER+1,'','DE-Relation','DE-Relation nodename')
		     * offset the DE Relation because
		     * this information isn't in ObjType or ObjCode
		     * as distinct from DE-Cursor other than in the Name field
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_GROUP, ;
		      FRX_OBJCOD_OTHER,'','Group','Group selector nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES, ;
		     OUTPUTXML_OBJCODE_DOC,'','Reports','XML Document root nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES,;
		     OUTPUTXML_OBJCODE_DATA,'','Data','Report scope data root nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES, ;
		     OUTPUTXML_OBJCODE_RDL,'','VFP-RDL','RDL layout description root nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES, ;
		     OUTPUTXML_OBJCODE_PAGES,'','Pages','Pages collection root nodename')
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES, ;
		     OUTPUTXML_OBJCODE_COLS,'','Columns','Column collection root nodename')
		   *&* Sedna     
		   INSERT INTO (ALIAS()) VALUES ;
		    (OUTPUTXML_OBJTYPE_NODES, ;
		     OUTPUTXML_OBJCODE_RUN,'','Run','Run property set root nodename')
		
	ENDPROC

	PROCEDURE invokeoncurrentpass
		RETURN (THIS.includePage) AND ;
		       (NOT THIS.XMLMode = OUTPUTXML_RDL_ONLY ) AND ;
		       ((NOT THIS.TwoPassProcess) OR THIS.CurrentPass = LISTENER_FULLPASS)
		        
		
		
	ENDPROC

	PROCEDURE leftattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.leftAttr = m.vNewVal
		ENDIF   
		
		
	ENDPROC

	PROTECTED PROCEDURE loadprocessorobject		&& Provides a generic means to load an XSLT processor object from a string representing an XSLT document or a filename.
		LPARAMETERS m.tcVal
		
		LOCAL m.loReturn
		m.loReturn = NULL
		
		IF VARTYPE(m.tcVal) = "C" AND NOT EMPTY(m.tcVal)
		  LOCAL m.loProcessor, m.loStylesheet, m.liSession
		  m.liSession = SET("DATASESSION")
		  THIS.resetDataSession()
		  m.loProcessor  = CREATEOBJECT(OUTPUTXML_XSLT_PROCESSOROBJECT)
		  m.loStyleSheet = CREATEOBJECT(OUTPUTXML_DOMFREETHREADED_DOCUMENTOBJECT)
		  THIS.fixMSXMLObjectForDTDs(m.loStyleSheet)
		  SET DATASESSION TO (m.liSession)
		  IF FILE(m.tcVal)
		    m.loStyleSheet.Load(m.tcVal)
		  ELSE
		    * try to load it as a string
		    m.loStyleSheet.LoadXML(m.tcVal)
		  ENDIF
		  IF LEN(m.loStyleSheet.XML) > 0 AND ;
		     EMPTY(m.loStyleSheet.parseError.reason)
		     m.loProcessor.styleSheet = loStyleSheet
		     m.loReturn = m.loProcessor
		*  ELSE     
		*     THIS.LastErrorMessage = loSStyleSheet.parseError.reason
		  ENDIF   
		ENDIF
		
		RETURN loReturn
	ENDPROC

	PROCEDURE nopageeject_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "L" AND NOT THIS.IsRunning
		   THIS.NoPageEject = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROCEDURE opentargetfile
		#IF OUTPUTXML = OUTPUTXML_DOM
		   THIS.VerifyTargetFile() 
		   THIS.TargetHandle = 0
		   RETURN (NOT THIS.HadError)
		#ELSE
		   RETURN DODEFAULT()   
		#ENDIF
		
	ENDPROC

	PROCEDURE pageimageattr_assign
		LPARAMETERS vNewVal
		
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.pageImageAttr = m.vNewVal
		ENDIF   
		
		
	ENDPROC

	PROTECTED PROCEDURE preparefrxcopy		&& Prepares FRX alias or copy for use in creating VFP-RDL contents.
		LOCAL m.lcAlias, m.lcFile
		m.lcAlias = "FRX"
		IF EMPTY(SYS(2000,THIS.CommandClauses.File)) AND ;
		   USED("FRX")
		   *&* streamlined in Sedna leveraging new superclass capabilities.   
		   m.lcFile = THIS.prepareFRXSwapCopy(JUSTPATH(THIS.targetFileName),.T.)
		   m.lcAlias = JUSTSTEM(m.lcFile)   
		   * prepareFRXSwapCopy defines the file name suitably for the
		   * above JUSTSTEM() evaluation -> alias to work all the time.
		   SELECT FRX
		ENDIF
		RETURN m.lcAlias
	ENDPROC

	PROTECTED PROCEDURE removefrxcopy		&& Removes FRX copy used in preparing VFP-RDL.
		LPARAMETERS m.tcAlias
		LOCAL m.lcFile
		IF m.tcAlias # "FRX"
		   m.lcFile = DBF(m.tcAlias)
		   USE IN (m.tcAlias)
		   * streamlined in Sedna using
		   * new superclass feature
		   THIS.removeFRXSwapCopy(m.lcFile) 
		ENDIF      
		
	ENDPROC

	PROCEDURE Render
		LPARAMETERS m.nFRXRecNo, m.nLeft,m.nTop,m.nWidth,m.nHeight, ;
		            m.nObjectContinuationType, m.cContentsToBeRendered, m.GDIPlusImage
		
		IF NOT ISNULL(THIS.successorGFXNoRender)
		   * XML Output and descendents respect norendering properties
		   * as successors, evaluating them individually since the conditions
		   * might apply only to some output types
		   IF THIS.successorGFXNoRender.applyFX(THIS,"RENDER",m.nFRXRecNo, m.nLeft) = ;
		       OUTPUTFX_BASERENDER_NORENDER
		       RETURN OUTPUTFX_BASERENDER_NORENDER
		   ENDIF                
		ENDIF
		
		IF (DODEFAULT(m.nFRXRecNo, @m.nLeft,@m.nTop,@m.nWidth,@m.nHeight, ;
		              @m.nObjectContinuationType, @m.cContentsToBeRendered, @m.GDIPlusImage) # ;
		              OUTPUTFX_BASERENDER_NORENDER) AND ;
		   THIS.InvokeOnCurrentPass() AND ;
		   THIS.Targethandle > -1 
		
		   * also evaluate THIS.IncludeBreaksInData and 
		   * the band for the object in question.
		
		   * If the stars align, create the node for the object here.  For now:
		   
		   LOCAL m.lcNode, m.loNode, m.lcFormattingInfo, m.lcContents,  ;
		         m.llTextType, m.loBandRef, m.liBandRecno, m.lcID
		  
		   THIS.SetFRXDataSession()
		   
		   GO m.nFRXRecNo IN FRX
		   
		
		   m.lcContents = m.cContentsToBeRendered
		   m.llTextType = INLIST(FRX.ObjType,  FRX_OBJTYP_LABEL, FRX_OBJTYP_FIELD)
		   m.lcID = TRANSFORM(m.nFRXRecNo)
		   IF INLIST(m.nObjectContinuationType, ;
		             LISTENER_CONTINUATION_MIDDLE, ;
		             LISTENER_CONTINUATION_END)
		      m.lcID = m.lcID + "+"
		   ENDIF
		
		      
		   IF THIS.IncludeBreaksInData = OUTPUTXML_BREAKS_COLLECTION ;
		      OR (ISNULL(THIS.CurrentPage) AND ISNULL(THIS.CurrentColumn))
		      m.lcNode =   IIF(SEEK(OUTPUTXML_OBJTYPE_NODES+FRX.ObjType,"Nodes","ObjType"), ;
		                     Nodes.ObjValue,;
		                     OUTPUTXML_GOOFTAG)
		                  
		      #IF OUTPUTXML = OUTPUTXML_RAW
		          m.lcFormattingInfo = THIS.GetRawFormattingInfo( m.nLeft, m.nTop, m.nWidth,m.nHeight, m.nObjectContinuationType)
		          THIS.setFRXDataSession()          
		          IF m.llTextType
		             * build 1515: render gets unicode
		             m.lcContents = STRCONV(TRANSFORM(m.lcContents),STRCONV_UNICODE_UTF8)
		          ELSE
		             m.lcContents = TRANSFORM(m.lcContents)  
		          ENDIF
		          DO CASE
		          CASE NOT ISNULL(THIS.CurrentPage)
		             THIS.CurrentPage = THIS.CurrentPage +  ;
		                 THIS.XMLRawNode( ;
		                 m.lcNode, ;
		                 m.lcContents, ;
		                 m.lcID,.F.,m.lcFormattingInfo) && FRX.UniqueID
		          CASE NOT ISNULL(THIS.CurrentColumn)
		             THIS.CurrentColumn = THIS.CurrentColumn +  ;
		                 THIS.XMLRawNode( ;
		                 m.lcNode, ;
		                 m.lcContents, ;
		                 m.lcID,.F.,m.lcFormattingInfo) 
		          OTHERWISE 
		             * write directly to the stream
		             * First, take care of continuation.
		             IF EMPTY(NVL(THIS.CurrentBand,""))
		                * first object in a continued band
		                 IF ISNULL(THIS.FRXCursor)
		                    m.liBandRecno = 0
		                 ELSE
		                    m.loBandRef =  THIS.FRXCursor.GetBandFor(FRX.UniqueID, .T.,THIS.FRXDataSession)
		                    SELECT FRX
		                    LOCATE FOR UniqueID == loBandRef.UniqueID
		                    IF EOF()
		                       m.liBandRecno = 0
		                    ELSE
		                       m.liBandRecno = RECNO()
		                    ENDIF
		                 ENDIF
		                 IF m.liBandRecno = 0
		                    THIS.CurrentBand = THIS.XMLRawTag(OUTPUTXML_GOOFTAG, .T.,;
		                                  "0",TRANSFORM(IIF(THIS.sharedPageNo = 0, THIS.PageNo, THIS.sharedPageNo)) )
		                 ELSE
		                    THIS.SetCurrentDataSession()
		                    THIS.BeforeBand(FRX_OBJCOD_DETAIL,m.liBandRecno, .T.)
		                    THIS.SetFRXDataSession()
		                 ENDIF                 
		                 THIS.CurrentBand = THIS.CurrentBand + ;
		                      THIS.XMLRawNode( ;
		                       m.lcNode, ;
		                       m.lcContents, ;
		                       m.lcID,.F.,m.lcFormattingInfo) 
		                IF EOF()      
		                   THIS.WriteRaw(THIS.CurrentBand + ;
		                                THIS.XMLRawTag(OUTPUTXML_GOOFTAG))
		                   THIS.CurrentBand = ""               
		                ENDIF
		                GO m.nFRXRecNo IN FRX
		             ELSE      
		                THIS.CurrentBand = THIS.CurrentBand + ;
		                     THIS.XMLRawNode( ;
		                      m.lcNode, ;
		                      m.lcContents, ;
		                      m.lcID,.F., m.lcFormattingInfo) 
		             ENDIF
		             
		          ENDCASE
		     
		      #ELIF OUTPUTXML =  OUTPUTXML_DOTNET
		          * XMLTextWriter work
		      #ELSE      
		          * if continuation type is of type 2 or 3
		          * and we're in a text type object
		          * we have to create a new
		          * continued band node as if a BeforeBand event has occurred.         
		          THIS.setFRXDataSession()
		          IF ISNULL(THIS.CurrentBand)
		             * first object in a continued band
		             IF ISNULL(THIS.FRXcursor)
		                m.liBandRecno = 0
		             ELSE
		                m.loBandRef =  THIS.FRXCursor.GetBandFor(FRX.UniqueID, .T., THIS.FRXDataSession)
		                SELECT FRX
		                LOCATE FOR UniqueID == m.loBandRef.UniqueID
		                m.liBandRecno = RECNO()
		             ENDIF
		             THIS.SetCurrentDataSession()
		             IF EOF()
		                 THIS.BeforeBand(FRX_OBJCOD_DETAIL,1, .T.)
		             ELSE
		                 THIS.BeforeBand(FRX_OBJCOD_DETAIL,m.liBandRecno, .T.)
		             ENDIF
		             THIS.SetFRXDataSession()
		             GO m.nFRXRecNo IN FRX
		          ENDIF
		          m.loNode = THIS.CurrentDocument.CreateElement(m.lcNode)          
		          m.lcContents = TRANSFORM(m.lcContents)            
		          * build 1515: render gets unicode, and is already regionally transformed          
		          * EXCEPT if it's a filename for an image, in which case it's DBCS          
		          IF m.llTextType 
		             m.loNode.Text = CREATEBINARY(m.lcContents)          
		          ELSE
		             m.loNode.Text = m.lcContents          
		          ENDIF             
		          m.loNode.SetAttribute(THIS.IdAttribute,m.lcID)
		          THIS.SetDOMFormattingInfo( m.loNode, m.nLeft, m.nTop, m.nWidth,m.nHeight, m.nObjectContinuationType)
		          DO CASE
		          CASE NOT ISNULL(THIS.CurrentPage)
		             THIS.CurrentPage.AppendChild(m.loNode)          
		          CASE NOT ISNULL(THIS.CurrentColumn)
		             THIS.CurrentColumn.AppendChild(m.loNode)          
		          OTHERWISE
		             THIS.CurrentBand.AppendChild(m.loNode)                     
		          ENDCASE
		          m.loNode = NULL
		       #ENDIF
		   ELSE
		      * otherwise object belongs to a formatting header or footer
		      * and we're not processing them (XMLBREAKS_NONE)
		   ENDIF                   
		   
		   THIS.resetDataSession()
		   
		ENDIF
		
		RETURN  
	ENDPROC

	PROCEDURE resetcallevaluatecontents
		IF (THIS.CallEvaluateContents # LISTENER_CALLDYNAMICMETHOD_ALWAYS) AND ;
		   THIS.includeDataTypeAttributes AND ;
		   (THIS.xmlMode #  OUTPUTXML_RDL_ONLY)
		   THIS.CallEvaluateContents = LISTENER_CALLDYNAMICMETHOD_ALWAYS
		ENDIF
	ENDPROC

	PROCEDURE resetdocument		&& Resets the XML document after a report run.
		* Do *not* reset 
		* page number/total
		THIS.ResetReport()   
		THIS.CloseTargetFile()
		THIS.NoPageEject = .F.
		IF THIS.HadError
		   THIS.ResetToDefault("QuietMode")
		ENDIF   
		THIS.CurrentDocument = NULL
		
		
		
		
	ENDPROC

	PROTECTED PROCEDURE resetreport		&& Resets information for a report-level node during the production of an XML document that may span multiple reports.
		THIS.IncludePage = .T.
		THIS.IsRunning = .F.
		THIS.DataNodes = NULL
		THIS.PageNodes = NULL
		THIS.ColumnNodes = NULL
		THIS.CurrentBand = NULL
		THIS.CurrentPage = NULL
		THIS.CurrentColumn = NULL
		THIS.evaluateContentsValues = NULL 
		THIS.successorGFXNoRender = NULL
		THIS.ClearStatus()   
		
		
		   
		
	ENDPROC

	PROCEDURE resetruncollector
		THIS.runCollector = NULL
	ENDPROC

	PROCEDURE runcollectorresetlevel_assign
		LPARAMETERS tvNewVal
		THIS.runCollectorResetLevel = OUTPUTFX_RUNCOLLECTOR_RESET_ONREPORT
	ENDPROC

	PROTECTED PROCEDURE setdomformattinginfo		&& Formulates the appropriate formatting attributes for an element when XMLListener is using the DOM to create XML.
		LPARAMETERS m.toNode, m.tnLeft, m.tnTop, m.tnWidth,m.tnHeight, m.tnObjectContinuationType
		
		m.toNode.SetAttribute(THIS.ContAttr,TRANSFORM(m.tnObjectContinuationType))                  
		IF THIS.IncludeFormattingInLayoutObjects
		   m.toNode.SetAttribute(THIS.LeftAttr,TRANSFORM(m.tnLeft))
		   m.toNode.SetAttribute(THIS.TopAttr,TRANSFORM(m.tnTop))
		   m.toNode.SetAttribute(THIS.WidthAttr,TRANSFORM(m.tnWidth))             
		   m.toNode.SetAttribute(THIS.HeightAttr,TRANSFORM(m.tnHeight))
		ENDIF
		
		LOCAL  m.llPageImages
		
		THIS.setFRXDataSession()
		
		m.llPageImages = (NOT EMPTY(THIS.currentPageImageFilename)) ;
		                  AND USED(THIS.memberDataAlias)
		
		
		IF THIS.includeDataTypeAttributes OR m.llPageImages
		
		   IF USED(THIS.FormattingChanges) AND ;
		      SEEK(RECNO("FRX"),THIS.FormattingChanges,"FRXRecno") 
		      SELECT (THIS.FormattingChanges)    
		      IF THIS.includeDataTypeAttributes                  
		         IF EMPTY(DText)
		            m.toNode.SetAttribute(THIS.dataTypeAttr,DType)
		         ELSE
		            m.toNode.SetAttribute(THIS.dataTypeAttr,DType)
		            m.toNode.SetAttribute(THIS.dataTextAttr,DText)
		         ENDIF      
		      ENDIF
		   ENDIF    
		   IF m.llPageImages AND SEEK(RECNO("FRX"),THIS.memberDataAlias,"FRXRecno")
		      SELECT (THIS.memberDataAlias)
		      LOCATE FOR FRXRecno = RECNO("FRX") AND ;
		                 Type == FRX_BLDR_MEMBERDATATYPE AND ;
		                 Name == FRX_BLDR_NAMESPACE_ADVANCEDPROPS AND ;
		                 ExecWhen == FRX_BLDR_ADVPROP_HTML_PAGEIMAGEHREF AND ;
		                 INLIST(UPPER(Execute),"YES",".T.","TRUE","1") 
		      IF FOUND()
		         m.toNode.SetAttribute(THIS.pageImageAttr,;
		                               THIS.currentPageImageFileName)
		      ENDIF      
		   ENDIF
		   SELECT FRX              
		ENDIF   
		
		
		
	ENDPROC

	PROCEDURE setfrxdatasessionenvironment
		DODEFAULT()
		SET EXACT ON
		SET SYSFORMATS ON
		SET CENTURY ON
		SET SAFETY OFF
	ENDPROC

	PROCEDURE setfrxrunstartupconditions
		DODEFAULT()
		IF TYPE("THIS.CommandClauses.File") # "C"
		   ADDPROPERTY(THIS.CommandClauses,"File","")
		ENDIF      
		IF TYPE("THIS.CommandClauses.NoPageEject") # "L"
		   ADDPROPERTY(THIS.CommandClauses,"NoPageEject",.F.)
		ENDIF      
		
	ENDPROC

	PROTECTED PROCEDURE synchxsltprocessoruser		&& Can be called in the assign of any Attribute-setting property to synchronize the XSLT associated with the class witht he new attribute values.
		IF THIS.applyUserTransform AND NOT ISNULL(THIS.XSLTProcessorUser)
		   THIS.XSLTProcessorUser = NULL
		   THIS.applyUserTransform = .T. && kickstart
		ENDIF 
	ENDPROC

	PROCEDURE targetfileext_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal) = "C" AND ;
		   NOT UPPER(ALLTRIM(STRTRAN(m.vNewVal,".",""))) == "TMP"
		   DODEFAULT(m.vNewVal)
		   * this class reserves the extension
		   * TMP for swapping in and out when 
		   * using temporary files and XLSTs transforms
		ENDIF   
	ENDPROC

	PROCEDURE topattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.topAttr = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE verifyattributenames		&& Hook method called during XML Listener's augmented version of VerifyConfigTable, allowing subclasses to verify attribute names should they decide to store them in the configuration table similar to node names.
		* abstract
	ENDPROC

	PROCEDURE verifyconfigtable
		LPARAMETERS m.tcAlias
		
		LOCAL m.llReturn, laRequired[1], m.liIndex, m.liSelect, ;
		      m.liTag, m.lcTag, m.lcIndex, m.llSafetyOn, m.llFixedOn
		
		m.llReturn = DODEFAULT(m.tcAlias)
		
		IF m.llReturn
		   * check for required tagnames (used in SEEKs)
		   
		   m.liSelect = SELECT(0)
		   SELECT (m.tcAlias)
		   
		   DIME laRequired[2,2]
		   laRequired[1,1] = "OBJTYPE"
		   laRequired[1,2] = "OBJTYPE"
		   laRequired[2,1] = "FRXNODES"
		   laRequired[2,2] = NORMALIZE("OBJTYPE+OBJCODE+IIF(OBJTYPE="+ ;
		                      TRANSFORM(FRX_OBJTYP_BAND+OUTPUTXML_OBJTYPE_NODES,"9999999")+"," + ;
		                      TRANSFORM(OUTPUTXML_OBJTYPE_BANDOFFSET,"9999999")+",0)")
		   
		   FOR m.liIndex = 1 TO ALEN(laRequired,1)
		       m.liTag = TAGNO(laRequired[m.liIndex,1])
		       IF m.liTag = 0 OR NOT NORMALIZE(KEY(m.liTag)) == ;
		          laRequired[m.liIndex,2]
		          m.llReturn = .F.
		       ENDIF
		   ENDFOR
		   
		   IF NOT m.llReturn
		      m.llSafetyOn = (SET("SAFETY") = "ON")
		      SET SAFETY OFF
		      m.llFixedOn = (SET("FIXED") = "ON")
		      SET FIXED OFF
		   
		      TRY
		         USE (DBF(m.tcAlias)) EXCLU ALIAS (m.tcAlias)
		         FOR m.liIndex = 1 TO ALEN(laRequired,1)
		            m.lcTag = laRequired[m.liIndex,1]
		            m.lcIndex = laRequired[m.liIndex,2]
		            INDEX ON &lcIndex TAG &lcTag
		         ENDFOR
		      
		         m.llReturn = .T.
		      CATCH
		      ENDTRY   
		      
		      
		      IF m.llReturn
		         FOR m.liIndex = 1 TO ALEN(laRequired,1)
		             m.liTag = TAGNO(laRequired[m.liIndex,1])
		             IF m.liTag = 0 OR NOT NORMALIZE(KEY(m.liTag)) == ;
		                laRequired[m.liIndex,2]
		                m.llReturn = .F.
		             ENDIF
		         ENDFOR
		      ENDIF
		      
		      USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
		      
		      IF m.llSafetyOn
		         SET SAFETY ON
		      ENDIF
		      IF m.llFixedOn
		         SET FIXED ON
		      ENDIF
		   
		   ENDIF
		  
		   IF NOT m.llReturn
		      m.lcMessage =  OUTPUTXML_CONFIGTAGMISSING_LOC + CHR(13) 
		      FOR m.liIndex = 1 TO ALEN(laRequired,1)
		          m.lcMessage = m.lcMessage + ;
		                     CHR(13) + laRequired[m.liIndex,1] + ;
		                     "=" + laRequired[m.liIndex,2]
		      ENDFOR               
		      THIS.DoMessage(m.lcMessage,MB_ICONSTOP )      
		      THIS.lastErrorMessage = OUTPUTXML_CONFIGTAGMISSING_LOC
		   ENDIF
		   
		   IF m.llReturn 
		                                  
		     * just do one check, this is in case
		     * a different listener created the config file.
		     * the XML will run just fine without these records,
		     * it will just use its gooftag instead of regular
		     * nodenames if all or any are missing
		
		     IF NOT SEEK( OUTPUTXML_OBJTYPE_NODES+ FRX_OBJTYP_REPORTHEADER, ;
		                               ALIAS(),"ObjType")
		        TRY
		           IF IsReadOnly()
		              USE (DBF(m.tcAlias)) SHARED ALIAS (m.tcAlias)
		           ENDIF
		           THIS.InsertXMLConfigRecords()
		        CATCH
		        ENDTRY   
		                               
		     ENDIF                          
		   
		   ENDIF
		   
		   SELECT (m.liSelect)
		   
		ENDIF
		
		RETURN m.llReturn       
		
		   
	ENDPROC

	PROCEDURE verifyncname		&& Generic method to validate strings as XML-standard NCNames.
		LPARAMETERS m.tcName
		
		LOCAL m.llValid, m.liChar, m.lcChar
		
		DO CASE 
		
		CASE VARTYPE(m.tcName) # "C" OR EMPTY(m.tcName)
		  * invalid
		CASE LEFT(m.tcName,1) # "_" AND NOT ISALPHA(LEFT(m.tcName,1))
		  * invalid
		CASE LEFT(UPPER(m.tcName),3) = "XML"
		  * invalid
		OTHERWISE
		  m.llValid = .T.  
		  FOR m.liChar = 2 TO LEN(tcName)
		     m.lcChar = SUBSTR(m.tcName,m.liChar,1)
		     IF NOT (ISALPHA(m.lcChar) OR ;
		             ISDIGIT(m.lcChar) OR ;
		             INLIST(m.lcChar,".","-","_"))
		        m.llValid = .F.
		        EXIT
		     ENDIF
		  ENDFOR
		ENDCASE
		
		RETURN m.llValid 
	ENDPROC

	PROTECTED PROCEDURE verifynodenames		&& Method called during XML Listener's augmented version of VerifyConfigTable to check all node values in the configuration table for XML validity.
		IF NOT USED("Nodes")
		   RETURN .F.
		ENDIF
		IF ISREADONLY("Nodes")
		   RETURN .T.
		ENDIF   
		   
		LOCAL m.liSelect, m.llSuccess
		m.liSelect = SELECT(0)
		m.llSuccess = .T.
		SELECT Nodes
		SCAN FOR BETWEEN(ObjType,OUTPUTXML_OBJTYPE_NODES,OUTPUTXML_OBJTYPE_NODES+99) ;
		     AND NOT DELETED()
		   IF NOT THIS.VerifyNCName(ObjValue)
		      DELETE
		      m.llSuccess = .F.
		   ENDIF
		ENDSCAN
		                    
		SELECT (m.liSelect)
		RETURN m.llSuccess                    
	ENDPROC

	PROCEDURE widthattr_assign
		LPARAMETERS m.vNewVal
		IF (NOT THIS.IsRunning) AND THIS.VerifyNCName(m.vNewVal)
		   THIS.widthAttr = m.vNewVal
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE writeraw		&& Used to write raw XML data to a file.
		LPARAMETERS m.tcContents
		
		 FWRITE(THIS.TargetHandle, m.tcContents) 
		
	ENDPROC

	PROCEDURE xmlmode_assign
		LPARAMETERS m.vNewVal
		* Readonly during report run
		IF NOT THIS.IsRunning
		   IF VARTYPE(m.vNewVal) = "N" AND ;
		      INLIST(m.vNewVal,;
		             OUTPUTXML_DATA_ONLY,;
		             OUTPUTXML_RDL_ONLY, ;
		             OUTPUTXML_DATA_RDL)
		      THIS.xmlmode = m.vNewVal
		   ENDIF
		ENDIF   
		
	ENDPROC

	PROTECTED PROCEDURE xmlrawconv		&& Used to convert any control characters to entity references when XML Listener is writing raw XML data to a file.
		LPARAMETERS m.tcValue
		LOCAL m.lcValue, m.liChar
		* must have ampersand as the first STRTRAN()      
		m.lcValue = STRTRAN(m.tcValue, '&', '&amp;' )      
		m.lcValue = STRTRAN(m.lcValue, '<', '&lt;' )
		m.lcValue = STRTRAN(m.lcValue, '>', '&gt;' )
		m.lcValue = STRTRAN(m.lcValue, '"', '&quot;' )
		m.lcValue = STRTRAN(m.lcValue, ['], '&apos;' )
		m.lcValue = CHRTRAN(m.lcValue, CHR(0)+CHR(4), "  ")
		RETURN m.lcValue
		* TBD: make any adjustments 
		* and, if needed, for different element types if needed
		
	ENDPROC

	PROTECTED PROCEDURE xmlrawnode		&& Used to formulate the contents of an XML element  node when XML Listener is writing the XML document as raw data to a file.
		LPARAMETERS m.tcNode,m.tcValue, m.tvID, m.tvIDRef, m.tvFormatting
		LOCAL m.lcValue, m.lcNode
		IF PARAMETERS() < 2
		   m.lcValue = ""
		ELSE
		   m.lcValue = THIS.XMLRawConv(m.tcValue)
		ENDIF
		IF EMPTY(m.lcValue) 
		  m.lcNode = THIS.XMLRawTag(m.tcNode,NULL, m.tvID, m.tvIDRef, m.tvFormatting)
		ELSE
		  m.lcNode = THIS.XMLRawTag(m.tcNode, .T., m.tvID, m.tvIDRef, m.tvFormatting)+m.lcValue+THIS.XMLRawTag(m.tcNode)
		ENDIF
		
		RETURN m.lcNode
		   
	ENDPROC

	PROTECTED PROCEDURE xmlrawtag		&& Used to formulate the contents of an XML tag when XML Listener is writing the XML document as raw data to a file.
		LPARAMETERS m.tcNode, m.tlOpen, m.tcID, m.tcIDRef, m.tvFormatting
		LOCAL m.lcNode
		
		IF ISNULL(m.tlOpen) OR m.tlOpen
		   m.lcNode = "<" + m.tcNode 
		   IF NOT EMPTY(m.tcID)
		      m.lcNode = m.lcNode + " "+THIS.idAttribute+"='"+m.tcID+"'"
		   ENDIF
		   IF NOT EMPTY(m.tcIDRef)
		      m.lcNode = m.lcNode + " "+THIS.idRefAttribute+"='"+m.tcIDRef+"'"
		   ENDIF
		   IF NOT EMPTY(m.tvFormatting)
		      m.lcNode = m.lcNode + " " + m.tvFormatting
		   ENDIF
		   IF ISNULL(m.tlOpen)
		      m.lcNode = m.lcNode +  "/"
		   ENDIF
		   m.lcNode = m.lcNode + ">"
		ELSE
		   m.lcNode = "</"+ m.tcNode + ">"   
		ENDIF
		
		RETURN m.lcNode
	ENDPROC

	PROCEDURE xsltparameters_assign
		LPARAMETERS m.vNewVal
		DO CASE
		CASE VARTYPE(m.vNewVal) = "X"
		  THIS.XSLTParameters= NULL
		CASE VARTYPE(m.vNewVal) = "O" 
		   TRY
		     IF UPPER(m.vNewVal.BaseClass) == "COLLECTION" 
		       THIS.XSLTParameters = m.vNewVal
		     ENDIF
		   CATCH 
		   ENDTRY
		OTHERWISE
		  THIS.XSLTParameters= NULL
		ENDCASE
		
		
		
		
		
		
	ENDPROC

	PROCEDURE xsltprocessorrdl_assign
		LPARAMETERS m.vNewVal
		DO CASE
		CASE VARTYPE(m.vNewVal) = "X"
		   THIS.XSLTProcessorRDL = NULL
		CASE VARTYPE(m.vNewVal) = "O" 
		   TRY
		     IF VARTYPE(m.vNewVal.stylesheet) = "O"
		       THIS.XSLTProcessorRDL = m.vNewVal
		     ENDIF
		   CATCH 
		   ENDTRY
		CASE VARTYPE(m.vNewVal) = "C" 
		   LOCAL m.loProcessor
		   m.loProcessor = THIS.LoadProcessorObject(m.vNewVal)
		   IF NOT ISNULL(m.loProcessor)
		      THIS.XSLTProcessorRDL = m.loProcessor
		   ENDIF
		ENDCASE
		
		
		
	ENDPROC

	PROCEDURE xsltprocessoruser_assign
		LPARAMETERS m.vNewVal
		DO CASE
		CASE VARTYPE(m.vNewVal) = "X"
		   THIS.XSLTProcessorUser = NULL
		CASE VARTYPE(m.vNewVal) = "O" 
		   TRY
		     IF VARTYPE(m.vNewVal.stylesheet) = "O"
		       THIS.XSLTProcessorUser = m.vNewVal
		     ENDIF
		   CATCH 
		   ENDTRY
		CASE VARTYPE(m.vNewVal) = "C" 
		   LOCAL m.loProcessor
		   m.loProcessor = THIS.LoadProcessorObject(m.vNewVal)
		   IF NOT ISNULL(m.loProcessor)
		      THIS.XSLTProcessorUser = m.loProcessor
		   ENDIF
		ENDCASE
		
		
		
	ENDPROC

ENDDEFINE
